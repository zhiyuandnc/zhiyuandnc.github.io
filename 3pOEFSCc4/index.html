<html>
<head>
    <meta charset="utf-8"/>
<meta name="description" content=""/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>JavaSE学习 | 絷缘的博客</title>

<link rel="shortcut icon" href="https://zhiyuandnc.github.io/favicon.ico?v=1740567139208">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://zhiyuandnc.github.io/styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
 <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            絷缘的博客
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
                <div class="nav-item">
                    
                        <a href="/" class="menu gt-a-link">
                            首页
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/archives" class="menu gt-a-link">
                            归档
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/tags" class="menu gt-a-link">
                            标签
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/about" class="menu gt-a-link">
                            关于
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/friends" class="menu gt-a-link">
                            友链
                        </a>
                    
                </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1740567139208" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    JavaSE学习
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2021-03-18 ·
                    </time>
                    
                        <a href="https://zhiyuandnc.github.io/LRJO48mE0/" class="post-tags">
                            # JavaSE
                        </a>
                    
                </div>
                <div class="post-content">
                    <h2 id="1-关键字">1. 关键字</h2>
<h3 id="a理解-java中事先定义的含有特别意义的标识符">A.理解： Java中事先定义的，含有特别意义的标识符</h3>
<table>
<thead>
<tr>
<th>private</th>
<th>一种访问控制方式：私有模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>protected</td>
<td>一种访问控制方式：保护模式</td>
</tr>
<tr>
<td>public</td>
<td>一种访问控制方式：公有模式</td>
</tr>
<tr>
<td>abstract</td>
<td>表明类或者成员方法具有抽象属性</td>
</tr>
<tr>
<td>class</td>
<td>类</td>
</tr>
<tr>
<td>extends</td>
<td>表明一个类型是另一个类型的子类型，这里常见的类型有类和接口</td>
</tr>
<tr>
<td>final</td>
<td>用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变</td>
</tr>
<tr>
<td>implements</td>
<td>表明一个类实现了给定的接口</td>
</tr>
<tr>
<td>interface</td>
<td>接口</td>
</tr>
<tr>
<td>native</td>
<td>用来声明一个方法是由与计算机相关的语言（如C/C++/FORTRAN语言）实现的</td>
</tr>
<tr>
<td>new</td>
<td>用来创建新实例对象</td>
</tr>
<tr>
<td>static</td>
<td>表明具有静态属性</td>
</tr>
<tr>
<td>strictfp</td>
<td>用来声明FP_strict（单精度或双精度浮点数）表达式遵循IEEE 754算术规范</td>
</tr>
<tr>
<td>synchronized</td>
<td>表明一段代码需要同步执行</td>
</tr>
<tr>
<td>transient</td>
<td>声明不用序列化的成员域</td>
</tr>
<tr>
<td>volatile</td>
<td>表明两个或者多个变量必须同步地发生变化</td>
</tr>
<tr>
<td>break</td>
<td>提前跳出一个块</td>
</tr>
<tr>
<td>continue</td>
<td>回到一个块的开始处</td>
</tr>
<tr>
<td>return</td>
<td>从成员方法中返回数据</td>
</tr>
<tr>
<td>do</td>
<td>用在do-while循环结构中</td>
</tr>
<tr>
<td>while</td>
<td>用在循环结构中</td>
</tr>
<tr>
<td>if</td>
<td>条件语句的引导词</td>
</tr>
<tr>
<td>else</td>
<td>用在条件语句中，表明当条件不成立时的分支</td>
</tr>
<tr>
<td>for</td>
<td>一种循环结构的引导词</td>
</tr>
<tr>
<td>instanceof</td>
<td>用来测试一个对象是否是指定类型的实例对象</td>
</tr>
<tr>
<td>switch</td>
<td>分支语句结构的引导词</td>
</tr>
<tr>
<td>case</td>
<td>用在switch语句之中，表示其中的一个分支</td>
</tr>
<tr>
<td>default</td>
<td>默认，例如，用在switch语句中，表明一个默认的分支</td>
</tr>
<tr>
<td>try</td>
<td>尝试一个可能抛出异常的程序块</td>
</tr>
<tr>
<td>catch</td>
<td>用在异常处理中，用来捕捉异常</td>
</tr>
<tr>
<td>throw</td>
<td>抛出一个异常</td>
</tr>
<tr>
<td>throws</td>
<td>声明在当前定义的成员方法中所有需要抛出的异常</td>
</tr>
<tr>
<td>import</td>
<td>表明要访问指定的类或包</td>
</tr>
<tr>
<td>package</td>
<td>包</td>
</tr>
<tr>
<td>boolean</td>
<td>基本数据类型之一，布尔类型</td>
</tr>
<tr>
<td>byte</td>
<td>基本数据类型之一，字节类型</td>
</tr>
<tr>
<td>char</td>
<td>基本数据类型之一，字符类型</td>
</tr>
<tr>
<td>double</td>
<td>基本数据类型之一，双精度浮点数类型</td>
</tr>
<tr>
<td>float</td>
<td>基本数据类型之一，单精度浮点数类型</td>
</tr>
<tr>
<td>int</td>
<td>基本数据类型之一，整数类型</td>
</tr>
<tr>
<td>long</td>
<td>基本数据类型之一，长整数类型</td>
</tr>
<tr>
<td>short</td>
<td>基本数据类型之一,短整数类型</td>
</tr>
<tr>
<td>null</td>
<td>空</td>
</tr>
<tr>
<td>true</td>
<td>正确</td>
</tr>
<tr>
<td>false</td>
<td>错误</td>
</tr>
<tr>
<td>super</td>
<td>表明当前对象的父类型的引用或者父类型的构造方法</td>
</tr>
<tr>
<td>this</td>
<td>指向当前实例对象的引用</td>
</tr>
<tr>
<td>void</td>
<td>声明当前成员方法没有返回值</td>
</tr>
<tr>
<td>goto</td>
<td>保留关键字，没有具体含义</td>
</tr>
<tr>
<td>const</td>
<td>保留关键字，没有具体含义</td>
</tr>
</tbody>
</table>
<h2 id="2-保留字">2. 保留字</h2>
<h3 id="a-理解java中事先定义的以后的版本可能被使用的标识符">A. 理解：Java中事先定义的以后的版本可能被使用的标识符</h3>
<p><strong>goto 和 const</strong></p>
<h2 id="3-标识符">3. 标识符</h2>
<h3 id="a-理解用来表示类名变量名方法名类型名数组名文件名的有效字符序列称为标识符通俗讲自己起的名字">A. 理解：用来表示类名，变量名，方法名，类型名，数组名，文件名的有效字符序列称为标识符（通俗讲：自己起的名字）</h3>
<p>组成：</p>
<ul>
<li>数字0-9</li>
<li>字母A-Za-z</li>
<li>下划线_</li>
<li>美元符$</li>
</ul>
<p>注意事项：</p>
<ul>
<li>不能以数字开头，阿里巴巴手册中规定不能以下划线或$开头</li>
<li>命名遵守驼峰命名法
<ul>
<li>大驼峰：类名</li>
<li>小驼峰：方法名，变量名</li>
</ul>
</li>
<li>Java中严格区分大小写</li>
<li>结尾必须以分号结束</li>
<li>写代码时注意缩进，等号前后加空格</li>
</ul>
<h2 id="4-注释">4. 注释</h2>
<h3 id="a-理解用于解释说明程序的文字信息">A. 理解：用于解释说明程序的文字信息</h3>
<h3 id="b-类别">B. 类别：</h3>
<ul>
<li>单行注释：//</li>
<li>多行注释：/**/</li>
<li>文档注释：/***/</li>
</ul>
<h2 id="5-进制转换">5. 进制转换</h2>
<h3 id="a-二进制">A. 二进制</h3>
<ul>
<li>由0，1组成。以0b开头</li>
<li>int num = 0b11011;</li>
</ul>
<h3 id="b-八进制">B. 八进制</h3>
<ul>
<li>由0,1,...7组成。以0开头</li>
<li>int num = 01011;</li>
</ul>
<h3 id="c-十六进制">C. 十六进制</h3>
<ul>
<li>由0,1,...9,a,b,c,d,e,f(大小写均可)组成，以0x开头</li>
<li>int num = 0xac34b;</li>
</ul>
<h3 id="d-十进制">D. 十进制</h3>
<ul>
<li>由0,1,...9组成，默认整数是十进制</li>
<li>int num = 110;</li>
</ul>
<h2 id="6-变量">6. 变量</h2>
<h3 id="a-理解内存中的一块拥有名称可以存储数据的存储区域">A. 理解：内存中的一块拥有名称可以存储数据的存储区域</h3>
<ul>
<li>内存中的一个存储区域</li>
<li>该区域有自己的名称（变量名）、类型（数据类型）、值</li>
<li>Java中每个变量必须先声明，再赋值，然后才能使用</li>
<li>该区域的数据可以在同一类型范围内不断变化</li>
<li>Java 中的变量有四个基本属性：变量名，数据类型，存储单元和变量值</li>
</ul>
<h3 id="b-变量的声明数据类型-变量名-变量值">B. 变量的声明：数据类型   变量名   =    变量值</h3>
<h3 id="c-变量必须初始化才能使用初始化就是给一个初始值">C. 变量必须初始化才能使用，初始化就是给一个初始值</h3>
<h2 id="7-常量">7. 常量</h2>
<h3 id="a-理解在程序中固定不变的值是不能改变的数据">A. 理解：在程序中固定不变的值，是不能改变的数据。</h3>
<h3 id="b-字面常量值不会变化的量">B. 字面常量：（值不会变化的量）</h3>
<ul>
<li>整型常量（int）</li>
<li>浮点数常量（float double） ：2e3f      3.6d      0f      3.84d      5.022e+23f</li>
<li>布尔常量（boolean）：true  false</li>
<li>字符常量（char）：'a'     '1'      '&amp;'      '\r'      '\u0000'</li>
<li>字符串常量（String）：&quot;HelloWorld&quot;       &quot;123&quot;      &quot;We come \n XXX&quot;</li>
<li>null常量（null）：null</li>
</ul>
<h3 id="c-自定义常量">C. 自定义常量：</h3>
<h2 id="8-数据类型">8. 数据类型</h2>
<h3 id="a-基本数据类型">A. 基本数据类型</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>型别</th>
<th>字节</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>整型</td>
<td>1byte（8位）</td>
<td>-2<sup>7</sup> ~ 2<sup>7</sup>-1（-128~127，默认值0）1000 0000固定为-128</td>
</tr>
<tr>
<td>short</td>
<td>整型</td>
<td>2byte（16位）</td>
<td>-2<sup>15</sup> ~ 2<sup>15</sup>-1（-32768~32717，默认值0）1000 0000 0000 0000固定为-32768</td>
</tr>
<tr>
<td>int</td>
<td>整型</td>
<td>4byte（32位）</td>
<td>-2<sup>31</sup> ~ 2<sup>31</sup>-1（-2147483648~2147483647，默认值0）</td>
</tr>
<tr>
<td>long</td>
<td>整型</td>
<td>8byte（64位）</td>
<td>-2<sup>63</sup> ~ 2<sup>63</sup>-1（默认值0L）赋值时要以L结尾</td>
</tr>
<tr>
<td>float</td>
<td>浮点型</td>
<td>4byte（32位）</td>
<td>+3.402823e+38 ~ 1.401298e-45（默认值0）赋值时要以F结尾</td>
</tr>
<tr>
<td>double</td>
<td>浮点型</td>
<td>8byte（64位）</td>
<td>1.797693e+308~ 4.9000000e-324（默认值0）以D结尾，java中浮点型默认为Double，所以不用加D</td>
</tr>
<tr>
<td>char</td>
<td>文本型</td>
<td>2byte（16位）</td>
<td>0 ~ 2<sup>16</sup>-1（取值范围0~65535，默认值为空）</td>
</tr>
<tr>
<td>boolean</td>
<td>布尔型</td>
<td>1byte（8位）</td>
<td>true/false</td>
</tr>
</tbody>
</table>
<h3 id="b-引用数据类型">B. 引用数据类型</h3>
<ul>
<li>字符串</li>
<li>数组</li>
<li>类</li>
<li>接口</li>
<li>Lambda</li>
</ul>
<h3 id="c-注意在数据做为参数传递的时候基本数据类型是值传递引用数据类型是引用传递地址传递">C. 注意：在数据做为参数传递的时候，基本数据类型是值传递，引用数据类型是引用传递（地址传递）</h3>
<h3 id="d-数据类型转换">D. 数据类型转换</h3>
<ul>
<li>
<p><em><strong>默认转换（小转大，小的数据类型的值，赋给大的数据类型的变量）</strong></em></p>
<p>从低精度向高精度转换</p>
<figure data-type="image" tabindex="1"><img src="http://pic.zyblog.xyz/img/typora/20201026163154.png" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="http://pic.zyblog.xyz/img/typora/20201031083512.png" alt="img" loading="lazy"></figure>
<blockquote>
<p>long-&gt;float的自动转型参考：https://blog.csdn.net/writing_happy/article/details/78880606</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>浮点数在内存中的存储形式参考：https://blog.csdn.net/u014470361/article/details/79820892</p>
</blockquote>
<pre><code class="language-java">public class DataTypeDemo{
    public static void main(String [] args){
        System.out.println(1024); //这是一个整数，整数有byte、short、int、long四种，java中默认为int
        System.out.println(3.14); //这是一个浮点数，浮点数有float、double两种，java中默认为double
        long num1 = 1024L;   //加了L，为long类型
        System.out.println(num1);
        
        long num2 = 1024;	//未加L，默认为int类型，依然可以正常输出，中间发生了自动转换，int到long
        System.out.println(num2);
        
        double num3 = 2.5F;	//加了F，为float类型，发生自动转换，float到double
        System.out.println(num3);
        
        double num4 = 2.5;	//未加F，默认为double类型
        System.out.println(num4);
        
        float num5 = 30L;	//加了L，为long类型，依然可以正常输出，中间发生了自动转换，long到float
        System.out.println(num5);
        
        byte num6 = 25;
        int num7 = num6;
        System.out.println(num7); //可以正常输出，发生了自动类型的转换，byte到int
        
        byte num8 = 35;
        short num9 = num8;
        System.out.println(num9); //可以正常输出，发生了自动类型转换，byte到short
        
        short num10 = 100;
        int num11 = num10;
        System.out.println(num11); //可以正常输出，发生了自动类型转换，short到int
    }
}
</code></pre>
<ul>
<li><em><strong>强制转换的格式：大数据类型 变量名称 = (大数据类型)(小数据类型)</strong></em></li>
<li>注意：强制转换的格式是在需要转型的数据前加上“( )”，然后在括号内加入需要转化的数据类型。数据经过转型运算后，精度会丢失
<ul>
<li>char不能转换为short和byte</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public static void main(String[] args){
    int num = 127;
    byte by = 122;
    by = (byte)num;
}
</code></pre>
<ul>
<li>byte/short/char 默认都可以发生数学运算，在运算的时候会被提升为int类型计算</li>
</ul>
<pre><code class="language-java">public static void main(String [] args){
    char c = 'A'; 				// A的ASCII码为65
    System.out.println(c + 1); 	// 66
}
</code></pre>
<pre><code class="language-java">byte b1 = 20;
byte b2 = 22;
int b = b1 + b2;   	//byte被提升为int型并进行了数学运算，计算结果也是int

short s1 = 34;
short s2 = 32;
int s = s1 + s2;	//short被提升为int型并进行了数学运算，计算结果也是int
</code></pre>
<ul>
<li>布尔类型不能发生数据类型转换</li>
</ul>
<blockquote>
<p>在ASCII码表中，48表示字符0，65表示大写A，97表示小写a</p>
</blockquote>
<blockquote>
<p>JDK9新特性：“ 编译器常量优化 ”：当两个常量运算时，如果运算结果数值没有超过左侧变量类型的范围，则正常输出，右侧一旦出现变量，就无法参与这项优化</p>
</blockquote>
<h2 id="9-字符集和字符编码">9. 字符集和字符编码</h2>
<h3 id="a-为了实现计算机认识字母-符号-图形">A. 为了实现计算机认识字母、符号、图形</h3>
<h3 id="b-字符集就是字母数字指定的二进制编码">B. 字符集就是字母数字指定的二进制编码</h3>
<h3 id="c-字符集制成的表示字符编码表">C. 字符集制成的表示字符编码表</h3>
<ul>
<li>
<p>ASCII</p>
</li>
<li>
<p>GBK</p>
</li>
<li>
<p>GB2312</p>
</li>
<li>
<p>w3c出面制成统一码表：unicode码表</p>
<ul>
<li>
<p>按照进制制成新的码表</p>
</li>
<li>
<p>utf-8</p>
</li>
<li>
<p>utf-16</p>
</li>
<li>
<p>utf-32</p>
</li>
</ul>
</li>
</ul>
<h2 id="10-运算符">10. 运算符</h2>
<h3 id="a-算数运算符">A. 算数运算符</h3>
<ul>
<li>
<ul>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
</ul>
</li>
<li>/</li>
<li>%</li>
<li>++
<ul>
<li>前++：先运算再赋值</li>
<li>后++：先赋值再运算</li>
</ul>
</li>
<li>--
<ul>
<li>前--：先运算再赋值</li>
<li>后--：先赋值再运算</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public static void main(String [] args){
    int num = 999;
    int num1 = 300;
    System.out.println(num+num1);
    System.out.println(num-num1);
    System.out.println(num*num1);
    System.out.println(num/num1);
    System.out.println(num%num1);
    System.out.println(num1%num);//小的数取模于大的数，得到的是本身（小的数）
    int num2 = 3;
    num2++;
    num2--;
}
</code></pre>
<h3 id="b-赋值运算符">B. 赋值运算符</h3>
<ul>
<li>=</li>
<li>+=</li>
<li>-=</li>
<li>*=</li>
<li>/=</li>
<li>%=</li>
</ul>
<blockquote>
<p>补充：b+=4不等于b=b+4，扩展的赋值运算符都隐含了强制类型转换 ，等价于b=(b的数据类型)b+4；</p>
</blockquote>
<blockquote>
<p>instanceof：判断是否是类的对象 &quot;String&quot; instanceof  String</p>
</blockquote>
<pre><code class="language-java">public static void main(String [] args){
    String name = &quot;zhiyuan&quot;;
    int sum = 666;
    sum = sum + 20;
    sum += 20; //上边的简写形式
}
</code></pre>
<h3 id="c-比较关系运算符">C. 比较（关系）运算符</h3>
<ul>
<li>
<p>&gt;</p>
</li>
<li>
<p>&lt;</p>
</li>
<li>
<p>&gt;=</p>
</li>
<li>
<p>&lt;=</p>
</li>
<li>
<p>!=</p>
</li>
<li>
<p>==</p>
<ul>
<li>基本数据类型，比较值是否相等</li>
<li>引用数据类型，比较地址值是否相等</li>
<li>和equals的区别</li>
</ul>
</li>
<li>
<p>运算结果为boolean值</p>
<pre><code class="language-java">public static void main(String [] args){
    System.out.println(100 &gt; 20);
    System.out.println(100 &lt; 200);
    System.out.println(100 &gt;= 200);
    System.out.println(100 &lt;= 200);
    System.out.println(100 != 200);
    System.out.println(100 == 200);
}
</code></pre>
</li>
</ul>
<h3 id="d-逻辑运算符左右两侧均为布尔表达式">D. 逻辑运算符（左右两侧均为布尔表达式）</h3>
<ul>
<li>
<p>&amp;：逻辑与</p>
</li>
<li>
<p>|：逻辑或</p>
</li>
<li>
<p>&amp;&amp;：左右两侧都成立，结果成立（全真为真，有假为假）（短路与）</p>
</li>
<li>
<p>||  ：左右两侧有一个成立，结果成立（有真为真，全假为假），前面成立，后面无需看结果（短路或）</p>
</li>
<li>
<p>！：取反</p>
</li>
</ul>
<pre><code class="language-java">public static void main(String [] args){
    System.out.println(100 &gt; 20 &amp;&amp; 200 &gt; 300);
    System.out.println(100 &lt; 200 &amp;&amp; 200 &lt; 100);
    
    System.out.println(100 &gt; 20 || 200 &gt; 300);
    System.out.println(100 &lt; 200 || 200 &lt; 100);
    
    System.out.println(!(100 &gt; 20));
}
</code></pre>
<h3 id="e-位运算符位运算是最快的">E. 位运算符（位运算是最快的）</h3>
<ul>
<li>
<p>&amp;：（二进制补码按位与）</p>
</li>
<li>
<p>|  ：（二进制补码按位或）</p>
</li>
<li>
<p>^：（二进制补码按位异或）一个数对另外一个数按位异或两遍，还是它本身</p>
</li>
<li>
<p>&lt;&lt;：（二进制按位左移）次方运算直接左移（次方-1）位</p>
<blockquote>
<p>12 &lt;&lt; 2      12*2^2 = 48</p>
</blockquote>
</li>
<li>
<p>&gt;&gt;：（二进制按位右移）</p>
<blockquote>
<p>12 &gt;&gt; 2      12/2^2 = 3</p>
</blockquote>
</li>
<li>
<p>~</p>
</li>
<li>
<p>&gt;&gt;&gt;：无符号右移规则和右移运算是一样的，只是填充时不管左边的数字是正是负都用0来填充，无符号右移运算只针对负数计算，因为对于正数来说这种运算没有意义</p>
</li>
</ul>
<pre><code class="language-java">public static void main(String [] args){
    System.out.println(8 &amp; 3);
    System.out.println(8 | 3);
    System.out.println(8 ^ 3);
    System.out.println(8 &lt;&lt; 3);
    System.out.println(8 &gt;&gt; 3);
}
</code></pre>
<h3 id="f-三元三目运算符">F. 三元（三目）运算符</h3>
<ul>
<li>表达式 ? 成立结果 : 不成立结果</li>
</ul>
<pre><code class="language-java">public static void main(String [] args){
    System.out.println(8 &gt; 3 ? true : false);   
}    
</code></pre>
<h3 id="g-instanceof运算符">G. instanceof运算符</h3>
<ul>
<li>java中，instanceof运算符的前一个操作符是一个引用变量，后一个操作数通常是一个类（可以是接口），用于判断前面的对象是否是后面的类，或者其子类、实现类的实例。如果是返回true，否则返回false。</li>
</ul>
<h2 id="11-转义字符">11. 转义字符</h2>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\r</td>
<td>回车符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>\b</td>
<td>退格符</td>
</tr>
<tr>
<td>\'</td>
<td>单引号字符</td>
</tr>
<tr>
<td>\''</td>
<td>双引号字符</td>
</tr>
<tr>
<td>\\</td>
<td>反斜杠字符</td>
</tr>
</tbody>
</table>
<h2 id="12-流程控制语句">12. 流程控制语句</h2>
<h3 id="a-顺序语句代码执行的时候是从上到下从左到右的">A. 顺序语句：代码执行的时候是从上到下，从左到右的</h3>
<h3 id="b-分支语句">B. 分支语句：</h3>
<ul>
<li>
<p>if语句</p>
<pre><code class="language-java">public class ControlDemo {
    public static void main(String[] args) {
        int num = 10;
        if(num &gt; 5){
            System.out.println(num + &quot; &gt; 5&quot;);
        }
    }
}
</code></pre>
</li>
<li>
<p>if-else语句</p>
<pre><code class="language-java">public class ControlDemo {
    public static void main(String[] args) {
        int num = 3;
        if(num &gt; 5){
            System.out.println(num + &quot; &gt; 5&quot;);
        }else{
            System.out.println(num + &quot; &lt; 5&quot;);
        }
    }
}
</code></pre>
</li>
<li>
<p>if-else-if-else语句</p>
</li>
</ul>
<pre><code class="language-java">// if else if else语句
public class ControlDemo {
    public static void main(String[] args) {
        int age = 20;
        double height = 120.0;
        if(age &gt; 10){
            System.out.println(age + &quot; &gt; 10&quot;);
        }else if(height &lt; 120){
            System.out.println(height + &quot; &lt; 120&quot;);
        }else{
            System.out.println(age + &quot; &lt; 10&quot; + height + &quot; &gt; 120&quot;);
        }
    }
}        
</code></pre>
<pre><code class="language-java">import java.util.Scanner;

public class ScannerDemo {
    public static void main(String[] args) {
        // 根据用户输入的成绩，判断是哪一个等级
        Scanner sc = new Scanner(System.in);//System.in系统的标准输入
        // String str = sc.next();
        //String str = sc.nextLine();
        int score = sc.nextInt();
        System.out.println(score);
        if (score &gt; 90) {
            System.out.println(&quot;优&quot;);
        }else if(score &gt; 80){
            System.out.println(&quot;甲&quot;);
        }else if(score &gt; 70){
            System.out.println(&quot;乙&quot;);
        }else if(score &gt; 60){
            System.out.println(&quot;丙&quot;);
        }else {
            System.out.println(&quot;丁&quot;);
        }
    }
}
</code></pre>
<ul>
<li>switch语句（break不可省略）</li>
</ul>
<pre><code class="language-java">import java.util.Scanner;

public class ControlDemo {
    public static void main(String[] args) {        
	//switch语句（int、char、byte、short、String【JDK1.7新增】）
        Scanner sc = new Scanner(System.in);
        int i = sc.nextInt();
        switch(i){
            case 1:
                System.out.println(&quot;星期一&quot;);break;
            case 2:
                System.out.println(&quot;星期二&quot;);break;
            case 3:
                System.out.println(&quot;星期三&quot;);break;
            case 4:
                System.out.println(&quot;星期四&quot;);break;
            case 5:
                System.out.println(&quot;星期五&quot;);break;
            case 6:
                System.out.println(&quot;星期六&quot;);break;
            case 7:
                System.out.println(&quot;星期日&quot;);break;
            default:
                System.out.println(&quot;没有&quot;);break;
        }
    }
}
</code></pre>
<h3 id="c-循环语句">C. 循环语句：</h3>
<blockquote>
<p>注意：如果出现死循环，程序不能及时停止，会出现值栈溢出Stack Overflow（内存溢出）</p>
<p>所以在使用while循环的时候，我们要在适当的时侯终止循环，结合if else使用break终止循环，直接退出循环最外层，不再执行循环</p>
</blockquote>
<blockquote>
<p>break是直接终止循环</p>
<p>continue是终止本次循环，进行下次循环，直到循环执行结束</p>
</blockquote>
<ul>
<li><strong>while（布尔表达式）{循环体}</strong></li>
</ul>
<pre><code class="language-java">public class WhileDemo {
    public static void main(String[] args) {
        //while循环 控制循环条件的变量值，固定循环次数
        int flag = 10;
        while(flag &gt; 0){
            System.out.println(&quot;循环正常执行&quot;);
            flag --;
        }
    }
}    
</code></pre>
<ul>
<li><strong>do {循环体} while（布尔表达式）</strong></li>
</ul>
<pre><code class="language-java">public class DoWhileDemo {
    public static void main(String[] args) {
        public class DoWhileDemo {
    public static void main(String[] args) {
        //do while 循环 即使条件不成立，也会执行一次
        int num = 10;
        do{
            System.out.println(&quot;循环正常执行&quot; + num);
            num --;
        }while(num &gt; 0);
    }
}
</code></pre>
<ul>
<li><strong>for（初始化语句；循环条件；迭代体）{循环体}</strong></li>
</ul>
<pre><code class="language-java">public class ForDemo {
    public static void main(String[] args) {
        //for循环 循环次数是初始变量值和循环条件计算得出的
        //i++和++i在for循环中没有区别
        for (int i = 0;i &lt;= 10;i++){
            System.out.println(i);
        }
    }
} 
</code></pre>
<ul>
<li><strong>死循环</strong></li>
</ul>
<pre><code class="language-java">for(;;){}

while(true){}

do{}while(true);
</code></pre>
<blockquote>
<p>print 和 println的区别</p>
<p>print：直接输出      println：换行输出</p>
</blockquote>
<h3 id="d-循环嵌套">D. 循环嵌套：</h3>
<blockquote>
<p>我们可以使用循环去做很多事情</p>
<p>打印九九乘法表</p>
<pre><code class="language-java">public class CombineForDemo {
  public static void main(String[] args) {
    //九九乘法表
    //外层循环控制行
      for(int i = 1;i &lt;= 9;i++){
         //内层循环控制列
         for(int k = 1;k &lt;= i;k++){
           System.out.print(k+&quot;×&quot;+i+&quot;=&quot;+i*k+&quot;\t&quot;);
         }
         System.out.println(&quot;&quot;);
      }
  }
}
</code></pre>
<pre><code class="language-java">1×1=1	
1×2=2	2×2=4	
1×3=3	2×3=6	3×3=9	
1×4=4	2×4=8	3×4=12	4×4=16	
1×5=5	2×5=10	3×5=15	4×5=20	5×5=25	
1×6=6	2×6=12	3×6=18	4×6=24	5×6=30	6×6=36	
1×7=7	2×7=14	3×7=21	4×7=28	5×7=35	6×7=42	7×7=49	
1×8=8	2×8=16	3×8=24	4×8=32	5×8=40	6×8=48	7×8=56	8×8=64	
1×9=9	2×9=18	3×9=27	4×9=36	5×9=45	6×9=54	7×9=63	8×9=72	9×9=81
</code></pre>
<p>输出菱形</p>
<pre><code class="language-java">public class DiamondDemo {
  public static void main(String[] args) {
    //菱形
    for (int i = 1;i &lt;= 5;i++){
        for (int k = 5 - i;k &gt;= 0;k--){
             System.out.print(&quot; &quot;);
         }
        for (int j = 1;j &lt;= 2*i-1;j++){
              System.out.print(&quot;*&quot;);
          }
          System.out.println(&quot;&quot;);
      }
      for (int i = 4;i &gt;= 1;i--){
          for (int k = 1; k &lt;= 6-i;k++){
              System.out.print(&quot; &quot;);
          }
          for (int j = 1;j &lt;= 2*i-1;j++){
              System.out.print(&quot;*&quot;);
          }
          System.out.println(&quot;&quot;);
      }
  }
}
</code></pre>
<p>输出等腰三角形</p>
<pre><code class="language-java">public class IsoscelesTriangleDemo {
  public static void main(String[] args) {
    //等腰三角形
    int num = 6;
    for(int i = 0;i &lt;= num;i++){
       //打印空格占位
       //前半边占位的空格和行数的关系，是总的行数-1
        for(int k = num - i;k &gt;= 0;k--){
              System.out.print(&quot; &quot;);
          }
          //打印后半部分星号
          for(int j = 1;j &lt;= 2*i-1;j++){
              System.out.print(&quot;*&quot;);
          }
          //负责换行
          System.out.println(&quot;&quot;);
      }
  }
}
</code></pre>
<p>求1000以内的水仙花数</p>
<pre><code class="language-java">public class DaffodilsNumDemo {
  public static void main(String[] args) {
  //水仙花数
    for(int i = 100;i &lt; 1000;i++){
        int onesplace = i % 10; //个位
         int hundredsplace = i / 100; //百位
         int tenplace = i / 10 % 10; //十位
         int newvalue = onesplace*onesplace*onesplace + tenplace*tenplace*tenplace + hundredsplace*hundredsplace*hundredsplace;
         if(newvalue == i){
              System.out.println(&quot;水仙花数：&quot; + i);
          }
      }
  }
}
</code></pre>
<p>求1000以内的素数</p>
<pre><code class="language-java">public class PrimeNumberDemo {
  public static void main(String[] args) {
    for(int i = 2;i &lt; 1000;i++){
       for(int j = 2;j &lt; i;j++){
          if(i % j == 0){
               break;
           }else{
                System.out.println(i+&quot;为素数&quot;);
                  break;
              }
          }
      }
  }
}
</code></pre>
<p>求100以内的7的倍数</p>
<pre><code class="language-java">public class SevenTimesDemo {
  public static void main(String[] args) {
    for(int i = 0;i &lt; 100;i++){
      if(i % 7 == 0){
           System.out.println(i+&quot;是7的倍数&quot;);
         }
    }
  }
}
</code></pre>
<p>今有雉兔同笼，上有三十五头，下有九十四足，问雉兔各几何？</p>
<pre><code class="language-java">public class ChickenRabbitCageDemo {
  public static void main(String[] args) {
    int count = 35;
    int foot = 94;
    int chickencount;
    int rabbitcount;
    for(chickencount = 1;chickencount &lt;= 35;chickencount++){
       	rabbitcount = count - chickencount;
         if (chickencount*2+rabbitcount*4 == 94) {
           System.out.println(&quot;鸡有&quot;+chickencount+&quot;只&quot;);
           System.out.println(&quot;兔有&quot;+rabbitcount+&quot;只&quot;);
           break;
         }
      }
  }
}
</code></pre>
<p>有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问一年后的兔子总数为多少？（斐波那契数列）</p>
<p>1   1   2    3    5    8    13    21</p>
<pre><code class="language-java">int month = 12;
int first = 1;
int second = 1;
int count = 0;
for(int i = 3;i &lt;= month;i++){
	count = first + second;
	first = second;
	second = count;
	System.out.println(i+&quot;月份生的兔子的总数是：&quot;+count*2); //288
}
</code></pre>
<p>3	3	3	3	3</p>
<p>3	2	2	2	3</p>
<p>3	2	1	2	3</p>
<p>3	2	2	2	3</p>
<p>3	3	3	3	3</p>
<pre><code class="language-java">for(int i = 0;i &lt; 7;i++){
  if(i==0 &amp;&amp; i == 13){
   System.out.println(&quot;7&quot;);
  }
}
</code></pre>
</blockquote>
<h3 id="e-debug调试工具">E. Debug调试工具</h3>
<figure data-type="image" tabindex="3"><img src="http://pic.zyblog.xyz/img/typora/20201021161002.png" alt="image-20201021161002815" loading="lazy"></figure>
<h3 id="f-指定跳转的位置java的标签">F. 指定跳转的位置（java的标签）</h3>
<blockquote>
<p>结合循环的break使用，指定程序中断跳出到循环外的位置</p>
</blockquote>
<ul>
<li>break</li>
</ul>
<pre><code class="language-java">wc:for(int i = 0;i &lt; 4;i++){
    nc:for(int j = 0;j &lt; 5;j++){
        if(j == 3){
            //break;
            //break nc;
            break wc;
        }
        System.out.println(&quot;*&quot;);
    }
    System.out.println();
}

//输出结果
***
</code></pre>
<ul>
<li>continue</li>
</ul>
<pre><code class="language-java">wc:for(int i = 0;i &lt; 4;i++){
    nc:for(int j = 0;j &lt; 5;j++){
        if(j == 3){
            //continue;
            //continue nc;
            continue wc;
        }
        System.out.println(&quot;*&quot;);
    }
    System.out.println();
}

//输出结果
************
</code></pre>
<ul>
<li>return也可以结束循环，不过本质是结束方法</li>
</ul>
<h2 id="13-数组">13. 数组</h2>
<h3 id="a-数组只能保存一种类型的数据">A. 数组只能保存一种类型的数据</h3>
<h3 id="b-数组只要声明了那么数组的长度在程序运行过程中就是固定不可变化的即使移除数组的值">B. 数组只要声明了，那么数组的长度在程序运行过程中就是固定不可变化的，即使移除数组的值</h3>
<h3 id="c-数组的声明">C. 数组的声明</h3>
<ul>
<li>静态声明：在声明数组的时候，给数组将值添加进去，然后由系统计算数组的长度</li>
</ul>
<pre><code class="language-java">int [] arr = new int[]{0,1,2,3,4,5,6,7,8,9};
</code></pre>
<ul>
<li>动态声明：在声明数组的时候，固定数组的长度，然后由系统添加数组中的初始值</li>
</ul>
<pre><code class="language-java">int [] arr = new int[10];
</code></pre>
<ul>
<li>基本类型各自初始化值
<ul>
<li>int类型，默认初始值为0</li>
<li>long类型，默认初始值为0</li>
<li>short类型，默认初始值为0</li>
<li>byte类型，默认初始值为0</li>
<li>char类型，默认初始值为\u0000（unicode字符，不可见）</li>
<li>float类型，默认初始值为0.0</li>
<li>double类型，默认初始值0.0</li>
<li>boolean类型，默认值false</li>
<li>引用数据类型，默认初始值为null（空常量）</li>
</ul>
</li>
<li>数组是引用数据类型</li>
</ul>
<h3 id="d-一维数组">D. 一维数组</h3>
<blockquote>
<ul>
<li>数组的声明
<ul>
<li>静态声明：数据类型 []  变量名称   =    new   数据类型[] {值1，值2，值3}</li>
<li>动态声明：数据类型   []   变量名称   =   new   数据类型[数组的长度]；</li>
<li>数组声明的简写形式：数据类型   []   变量名称  =  {值1，值2，值3}</li>
</ul>
</li>
<li>length表示数组的长度</li>
</ul>
</blockquote>
<h3 id="e-数组的遍历">E. 数组的遍历</h3>
<pre><code class="language-java">public class ArrayListDemo {
    public static void main(String[] args) { 
        int [] arr = new int[]{10,12,13,14,15,16};
        System.out.println(arr[0]);
        for (int i = 0; i &lt; arr.length; i++) {
            System.out.println(&quot;arr[&quot; + i + &quot;]=&quot; + arr[i]);
        }
        //增强for循环（foreach）
        //for（数组中元素的数据类型 i代表的是下表位的元素的值 ：数组或者集合）
        for (int i : arr) {
            System.out.println(i);
        }
    }
}
</code></pre>
<pre><code class="language-java">//运行结果
10
arr[0]=10
arr[1]=12
arr[2]=13
arr[3]=14
arr[4]=15
arr[5]=16
10
12
13
14
15
16
</code></pre>
<blockquote>
<p>练习：int  [] arr = new int [] {21,3,41,45,67,2,78,6};中的最大值与最小值</p>
<pre><code class="language-java">public static void main(String [] args){
   for (int i = 0; i &lt; arr.length ; i++) {
       for(int k = i+1; j &lt;= arr.length;j++) {
           if(arr[i] &gt; arr[j]){
               int temp = arr[i];
               arr[i] = arr[j];
               arr[j] = temp;
           }
       }
   }
   for(int k : arr){
       System.out.println(i);
   }
}
</code></pre>
<pre><code class="language-java">最大值为：78
最小值为：2
</code></pre>
<pre><code class="language-java">public class ArrayMaxMinDemo {
 public static void main(String[] args) {
     int [] arr = new int []{21,3,41,45,67,2,78,6};
     //从数组中拿任意一个数
     //进行数组中其他元素比较，按照比较的结果进行换位
     int num = arr[0];
     for (int i = 0; i &lt; arr.length; i++) {
         if(num &gt; arr[0]){
             num = arr[0];
         }
     }
     System.out.println(&quot;最小值为：&quot;+num);
 }
}
</code></pre>
</blockquote>
<h3 id="f-二维数组">F. 二维数组</h3>
<ul>
<li>一维数组的下标位依然是一个一维数组，这种数组就是二维数组</li>
<li>二维数组的声明
<ul>
<li>数据类型 [] [] 变量名称  =  new  int  [] []{};</li>
<li>数据类型 [] [] 变量名称  =  new  int  [3] [4];</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code class="language-java">public class SecondArrayDemo {
 public static void main(String[] args) {
     int [][] arr = new int[][]{{2,3,4},{5,6,7},{8,9,10}};
     int [][] arr1 = new int[3][4];
     //获取值
//        System.out.println(arr[0][0]);
//        System.out.println(arr[0][1]);
//        System.out.println(arr[0][2]);
//
//        System.out.println(arr[1][0]);
//        System.out.println(arr[1][1]);
//        System.out.println(arr[1][2]);
//
//        System.out.println(arr[2][0]);
//        System.out.println(arr[2][1]);
//        System.out.println(arr[2][2]);

     arr1[0][0] = 11;
     arr1[0][1] = 12;
     arr1[0][2] = 13;
     arr1[0][3] = 14;

     arr1[1][0] = 24;
     arr1[1][1] = 23;
     arr1[1][2] = 22;
     arr1[1][3] = 21;

     arr1[2][0] = 51;
     arr1[2][1] = 52;
     arr1[2][2] = 53;
     arr1[2][3] = 54;

//        System.out.println(arr1[0][0]);
//        System.out.println(arr1[0][1]);
//        System.out.println(arr1[0][2]);
//        System.out.println(arr1[0][3]);
//
//        System.out.println(arr1[1][0]);
//        System.out.println(arr1[1][1]);
//        System.out.println(arr1[1][2]);
//        System.out.println(arr1[1][3]);
//
//        System.out.println(arr1[2][0]);
//        System.out.println(arr1[2][1]);
//        System.out.println(arr1[2][2]);
//        System.out.println(arr1[2][3]);


     for (int i = 0 ; i &lt; arr.length ; i++){
         for(int j = 0 ; j &lt; arr[i].length ; j++){
             System.out.println(&quot;arr[&quot;+i+&quot;][&quot;+j+&quot;]=&quot;+arr[i][j]);
         }
     }
 }
}
</code></pre>
</blockquote>
<h3 id="g-数组的排序">G. 数组的排序</h3>
<blockquote>
<ul>
<li>冒泡排序</li>
<li>选择排序</li>
<li>插入排序</li>
<li>快速排序</li>
<li>希尔排序</li>
<li>归并排序</li>
<li>折中排序</li>
<li>桶排序</li>
</ul>
<h2 id="选择排序">选择排序</h2>
<pre><code class="language-java">public class ArraySelectorSortDemo {
 public static void main(String[] args) {
     int [] arr = new int []{21,3,41,45,67,2,78,6};
     //选择排序
     for (int i = 0; i &lt; arr.length-1; i++) {
         for (int j = i+1; j &lt; arr.length; j++) {
             if(arr[i] &gt; arr[j]){
                 int temp = arr[i];
                 arr[i] = arr[j];
                 arr[j] = temp;
             }
         }
     }
     for (int i : arr) {
         System.out.println(i);
     }

 }
}
</code></pre>
<figure data-type="image" tabindex="4"><img src="http://pic.zyblog.xyz/img/typora/20201023103112.gif" alt="img" loading="lazy"></figure>
<h2 id="冒泡排序">冒泡排序</h2>
<pre><code class="language-java">public class ArrayBubbleSortDemo {
    public static void main(String[] args) {
        //冒泡排序：数组间两两之间进行比较，按照排序规则进行换位
        int [] arr = new int []{21,3,41,45,67,2,78,6};
        for (int i = 0; i &lt; arr.length; i++) {
            for (int j = 0; j &lt; arr.length - i - 1; j++) {
                if(arr[j] &gt; arr[j+1]){
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                }
            }
        }
        for (int i : arr) {
            System.out.println(i);
        }
    }
}

</code></pre>
<figure data-type="image" tabindex="5"><img src="http://pic.zyblog.xyz/img/typora/20201022113603.gif" alt="选择排序" loading="lazy"></figure>
<h2 id="插入排序">插入排序</h2>
<pre><code class="language-java">public static void main(String[] args) {
        int [] arr = new int [] {21,3,41,45,67,2,78,6};

        for(int i = 0;i &lt; arr.length-1;i++){
            //当前准备比较的值
            int temp  = arr[i+1];
             int num = i;
           //当前位置的值和前面所有的值比较进行换位
           while(num &gt;= 0 &amp;&amp; temp &lt; arr[num] ){
               arr[num + 1] = arr[num ];
                num --;
           }
           arr[num + 1] = temp;
        }
        for (int k : arr) {
            System.out.println(k);
        }
    }

</code></pre>
<pre><code class="language-java">public class ArrayInsertSortDemo {
    public static void main(String[] args) {
        int [] arr = new int []{21,3,41,45,67,2,78,6};
        int temp;
        int i;
        int j;
        for(i = 1;i &lt; arr.length;i++){
            for (j = i;j &gt; 0;j--){
                if(arr[j] &lt; arr[j-1]){
                    swap(arr,j,j-1);
                }
            }
        }
        for (int k : arr) {
            System.out.println(k);
        }
    }
    public static void swap(int [] arr,int i,int j){
        int temp = arr[j];
        arr[j] = arr[i];
        arr[i] = temp;
    }
}

</code></pre>
<figure data-type="image" tabindex="6"><img src="http://pic.zyblog.xyz/img/typora/20201023102920.webp" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="http://pic.zyblog.xyz/img/typora/20201023102943.gif" alt="img" loading="lazy"></figure>
<h2 id="快速排序">快速排序</h2>
<figure data-type="image" tabindex="8"><img src="http://pic.zyblog.xyz/img/typora/20201116130933.gif" alt="img" loading="lazy"></figure>
</blockquote>
<h3 id="h-元素的查找">H. 元素的查找</h3>
<ul>
<li>
<p>二分查找（折半查找）</p>
<ul>
<li>要求数组本身有序，不能对数组排序后使用二分查找，因为会改变元素本身位置</li>
</ul>
<pre><code class="language-java">public static int getIndex(int [] array,int value){
    int left = 0;
    int right = array.length - 1;
    while(left &lt;= right){
        int mid = (left + right) / 2;
        if (array[mid] &gt;= key) {
            right = mid - 1;
        }else {
            left = mid + 1;
        }
    }
    if(left &lt; arrat.length-1 &amp;&amp; array[left] == key){
        return left;
    }
    return -1;
}
</code></pre>
</li>
<li>
<p>基本查找（数组元素无序）</p>
</li>
</ul>
<h2 id="14-java的内存模型">14. java的内存模型</h2>
<blockquote>
<p>java内存模型(Java Memory Model，JMM)是java虚拟机规范定义的，用来屏蔽掉java程序在各种不同的硬件和操作系统对内存的访问的差异，这样就可以实现java程序在各种不同的平台上都能达到内存访问的一致性。可以避免像c++等直接使用物理硬件和操作系统的内存模型在不同操作系统和硬件平台下表现不同，比如有些c/c++程序可能在windows平台运行正常，而在linux平台却运行有问题。</p>
</blockquote>
<figure data-type="image" tabindex="9"><img src="http://pic.zyblog.xyz/img/typora/20201031151932.png" alt="img" loading="lazy"></figure>
<ul>
<li>JDK8之前的JVM内存布局</li>
</ul>
<figure data-type="image" tabindex="10"><img src="http://pic.zyblog.xyz/img/typora/20201031182849.png" alt="img" loading="lazy"></figure>
<ul>
<li>JDK8以后的JVM内存布局</li>
</ul>
<figure data-type="image" tabindex="11"><img src="http://pic.zyblog.xyz/img/typora/20201031182721.png" alt="图摘自《码出高效》" loading="lazy"></figure>
<blockquote>
<p>栈内存是先进后出</p>
<p>栈内存只能保存基本数据类型的变量和值</p>
<p>栈内存保存对象的变量，引用到堆内存中的地址值</p>
<p>只要使用了new关键字就会在堆内存中开辟空间，new使用一次开辟一次</p>
</blockquote>
<ul>
<li>本地方法区</li>
<li>栈内存：int  num  =  10；基本数据类型声明变量</li>
<li>堆内存：new  引用数据类型  栈内存对象的变量引用堆内存的十六进制地址值</li>
</ul>
<h2 id="15-方法">15. 方法</h2>
<h3 id="a-理解对一段代码的封装">A. 理解：对一段代码的封装</h3>
<blockquote>
<p>访问修饰符   修饰符   返回值类型   方法名（形参列表）{</p>
<p>​			方法体；</p>
<p>}</p>
<p>public  static  void  main（String [] args）{</p>
<p>​			System.out.println(&quot;Hello&quot;)；</p>
<p>}</p>
</blockquote>
<blockquote>
<p>方法的分类：</p>
<ul>
<li>返回值
<ul>
<li>有返回值：</li>
<li>无返回值：</li>
</ul>
</li>
<li>参数
<ul>
<li>有参数</li>
<li>无参数</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>访问权限修饰符：
<ul>
<li>作用：用来修饰成员变量和成员方法，从而实现对方法和变量的使用权限控制</li>
<li>分类：
<ul>
<li>public：公开的</li>
<li>private：私有的</li>
<li>protected：受保护的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="16-变量作用域">16. 变量作用域</h2>
<blockquote>
<p>定义变量的位置不同</p>
<ul>
<li>全局变量：就是类中的所有方法都可以使用，当前类当前类不在使用的时候 由GC(垃圾回收器)回收
<ul>
<li>全部变量一般定义在类 开始，属性定义的位置</li>
</ul>
</li>
<li>局部变量：只能在当前的方法中使用 方法执行完毕 变量从内存中释放</li>
</ul>
</blockquote>
<h2 id="17-代码块">17. 代码块</h2>
<ul>
<li>在java中，用{}括起来的代码就被称为代码块
<ul>
<li>局部代码块</li>
<li>构造代码块</li>
<li>静态代码块</li>
<li>同步代码块</li>
</ul>
</li>
</ul>
<h3 id="1-局部代码块">1. 局部代码块</h3>
<ul>
<li>
<p>在方法中出现，限定变量的作用范围（生命周期），让变量尽早释放，提高内存使用率</p>
</li>
<li>
<pre><code class="language-java">public class CodeBlockDemo{
    public static void main(String [] args){
        //局部代码块
        {  
            int a = 5;
            System.out.println(a);
        }   
        //System.out.println(a);//无法使用a变量
    }    
}
</code></pre>
</li>
</ul>
<h3 id="2-构造代码块">2. 构造代码块</h3>
<ul>
<li>
<p>在类中方法外出现，多个构造方法中相同的代码存放到一起，每次调用构造方法都会执行，而且在构造方法执行时一同执行，即每次创建对象都执行</p>
</li>
<li>
<pre><code class="language-java">public class CodeBlockDemo{
    private int a;
    private String s;
    //构造代码块
    {
        System.out.println(&quot;构造代码块&quot;);
    }
    //构造方法
    public CodeBlockDemo(){
        System.out.println(&quot;无参构造方法&quot;);
    }
    public CodeBlockDemo(int a,String s){
        this.a = a;
        this.s = s;
    }
}
</code></pre>
</li>
</ul>
<h3 id="3-静态代码块">3. 静态代码块</h3>
<ul>
<li>
<p>在类中方法外出现，被static修饰，用来给类进行初始化，在类被加载时执行，只执行一次</p>
</li>
<li>
<pre><code class="language-java">public class CodeBlockDemo{
    private int a;
    private String s;
    //静态代码块
    static{
        System.out.println(&quot;静态代码块&quot;);
    }
    //构造方法
    public CodeBlockDemo(){
        System.out.println(&quot;无参构造方法&quot;);
    }
    public CodeBlockDemo(int a,String s){
        this.a = a;
        this.s = s;
    }
}
</code></pre>
</li>
</ul>
<h3 id="4-同步代码块">4. 同步代码块</h3>
<ul>
<li>Synchronize{}：解决线程安全问题</li>
</ul>
<h3 id="5-静态代码块-构造代码块构造方法的执行顺序和次数">5. 静态代码块、构造代码块，构造方法的执行顺序和次数</h3>
<ul>
<li>静态代码块 ：在类被加载进内存时执行，只执行一次</li>
<li>构造代码块：在构造方法被调用之前执行，每次调用都会被执行</li>
<li>构造方法：对象被创建时执行，每次调用都会被执行</li>
</ul>
<h2 id="18-方法的重载">18. 方法的重载</h2>
<blockquote>
<p>方法的重载</p>
<ul>
<li>参数的数据类型不同</li>
<li>参数的顺序不同</li>
<li>参数的个数不同</li>
<li>与方法的返回值无关</li>
</ul>
<p>@OverLoad，早期方法重载声明，在jdk1.7以后更新不需要写了</p>
</blockquote>
<pre><code class="language-java">public static int sum(int i , int j){
    return i+j;
}
public static int sum(String i,int j){
    return i+j;
}
@OverLoad
public static int sum(String i ,int j,int k){
    return i+j+k;
}
public static int sum(int j,int k,String i ){
    return i+j+k;
}

</code></pre>
<pre><code class="language-java">public static void main (String [] args){
    int c = num(1,1);
    System.out.println(c);
}
public static int num (int a,int b ){
    int c = a+b;
    return c;
}
</code></pre>
<h2 id="19-面向对象">19. 面向对象</h2>
<blockquote>
<p>面向对象是基于面向过程的</p>
</blockquote>
<h3 id="1-封装encapsulation">1. 封装（<strong>Encapsulation</strong>）</h3>
<ul>
<li>
<p>概述：封装(encapsulation)又叫隐藏实现(Hiding the implementation)，就是只公开代码单元的对外接口，而隐藏其具体实现。</p>
</li>
<li>
<p>详述：</p>
<ul>
<li>将类的某些信息隐藏在类的内部，不允许外部程序进行直接的访问调用。</li>
<li>通过该类提供的方法来实现对隐藏信息的操作和访问。</li>
<li>隐藏对象的信息。</li>
<li>留出访问的对外接口。</li>
</ul>
</li>
<li>
<p>特点：</p>
<ul>
<li>提高了代码的安全性、复用性。</li>
<li>对成员变量实行更准确的控制。</li>
<li>封装可以隐藏内部程序实现的细节。</li>
<li>良好的封装能够减少代码之间的耦合度。</li>
<li>外部成员无法修改已封装好的程序代码。</li>
<li>方便数据检查，有利于保护对象信息的完整性，同时也提高程序的安全性。</li>
<li>便于修改，提高代码的可维护性。</li>
</ul>
</li>
<li>
<p>封装原则：</p>
<ul>
<li>把不需要对外提供的内容隐藏起来，提供对应的公共访问方式</li>
</ul>
</li>
<li>
<p>封装性在Java中的体现</p>
<ul>
<li>方法就是一种封装</li>
<li>关键字private也是一种封装</li>
</ul>
</li>
</ul>
<h3 id="2-继承inheritance">2. 继承（<strong>Inheritance</strong>）</h3>
<ul>
<li>概述：继承，Inheritance，是一种看起来很神奇的代码重用方式。 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。当然，如果在父类中拥有私有属性(private修饰)，则子类是不能被继承的。</li>
<li>特点：
<ul>
<li>提高代码复用性。</li>
<li>提高了代码的维护性</li>
<li>类与类之间产生联系（多态构成的前提）</li>
<li>类的耦合度增加了</li>
<li>父类的属性方法可以用于子类。</li>
<li>可以轻松的定义子类。</li>
<li>使设计应用程序变得简单</li>
</ul>
</li>
<li>Java只能单继承，不能多继承，一个类只能有一个父类，不能有多个父类，但是可以多层继承</li>
<li>注意事项：
<ul>
<li>不要为了部分功能而用继承</li>
<li>子类只能继承父类所有非私有的成员（成员变量和成员方法）</li>
<li>子类不能继承父类的构造方法，但是可以通过super关键字访问父类构造方法</li>
</ul>
</li>
<li>什么时候用使用继承：
<ul>
<li>继承体现的是一种关系：A is B（例如：<img src="https://pic.zyblog.xyz/img/typora/20201103102915.png" alt="img" loading="lazy">是水果，<img src="https://pic.zyblog.xyz/img/typora/20201103102944.png" alt="img" loading="lazy">是水果）</li>
</ul>
</li>
</ul>
<h3 id="3-多态polymorphism">3. 多态（<strong>Polymorphism</strong>）</h3>
<ul>
<li>父类引用指向子类对象</li>
</ul>
<blockquote>
<h3 id="开发原则低耦合高内聚">开发原则：低耦合，高内聚</h3>
</blockquote>
<h2 id="20-类">20. 类</h2>
<blockquote>
<p>一类相同事物的抽象</p>
</blockquote>
<ul>
<li>
<p>类的组成</p>
<ul>
<li>成员变量：事物的属性（在类中方法外定义）</li>
<li>成员方法：事物的功能</li>
<li>构造方法：初始化对象（无参，有参，可被重载）</li>
</ul>
</li>
<li>
<p>类的定义</p>
<ul>
<li>
<pre><code class="language-java">class Student{
    public int sid;
    public String sname;
    public Student(){}
    public Student(int id,String name){
        this.sid = id;
        this.name = sname;
    }
    public void study(){
        System.out.println(&quot;学习&quot;);
    }
    public void eat(){
        System.out.println(&quot;吃饭&quot;);
    }        
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="21-对象">21. 对象</h2>
<blockquote>
<p>某个事物的抽象</p>
</blockquote>
<ul>
<li>
<p>创建对象的格式：</p>
<pre><code class="language-java">类名   对象名   =   new   类名/构造方法(参数列表);
Student stu = new Studnet();
</code></pre>
</li>
<li>
<p>为成员变量赋值</p>
<pre><code class="language-java">stu.sid = 174350;
stu.sname = &quot;zhiyuan&quot;;
</code></pre>
</li>
</ul>
<blockquote>
<p>注：堆内存中的变量（引用类型）会被初始化，栈内存中的变量（基本类型）未初始化不可使用</p>
</blockquote>
<h2 id="22-成员变量和局部变量的区别">22. 成员变量和局部变量的区别</h2>
<ul>
<li>在类中的位置不同
<ul>
<li>成员变量：类中方法外</li>
<li>局部变量：方法声明上或方法内</li>
</ul>
</li>
<li>在内存中的位置不同
<ul>
<li>成员变量：在堆中</li>
<li>局部变量：在栈中</li>
</ul>
</li>
<li>生命周期不同
<ul>
<li>成员变量：随着对象的的存在而存在，随着对象的消失而消失</li>
<li>局部变量：随着方法的调用而存在，随着方法的调用完成而消失</li>
</ul>
</li>
<li>初始化不同
<ul>
<li>成员变量：有默认值</li>
<li>局部变量：无默认值</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意事项：局部变量的名字可以和成员变量的名字一样，在方法中用的时候，采用的是就近原则</p>
<pre><code class="language-java">class Demo{
 public int num = 5;
 public static void show(){
     int num = 5;
     System.out.println(num);
 }
 public static void main(String [] args){
     System.out.println(num);
     show();
 }
}
</code></pre>
</blockquote>
<h2 id="23-参数问题">23. 参数问题</h2>
<ul>
<li>基本类型：形参的改变不影响实参</li>
<li>引用类型：形参的改变直接影响实参</li>
</ul>
<h2 id="24-匿名对象">24. 匿名对象</h2>
<ul>
<li>定义：没有名字的对象，是对象的一种简化表示方法</li>
<li>应用：
<ul>
<li>匿名调用方法（如果需要调用多次方法，不建议使用匿名对象调用，因为每调用一次都创建一个新对象）</li>
<li>作为实际参数传递</li>
</ul>
</li>
<li>好处：匿名对象使用完成之后就是垃圾了，可以被回收。</li>
</ul>
<pre><code class="language-java">new Student();
//匿名调用方法
new Student().study();
//匿名对象做参数
new StudentDemo().studyDemo(new Student());
</code></pre>
<h2 id="25-equals与">25. equals（）与   ==</h2>
<ul>
<li>
<p>==</p>
<ul>
<li>基本类型：比较的是值是否相同</li>
<li>引用类型：比较的是地址值是否相同</li>
</ul>
</li>
<li>
<p>equals</p>
<ul>
<li>引用类型：Object默认比较的是地址值，子类重写后默认比较的是内容是否相同</li>
</ul>
</li>
</ul>
<h2 id="26-this关键字">26. this关键字</h2>
<pre><code class="language-java">class Person{
  private String name;
	public void setName(String name){
    	name = name;
	}
}
</code></pre>
<ul>
<li>分析：
<ul>
<li>这里实际上是把局部变量的值又赋给了局部变量</li>
<li>应该是把这个值赋值给成员变量</li>
<li>成员变量是随着对象的创建而存在</li>
<li>之前 “对象名.成员变量名” 可以访问成员变量</li>
<li>那么我们就需要找到一个可以表示 “当前对象” 的东西</li>
<li>而java提供了一个关键字 “this” 就可以表示 “当前对象”</li>
</ul>
</li>
</ul>
<blockquote>
<h3 id="this-当前对象所在类的对象的引用">this   -&gt;   当前对象(所在类的对象的“引用”)</h3>
</blockquote>
<ul>
<li>当前方法被谁调用，this就表示谁</li>
<li>修改上述例子</li>
</ul>
<pre><code class="language-java">class Person{
    private String name;
	public void setName(String name){
    	this.name = name;
	}
}
</code></pre>
<h2 id="27-构造方法">27. 构造方法</h2>
<ul>
<li>作用：初始化对象</li>
</ul>
<pre><code class="language-java">public class Student{
    private int sid;
    private String sname;
    //无参构造方法
    public Student(){
        
    }
    //有参构造方法
    public Student(int sid,String sname){
        this.sid = sid;
        this.sname = sname;
    }
    //构造方法可以被重载
    public Student(int sid){
        this.sid = sid;
    }
    public Student(String sname){
        this.sname = sname;
    }
    //Setter方法
    public void setId(int sid){
        this.sid = sid;
    }
    public void setName(String sname){
        this.sname = sname;
    }
    //Getter方法
    public int getId(){
        return sid;
    }
    public String getName(){
        return sname;
    }
    //重写toString方法
    @Override
    public String toString() {
        return &quot;Student{&quot; +
                &quot;sid=&quot; + sid +
                &quot;, sname='&quot; + sname + '\'' +
                '}';
    }
    
}

public class StudentTest{
    public static void main(String [] args){
        //创建对象
        Student stu1 = new Student();
        System.out.println(stu1);

        Student stu2 = new Student(18,&quot;zhiyuan&quot;);
        System.out.println(stu2);

        Student stu3 = new Student(18);
        System.out.println(stu3);

        Student stu4 = new Student(&quot;zhiyuan&quot;);
        System.out.println(stu4); 
    }
}

/*
输出结果
Student{sid=0, sname='null'}
Student{sid=18, sname='zhiyuan'}
Student{sid=18, sname='null'}
Student{sid=0, sname='zhiyuan'}
*/
</code></pre>
<ul>
<li>说明：
<ul>
<li>如果用户自己没写，系统会自动生成一个无参构造方法</li>
<li>如果用户写了构造方法，无论有参无参，系统都不会再自动生成无参构造方法</li>
<li>构造方法可以重载</li>
</ul>
</li>
</ul>
<h2 id="28-类的初始化过程">28. 类的初始化过程</h2>
<pre><code class="language-java">Student s = new Student();在内存中都干了哪些事？
//加载Student.class文件进内存
//在栈内存中给变量s分配内存空间
//在堆内存中给学生对象开辟空间
//对学生的成员变量进行隐式初始化(默认初始化)
//对学生的成员变量进行显式初始化(类内赋值初始化)    
//对学生的成员变量进行构造初始化(构造方法初始化) 
</code></pre>
<h2 id="29-static关键字">29. static关键字</h2>
<ul>
<li>
<p>可以修饰成员变量和成员方法</p>
</li>
<li>
<p>特点：</p>
<ul>
<li>被类内所有对象共享（也是我们判断要不要用static的标准）</li>
<li>随着类的加载而加载</li>
<li>优先于对象存在</li>
<li>可以通过类名调用（本身可以通过对象调用，建议用类名调用，否则失去了用static修饰的意义 ）</li>
</ul>
</li>
<li>
<p>静态方法只能访问静态的成员变量和静态成员方法（静态方法中不能用this）</p>
<ul>
<li>静态的成员变量和成员方法是对着类加载而加载的，this是随着对象的创建而存在的</li>
</ul>
<pre><code class="language-java">public class Demo{
    private int num;
    private static int num2 = 4;
    public void show(){
        System.out.println(num);
        System.out.println(num2);//无法通过非静态的成员方法访问静态的成员变量
        show2();
        show3();
    }
    public static void show1(){
        System.out.println(num);//报错，无法通过静态的成员方法访问非静态的成员变量
        System.out.println(num2);
        show2();  //静态的成员方法无法访问非静态的成员方法
        show3();
    }
    public void show2(){
        
    }
    public static void show3(){
        
    }
}
</code></pre>
</li>
<li>
<p>非静态方法既可以访问静态的成员变量和成员方法，又可以访问非静态的成员变量和成员方法</p>
</li>
</ul>
<pre><code class="language-java">public static void main(String [] args){
    for(int i = 0;i &lt; args.length;i++){
        System.out.println(args[i]);
    }
}
//String [] ars用于接收来自控制台交互的参数
</code></pre>
<ul>
<li>静态的成员变量和成员变量
<ul>
<li>所属不同
<ul>
<li>成员变量：属于对象</li>
<li>静态成员变量：属于类</li>
</ul>
</li>
<li>内存区域不同
<ul>
<li>成员变量：堆内存</li>
<li>静态变量：方法区中的静态区</li>
</ul>
</li>
<li>出现时间不同
<ul>
<li>成员变量：随着对象的创建而存在，随着对象的消失而消失</li>
<li>静态变量：随着类的加载而加载，随着类的消失而消失</li>
</ul>
</li>
<li>调用方式不同
<ul>
<li>成员变量：只能被对象调用</li>
<li>静态变量：可以使用类名调用，也可以使用对象名调用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="30-main方法">30. main方法</h2>
<pre><code class="language-java">public static void main(String [] args){
    //public：权限修饰符，公共的
    //static：被jvm调用，不需要创建对象
    //void：返回值为空类型，即无返回值
    //main：程序的主入口名，固定默认为main
    //String [] args：早期用于接收键盘录入数据，1.5版本后使用Scanner
}
</code></pre>
<pre><code class="language-java">//控制台编译运行时传入参数
javac Demo.java
java Demo hello world java  

//尝试输出参数    
public static void main(String [] args){
    for(String s : args){
        System.out.println(s);
    }
}
</code></pre>
<h2 id="31-文档注释">31.  文档注释</h2>
<ul>
<li>可以使用javadoc命令生成网页形式的说明书</li>
<li>制作帮助文档（了解）</li>
</ul>
<pre><code class="language-java">package com.demo.javase;
/**
 * @Author 絷缘
 * @Date 2020/11/2 10:02
 * @Version 1.0
 **/
public class ArrayTools {
    /**
     * 打印数组
     * @param arr 传入指定数组
     */
    public static void printArray(int [] arr){
        for (int a:arr) {
            System.out.println(a);
        }
    }

    /**
     * 获得数组中的最大值
     * @param arr 传入指定数组
     * @return int 返回数组中的最大值
     */
    public static int getMax(int [] arr){
        int max = arr[0];
        for(int i = 0;i &lt; arr.length;i++){
            if(arr[i] &gt; max){
                max = arr[i];
            }
        }
        return max;
    }

    /**
     * 获取数组中的最小值
     * @param arr 传入指定数组
     * @return int 返回数组中的最小值
     */
    public static int getMin(int [] arr){
        int min = arr[0];
        for(int i = 0;i &lt; arr.length;i++){
            if(arr[i] &lt; min){
                min = arr[i];
            }
        }
        return min;
    }

    /**
     * 反转数组方法A
     * 逆序数组
     * @param arr 传入指定数组
     */
    public static void reverseA(int [] arr){
        for(int i = 0,j = arr.length - 1;i &lt; j;i++,j--){
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }

    /**
     * 反转数组方法B
     * 逆序数组
     * @param arr 传入指定数组
     */
    public static void reverseB(int [] arr){
        for(int i = 0;i &lt; arr.length/2;i++){
            int temp = arr[i];
            arr[i] = arr[arr.length - 1 - i];
            arr[arr.length - 1] = arr[i];
        }
    }

    /**
     * 获取指定值第一次出现的索引值
     * @param arr  传入的指定数组
     * @param value 传入的指定值
     * @return int 返回的是第一次出现的索引值，如果不存在返回-1
     */
    public static int getIndex(int [] arr,int value){
        int index = -1;
        for(int i = 0;i &lt; arr.length;i++){
            if(arr[i] == value){
                index = i;
                break;
            }
        }
        return index;
    }

    /**
     * 获取指定索引处的值
     * @param arr 传入指定数组
     * @param index 传入指定索引
     */
    public static void getValue(int [] arr,int index){
        if(index &gt; arr.length -1 || index &lt; 0){
            for(int i = 0;i &lt; arr.length;i++){
                if(index == i){
                    System.out.println(arr[i]);
                    break;
                }
            }
        }else{
            System.out.println(&quot;index错误&quot;);
        }
    }
}
</code></pre>
<ul>
<li>
<p>使用javadoc命令解析</p>
<ul>
<li>
<p>格式：</p>
<pre><code class="language-java">javadoc -d . -author -version ArrayTools.java 
</code></pre>
</li>
<li>
<p>报错：找不到可以文档化的公共或受保护的类</p>
<ul>
<li>原因：权限不够</li>
<li>解决方法：给类加上public</li>
</ul>
</li>
</ul>
</li>
<li>
<p>看文档</p>
<ul>
<li>看类的结构
<ul>
<li>看包名</li>
<li>看类的说明</li>
<li>看类的结构
<ul>
<li>成员变量：字段摘要</li>
<li>构造方法：构造方法摘要</li>
<li>成员方法：方法摘要
<ul>
<li>左边：返回值，是否为静态</li>
<li>右边：方法名</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>外部调用（参考JavaDoc和字节码文件使用功能）</p>
<ul>
<li>构造方法私有化</li>
</ul>
</li>
</ul>
<h2 id="32-继承extends">32. 继承（extends）</h2>
<ul>
<li>Person类</li>
</ul>
<pre><code class="language-java">package com.demo.javase;

/**
 * @author 絷缘
 * @version 1.0
 * @date 2020/11/3 9:16
 **/
public class Person {
    protected String name;
    protected int age;
    protected String gender;

    /**
     * 有参构造方法
     * @param name 提供人的姓名
     * @param age  提供人的年龄
     * @param gender 提供人的性别
     */
    public Person(String name, int age, String gender) {
        this.name = name;
        this.age = age;
        this.gender = gender;
    }

    /**
     * 获取人的名字
     * @return String 返回人的姓名
     */
    public String getName() {
        return name;
    }

    /**
     * 获取人的年龄
     * @return int 返回人的年龄
     */
    public int getAge() {
        return age;
    }

    /**
     * 获取人的性别
     * @return String 返回人的性别
     */
    public String getGender() {
        return gender;
    }

    /**
     * 设置人的姓名
     * @param name 提供姓名参数
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * 设置人的年龄
     * @param age 提供年龄参数
     */
    public void setAge(int age) {
        this.age = age;
    }

    /**
     * 设置人的性别
     * @param gender 提供性别参数
     */
    public void setGender(String gender) {
        this.gender = gender;
    }

    public void eat(){
        System.out.println(&quot;吃饭&quot;);
    }
    public void sleep(){
        System.out.println(&quot;睡觉&quot;);
    }
    public void work(){
        System.out.println(&quot;工作&quot;);
    }
    public void study(){
        System.out.println(&quot;学习&quot;);
    }
    public void play(){
        System.out.println(&quot;玩耍&quot;);
    }
    @Override
    public String toString() {
        return &quot;Person{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                &quot;, gender='&quot; + gender + '\'' +
                '}';
    }
}
</code></pre>
<ul>
<li>Student类</li>
</ul>
<pre><code class="language-java">package com.demo.javase;

/**
 * @author 絷缘
 * @version 1.0
 * @date 2020/11/3 9:26
 **/
public class Student extends Person{
    private int sid;
    public Student(int sid,String name,int age,String gender){
        super(name,age,gender);
        this.sid = sid;
    }

    /**
     * 获取学生ID
     * @return int 返回学生的ID
     */
    public int getSid() {
        return sid;
    }

    /**
     * 设置学生的ID
     * @param sid 提供学生ID参数
     */
    public void setSid(int sid) {
        this.sid = sid;
    }

    @Override
    public String toString() {
        return &quot;Student{&quot; +
                &quot;sid=&quot; + sid +
                &quot;, name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                &quot;, gender='&quot; + gender + '\'' +
                '}';
    }
}
</code></pre>
<ul>
<li>测试类</li>
</ul>
<pre><code class="language-java">package com.demo.javase;

/**
 * @author 絷缘
 * @version 1.0
 * @date 2020/11/3 9:28
 **/
public class Test {
    public static void main(String[] args) {
        System.out.println(&quot;==========================================================&quot;);
        Student stu1 = new Student(174350,&quot;zhiyuan&quot;,18,&quot;male&quot;);
        System.out.println(stu1);
        System.out.println(&quot;==========================================================&quot;);
        System.out.println(&quot;sid=&quot;+stu1.getSid());
        System.out.println(&quot;name=&quot;+stu1.getName());
        System.out.println(&quot;age=&quot;+stu1.getAge());
        System.out.println(&quot;gender=&quot;+stu1.getGender());
        System.out.println(&quot;==========================================================&quot;);
        stu1.eat();
        stu1.sleep();
        stu1.study();
        stu1.play();
        System.out.println(&quot;==========================================================&quot;);
    }
}
</code></pre>
<ul>
<li>继承中的成员变量关系
<ul>
<li>类的组成
<ul>
<li>成员变量</li>
<li>构造方法</li>
<li>成员方法</li>
</ul>
</li>
<li>子类的成员变量名字和父类的成员变量名一样的话
<ul>
<li>在子类的方法中找，有就用</li>
<li>在子类的成员位置找，有就用</li>
<li>在父类的成员位置找，有就用</li>
<li>如果找不到，就去父类的父类成员位置找，有就用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="33-super关键字">33. super关键字</h2>
<ul>
<li>
<p>super的用法和this很像</p>
<ul>
<li>this表示本类对象的调用</li>
<li>super表示的是父类对象的调用</li>
</ul>
</li>
<li>
<p>用法：</p>
<ul>
<li>访问成员变量</li>
</ul>
<pre><code class="language-java">this.成员变量
super.成员变量    
</code></pre>
<ul>
<li>访问构造方法</li>
</ul>
<pre><code class="language-java">this()
super()    
</code></pre>
<ul>
<li>访问成员方法</li>
</ul>
<pre><code class="language-java">this.成员方法()
super.成员方法()    
</code></pre>
</li>
<li>
<p>super和this的区别</p>
<ul>
<li>this表示本类对象的调用</li>
<li>super表示的是父类对象的调用</li>
</ul>
</li>
<li>
<p>注意：super调用构造方法或this调用构造方法时，必须是第一条语句</p>
</li>
</ul>
<h2 id="34-继承中构造方法的关系">34. 继承中构造方法的关系</h2>
<ul>
<li>
<p>子类中所有构造方法默认都会访问父类中的无参构造方法</p>
<ul>
<li>
<p>因为子类继承父类，会继承父类中的数据，还要使用这些数据，父类中的数据随着父类对象的存在才会存在，所以，子类初始化之前，一定会先初始化父类。</p>
</li>
<li>
<pre><code class="language-java">public class 子类 extends 父类{
	public	子类构造(){
        //super父类构造();不写，默认会调用父类构造方法初始化对象
    }
    public 子类构造(参数列表){
        super(参数列表);
        this.子类成员变量 = 参数;
    }
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="35-继承中成员方法的关系">35. 继承中成员方法的关系</h2>
<ul>
<li>子类中的成员方法与父类中的成员方法同名
<ul>
<li>使用子类对象调用方法，先看子类有没有，有就用，没有就看父类有没有，有就用，没有就报错</li>
</ul>
</li>
</ul>
<h2 id="36-方法的重写">36. 方法的重写</h2>
<ul>
<li>在子父类中，子类出现了和父类中一模一样的方法声明，这种现象叫做方法重写（复写）</li>
<li>方法重写应用
<ul>
<li>当子类需要父类的功能，而功能的主体子类又有自己特有的内容时，可以重写父类继承过来的方法</li>
<li>这样既继承了父类的功能，又定义了子类的特有功能内容</li>
</ul>
</li>
<li>注意事项：
<ul>
<li>父类中私有的方法不能被重写（因为父类中的私有方法无法被继承，更不要说重写了）</li>
<li>子类重写父类的方法，访问权限不能更低</li>
<li>父类的静态方法，子类也必须使用静态方法重写（本质不算方法重写，现象确实如此，涉及多态）</li>
<li>子类重写方法时，声明要一模一样</li>
</ul>
</li>
</ul>
<h2 id="37-方法重载和方法重写的区别">37. 方法重载和方法重写的区别</h2>
<ul>
<li>方法重载：同一个类中，出现多个方法名相同，参数列表不同的方法，这种现象称为方法重载</li>
<li>方法重写：在子类中，出现和父类中成员方法声明相同，功能主体不同的方法，这种现象称为方法重写</li>
</ul>
<h2 id="38-访问权限修饰符">38. 访问权限修饰符</h2>
<table>
<thead>
<tr>
<th>访问权限修饰符</th>
<th>描述</th>
<th>本类</th>
<th>同一个包的无关类</th>
<th>其他包的无关类</th>
<th>同一个包的子孙类</th>
<th>其他包的子孙类</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>访问权限公开</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
</tr>
<tr>
<td>protected</td>
<td>访问权限受保护</td>
<td>✔️</td>
<td>✔️</td>
<td>❌</td>
<td>✔️</td>
<td>✔️</td>
</tr>
<tr>
<td>private</td>
<td>访问权限私有</td>
<td>✔️</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>默认的缺省的</td>
<td>friendly(同一个包内友好)</td>
<td>✔️</td>
<td>✔️</td>
<td>❌</td>
<td>✔️</td>
<td>❌</td>
</tr>
</tbody>
</table>
<h3 id="1-public">1. public</h3>
<blockquote>
<p>public 公开的，是访问权限限制最宽的修饰符。被public修饰的类、属性、及方法不仅可以跨类访问，而且可以跨包访问</p>
</blockquote>
<h3 id="2-protected">2. protected</h3>
<blockquote>
<p>protected 受保护的， 是介于public和private之间的一种访问修饰。被protected修饰的属性及方法只能被类本身的方法和子类访问。（子类在不同的包中也可以访问）</p>
</blockquote>
<h3 id="3-private">3. private</h3>
<blockquote>
<p>private 私有的，对访问权限限制最窄的修饰符。被private修饰的属性以及方法只能被该类的对象访问。它的子类也不可以访问，更不支持跨包访问</p>
</blockquote>
<h3 id="4-friendly">4. friendly</h3>
<blockquote>
<p>friendly 友好的，默认不加任何访问修饰符，只支持在同一个包中进行访问，对同一个包内的类友好</p>
</blockquote>
<h2 id="39-其他修饰符">39. 其他修饰符</h2>
<h3 id="1-static">1. static</h3>
<ul>
<li>修饰变量：静态变量
<ul>
<li>独立于对象的变量，又称类变量，在类被加载进内存时加载，类无论被实例化几次，静态变量只有一份拷贝</li>
</ul>
</li>
<li>修饰方法：静态方法
<ul>
<li>独立于对象的方法，又称类方法，在类被加载进内存时加载
<ul>
<li>静态方法只能访问静态成员（变量、方法）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-final">2. final</h3>
<blockquote>
<p>我们只希望子类能够继承父类的方法，不希望他改动，java就提供了final关键字</p>
</blockquote>
<ul>
<li>
<p>修饰变量：变量一旦赋值后，不能被重新赋值。</p>
<ul>
<li>
<p>被 final 修饰的实例变量必须指定初始值（显式初始化，构造初始化，构造代码块）。</p>
</li>
<li>
<p>final 修饰符通常和 static 修饰符一起使用来创建类常量。</p>
</li>
</ul>
</li>
</ul>
<pre><code class="language-java">static final double PI = 3.14;
</code></pre>
<ul>
<li>修饰方法：父类方法可以被子类继承，但不可被重写</li>
</ul>
<pre><code class="language-java">public class Person{
    private String name;
    public final void changeName(String name){
        this.name = name;
    }
}
</code></pre>
<ul>
<li>修饰类：表示最终类，该类不可被继承（但最终类可以继承别的类）</li>
</ul>
<pre><code class="language-java">public final class Person{
    
}
</code></pre>
<ul>
<li>final修饰局部变量
<ul>
<li>基本类型：值不能发生改变</li>
<li>引用类型：地址值不能发生改变，但是该对象在堆内存中的值是可以改变的</li>
<li>修饰形参时，在方法内部不可对值进行改变</li>
</ul>
</li>
<li>final修饰成员变量的初始化时机：在对象构造完成之前赋值即可，只能赋值一次</li>
</ul>
<h3 id="3-abstract">3. abstract</h3>
<ul>
<li>修饰类：抽象类</li>
<li>修饰方法：抽象方法</li>
</ul>
<h3 id="4-synchronized">4. synchronized</h3>
<h3 id="5-transient">5. transient</h3>
<h3 id="6-volatile">6. volatile</h3>
<h2 id="40-多态">40. 多态</h2>
<ul>
<li>
<p>同一事物在不同时刻表现出来不同的状态</p>
</li>
<li>
<p>例：水在低温下是固态，常温下是液态，高温下是气态</p>
</li>
<li>
<p>例：你在你爹面前是儿子，在你爷爷面前是孙子</p>
</li>
</ul>
<h3 id="1-多态的前提和表现">1. 多态的前提和表现</h3>
<p>前提：</p>
<ul>
<li>有继承关系</li>
<li>有方法重写</li>
</ul>
<p>表现：</p>
<ul>
<li>父类引用指向子类对象（向上转型）</li>
</ul>
<h3 id="2-多态中成员的访问特点">2. 多态中成员的访问特点</h3>
<pre><code class="language-java">class Father{
	int num = 111;
	public void show(){
		System.out.println(&quot;show father&quot;);
	}
	public static void function(){
		System.out.println(&quot;function father&quot;);
	}
}

class Son extends Father{
	int num = 222;
	int num2 = 333;
	public void show(){
		System.out.println(&quot;show son&quot;);
	}
	public static void function(){
		System.out.println(&quot;function son&quot;);
	}
	public void method(){
		System.out.println(&quot;method son&quot;);
	}
}

class Demo1{
	public static void main(String [] args){
		//多态
		Father f1 = new Son();
        System.out.println(f.num);
        System.out.println(f.num2);//找不到num2
	}
}
</code></pre>
<ul>
<li>访问成员变量
<ul>
<li>编译看左边，运行看左边</li>
</ul>
</li>
<li>访问成员方法
<ul>
<li>编译看左边，运行看右边（成员方法存在方法重写，所以运行看右边）</li>
</ul>
</li>
<li>访问静态方法
<ul>
<li>编译看左边，运行看左边（静态和类相关，算不上重写，所以访问是父类）</li>
</ul>
</li>
<li>访问构造方法
<ul>
<li>创建子类对象时，自动访问父类的构造方法，将父类数据进行初始化</li>
</ul>
</li>
</ul>
<h3 id="3-多态的好处和弊端">3. 多态的好处和弊端</h3>
<h4 id="好处">好处：</h4>
<ul>
<li>提高了程序的复用性、可维护性（由继承保证）</li>
<li>提高了程序的可扩展性（有多态的保证）</li>
</ul>
<h4 id="弊端">弊端：</h4>
<ul>
<li>无法访问到子类独有的内容（变量以及方法）</li>
</ul>
<h4 id="难道真的不能访问子类的内容吗">难道真的不能访问子类的内容吗？</h4>
<ul>
<li>
<p>向下转型</p>
</li>
<li>
<pre><code class="language-java">Father f = new Son();
Son s = (Son)f;
</code></pre>
</li>
</ul>
<h3 id="4-多态的作用">4. 多态的作用</h3>
<ul>
<li>当把不同的子类对象都当做父类类型来看待，可以屏蔽不同子类对象之间的实现差异，从而写出通用的代码达到通用编程，以适应需求的不断变化。</li>
</ul>
<h2 id="41-抽象类abstract">41. 抽象类（abstract）</h2>
<h3 id="1-抽象类的定义">1. 抽象类的定义：</h3>
<blockquote>
<p>比如<strong>图形(Shape)类</strong>, 就是一个抽象的概念,因为我们无法计算这个**“图形”<strong>的面积,所以它的成员函数</strong>area()**是空的。</p>
<p>而继承它的子类**(矩形,椭圆形,三角形等)<strong>就可以去</strong>覆写area()**成员函数. 里面通过数学公式,计算出面积.</p>
</blockquote>
<ul>
<li>抽象类，用来表示一个<strong>抽象概念</strong>，不是一个具体的事物。</li>
<li>是一种<strong>只能定义类型</strong>,而<strong>不能产生对象</strong>的类，所以定义了抽象类则必须有子类的出现.</li>
<li>抽象类的好处在于能够明确地定义子类<strong>需要覆写的</strong>方法</li>
<li>抽象类需要使用<strong>abstract</strong>声明.</li>
<li>定义格式：public  abstract class 类名 {  }</li>
</ul>
<h3 id="2-抽象方法">2. 抽象方法</h3>
<ul>
<li>一个没有方法体的方法</li>
<li>有抽象方法的类就必须定义为抽象类</li>
<li>定义格式：public  abstract  返回值类型  方法名（）；</li>
</ul>
<h3 id="3-注意事项">3. 注意事项</h3>
<ul>
<li>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</li>
<li>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li>
<li>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</li>
</ul>
<pre><code class="language-java">public abstract double computePay();
</code></pre>
<ul>
<li>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</li>
<li>如果子类是具体类，子类必须给出抽象类中的抽象方法的具体实</li>
</ul>
<ul>
<li>如果子类也是抽象类，子类可以不重写父类的抽象方法</li>
</ul>
<h3 id="4-抽象类的构造方法的意义">4. 抽象类的构造方法的意义</h3>
<ul>
<li>用于子类访问父类初始化数据</li>
<li>可以通过多态的方式实现实例化</li>
</ul>
<h3 id="5-抽象类中的成员特点">5. 抽象类中的成员特点</h3>
<ul>
<li>成员变量
<ul>
<li>可以是变量（成员变量，static 类变量）</li>
<li>也可以是常量（final 成员常量，static final 类常量）</li>
</ul>
</li>
<li>成员方法
<ul>
<li>可以有抽象方法（要求子类必须干的事情）</li>
<li>也可以有非抽象方法（给子类继承，提高代码复用性）</li>
</ul>
</li>
<li>构造方法
<ul>
<li>有构造，但是不能实例化</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public abstract class Animal{
    private String name;
    private int age;
    private String color;
    
    public Animal(){}
    public Animal(String name,int age,String color){
        this.name = name;
        this.age = age;
        this.color = color;
    }
    
    public String getName(){
        return name;
    }
    public int getAge(){
        return age;
    }
    public String getColor(){
        return color;
    }
    public void setName(String name){
        this.name = name;
    }
    public void setAge(int age){
        this.age = age;
    }
    public void setColor(String color){
        this.color = color;
    }
    public abstract void eat();
    public abstract void sleep();
    public abstract void play();
}
</code></pre>
<pre><code class="language-java">public class Dog extends Animal{
    public Dog(){}
    public Dog(String name,int age,String color){
        super(name,age,color);
    }
    public void eat(){
        System.out.println(&quot;狗吃狗&quot;);
    }
    public void sleep(){
        System.out.println(&quot;狗趴着睡&quot;);
    }
    public void play(){
        System.out.println(&quot;狗玩球&quot;);
    }
    public void lookDoor(){
        System.out.println(&quot;狗看门&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class Cat extends Animal{
    public Cat(){}
    public Cat(String name,int age,String color){
        super(name,age,color);
    }
        public void eat(){
        System.out.println(&quot;猫吃猫&quot;);
    }
    public void sleep(){
        System.out.println(&quot;猫蜷着睡&quot;);
    }
    public void play(){
        System.out.println(&quot;猫玩毛线&quot;);
    }
    public void catchMouse(){
        System.out.println(&quot;猫抓老鼠&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class Demo{
    public static void main(String [] args){
        Cat c1 = new Cat();
        c1.setName(&quot;咪咪&quot;);
        c1.setAge(1);
        c1.setColor(&quot;奶牛色&quot;);
        System.out.println(c1.getName()+c1.getAge()+c1.getColor());
        c1.eat();
        c1.sleep();
        c1.play();
        c1.catchMouse();
        
        Cat c2 = new Cat(&quot;橘猫&quot;,2,&quot;橘黄色&quot;);
        System.out.println(c2.getName()+c2.getAge()+c2.getColor());
        c2.eat();
        c2.sleep();
        c2.play();
        c2.catchMouse();
        
        //多态
        Animal a1 = new Cat();
        a1.setName(&quot;狸花猫&quot;);
        a1.setAge(2);
        a12.setColor(&quot;花&quot;);
        System.out.println(a1.getName()+a1.getAge()+a1.getColor());
        a1.eat();
        a1.sleep();
        a1.play();
        Cat c3 = (Cat)a1;
        c3.catchMouse();
        
        
        Animal a2 = new Cat(&quot;蓝猫&quot;,1,&quot;蓝色&quot;);
        System.out.println(a2.getName()+a2.getAge()+a2.getColor());
        a2.eat();
        a2.sleep();
        a2.play();
        Cat c4 = (Cat)a2;
        c4.catchMouse();
    }
}
</code></pre>
<h3 id="6-抽象类中的几个问题">6. 抽象类中的几个问题</h3>
<ul>
<li>一个类如果没有抽象方法，能不能定义成抽象类？如果可以，有什么意义？
<ul>
<li>可以，意义可以让类无法被实例化，即无法创建对象</li>
</ul>
</li>
<li>abstract类和abstract方法不能被以下修饰：
<ul>
<li>private abstract void show（）</li>
<li>final abstract void show（）</li>
<li>static abstract void show（）</li>
</ul>
</li>
</ul>
<h2 id="42-接口">42. 接口</h2>
<h3 id="1-概述">1. 概述</h3>
<ul>
<li>
<p>为了体现事物功能的扩展性，java就提供了接口来定义额外的功能，不给具体实现。</p>
</li>
<li>
<p>接口只描述所应该具备的方法，并没有具体实现，具体的实现由接口的实现类(相当于接口的子类)来完成。这样将功能的定义与实现分离，优化了程序设计。</p>
<blockquote>
<p>请记住：一切事物均有功能，即一切事物均有接口。</p>
</blockquote>
</li>
</ul>
<h3 id="2-接口的表示形式">2. 接口的表示形式</h3>
<ul>
<li>关键字：interface</li>
<li>格式：interface 接口名 {  }</li>
<li>实现接口关键字：implements</li>
<li>格式：class  类名  implements  接口名{  }</li>
</ul>
<h3 id="3-特点">3. 特点</h3>
<ul>
<li>接口不能被实例化</li>
<li>可以依赖具体的实现类实现实例化（接口多态）</li>
</ul>
<h3 id="4-接口的实现类">4. 接口的实现类</h3>
<ul>
<li>可以是抽象类，意义不大</li>
<li>可以是具体类，一定要重写接口中所有的抽象方法</li>
</ul>
<h3 id="5-多态类型">5. 多态类型</h3>
<ul>
<li>具体类多态（几乎不用）</li>
<li>抽象类多态（常用）</li>
<li>接口类多态（常用）</li>
</ul>
<pre><code class="language-java">interface AnimalInter {
    //钻火圈的额外功能
    public abstract void 钻火圈();
    
}
</code></pre>
<pre><code class="language-java">class Tiger implements AnimalInter{
    public void 钻火圈(){
        System.out.pritln(&quot;老虎钻火圈&quot;);
    }
}
</code></pre>
<pre><code class="language-java">class Demo{
    public static void main(String [] args){
        Tiger t = new Tiger();
		t.钻火圈();
		AnimalInter a = new Tiger();
		a.钻火圈();
    }
}
</code></pre>
<h3 id="6-接口中的成员特点">6. 接口中的成员特点</h3>
<ul>
<li>成员变量
<ul>
<li>默认被 public static final 修饰，只能是类常量</li>
<li>自己写上，否则会误认为是变量</li>
</ul>
</li>
<li>构造方法
<ul>
<li>没有构造方法，也不能有构造方法</li>
<li>因为接口是扩展功能，没有具体的实体对象</li>
<li>那么接口如何实现多态？
<ul>
<li>java中所有的类都直接或者间接继承了一个类，这个类就是Object类</li>
<li>Object是java中所有类的基类，是类层次结构中的根类</li>
</ul>
</li>
</ul>
</li>
<li>成员方法
<ul>
<li>接口中所有的方法都被public abstract修饰，即接口中所有的方法都是抽象方法</li>
<li>（其实可以出现非抽象方法，但不要记忆default void show(){}）</li>
<li>默认被 public abstract 修饰</li>
</ul>
</li>
</ul>
<pre><code class="language-java">interface Inter{
    public static final int num = 5;
    public static final int num2 = 6;
    public static final int num3 = 7;
    public static final int num4 = 8;
    
    public abstract void show();
}
</code></pre>
<pre><code class="language-java">class InterImp implements Inter{
    
}
</code></pre>
<pre><code class="language-java">class Demo{
    public static void main(String [] args){
        
    }
}
</code></pre>
<h3 id="7-类和类-类和接口-接口和接口之间的关系">7. 类和类、类和接口、接口和接口之间的关系</h3>
<ul>
<li>类和类
<ul>
<li>继承关系，只能单继承，可以多层继承</li>
</ul>
</li>
<li>类和接口
<ul>
<li>实现关系，可以单实现，也可以多实现</li>
<li>还可以在继承一个类的基础上同时实现多个接口</li>
</ul>
</li>
<li>接口和接口
<ul>
<li>继承关系，可以单继承，也可以多继承</li>
</ul>
</li>
</ul>
<h3 id="8-抽象类和接口的区别">8. 抽象类和接口的区别</h3>
<ul>
<li>
<p>成员区别：</p>
<ul>
<li>抽象类
<ul>
<li>成员变量：可以是变量，可以是常量</li>
<li>构造方法：有</li>
<li>成员方法：可以有抽象方法，也可以有非抽象方法</li>
</ul>
</li>
<li>接口
<ul>
<li>成员变量：都是静态常量</li>
<li>构造方法：没有</li>
<li>成员方法：只能是抽象方法</li>
</ul>
</li>
</ul>
</li>
<li>
<p>关系区别：</p>
<ul>
<li>类和类：继承，单继承</li>
<li>类和接口：实现，多实现</li>
<li>接口和接口：继承，多继承</li>
</ul>
</li>
<li>
<p>设计区别：</p>
<ul>
<li>抽象类：存储继承体系中共性的内容，体现的是 is  a 的关系</li>
<li>接口：体现事物的扩展功能，体现的是 like  a 的关系</li>
</ul>
</li>
<li>
<p>抽象类中可以有非抽象方法，接口中默认都为抽象方法（public abstract）</p>
</li>
<li>
<p>抽象类中的成员变量可以随便定义，接口中的成员变量都是类常量（public static final）</p>
</li>
</ul>
<h3 id="9-猫狗案例加入一个钻火圈的额外功能">9. 猫狗案例，加入一个钻火圈的额外功能</h3>
<pre><code class="language-java">interface AnimalInter{
    //定义额外功能
    public abstract void 钻火圈(){
        
    }
}

public abstract class Animal{
    private String name;
    private int age;
    private String color;
    
    public Animal(){
        
    }
    public Animal(String name,int age,String color){
        this.name = name;
        this.age = age;
        this.color = color;
    }
    
    public String getName(){
        return name;
    }
    public int getAge(){
        return age;
    }
    public String getColor(){
        return color;
    }
    public void setName(String name){
        this.name = name;
    }
    public void setAge(int age){
        this.age = age;
    }
    public void setColor(String color){
        this.color = color;
    }
    public abstract void eat();
    public abstract void sleep();
    public abstract void play();
    public void show(){
        System.out.println(&quot;Animal{&quot;+ name + &quot;,&quot; + age + &quot;,&quot; + color + &quot;}&quot;);
    }
}
//狗也是动物，所以继承动物
public class Dog extends Animal{
    public Dog(){}
    public Dog(String name,int age,String color){
        super(name,age,color);
    }
    public void eat(){
        System.out.println(&quot;狗吃骨头&quot;);
    }
    public void sleep(){
        System.out.println(&quot;狗趴着睡&quot;);
    }
    public void play(){
        System.out.println(&quot;狗玩球&quot;);
    }
    public void lookDoor(){
        System.out.println(&quot;狗会看门&quot;);
    }
}
//猫也是动物，所以继承动物
public class Cat extends Animal{
    public Cat(){}
    public Cat(String name,int age,String color){
        super(name,age,color);
    }
     public void eat(){
        System.out.println(&quot;猫吃鱼&quot;);
    }
    public void sleep(){
        System.out.println(&quot;猫蜷着睡&quot;);
    }
    public void play(){
        System.out.println(&quot;猫玩毛线&quot;);
    }
    public void catchMouse(){
        System.out.println(&quot;猫会抓老鼠&quot;);
    }
} 

//屌狗也是狗，所以继承狗
public class DiaoDog extends Dog implements AnimalInter{
    public DiaoDog(){}
    public DiaoDog(String name,int age,String color){
        super(name,age,color);
    }
    public void zhq(){
        System.out.println(&quot;屌狗钻火圈&quot;);
    }
}
//屌猫也是猫，所以继承猫
public class DiaoCat extends Cat implements AnimalInter{
    public DiaoCat(){}
    public DiaoCat(String name,int age,String color){
        super(name,age,color);
    }
    public void zhq(){
        System.out.println(&quot;屌猫钻火圈&quot;);
    }
}
//测试类
public class Demo{
    public static void main(String[]args){
        //测试普通狗
        Dog d1 = new Dog(&quot;哈巴狗&quot;,2,&quot;黄色&quot;);
        d1.show();
        d1.eat();
        d1.sleep();
        d1.play();
        d1.lookDoor();
        
        //测试屌狗
        DiaoDog d2 = new DiaoDog(&quot;金毛&quot;,3,&quot;金色&quot;);
        d2.show();
        d2.eat ();
        d2.sleep();
        d2.play();
        d2.lookDoor();
        d2.zhq();
        
        //测试普通猫
        Cat c1 = new Cat(&quot;橘猫&quot;,2,&quot;橘黄色&quot;);
        c1.show();
        c1.eat();
        c1.sleep();
        c1.play();
        c1.catchMouse();
        
        //测试屌猫
        DiaoCat c2 = new DiaoCat(&quot;狸花猫&quot;,3,&quot;狸花&quot;);
        c2.show();
        c2.eat ();
        c2.sleep();
        c2.play();
        c2.catchMouse();
        c2.zhq();
    }
}
</code></pre>
<h2 id="43-形参和返回值深入研究">43. 形参和返回值深入研究</h2>
<h3 id="1-形参">1. 形参</h3>
<ul>
<li>基本类型</li>
<li>引用类型
<ul>
<li>类：要的是该类的对象</li>
<li>抽象类：要的是该抽象类的具体子类的对象</li>
<li>接口：要的是该接口的具体实现类的对象</li>
</ul>
</li>
</ul>
<h3 id="2-返回值类型">2. 返回值类型</h3>
<ul>
<li>基本类型</li>
<li>引用类型
<ul>
<li>类：返回该类的具体对象</li>
<li>抽象类：返回该抽象类的具体子类对象</li>
<li>接口：返回该接口具体实现类对象</li>
</ul>
</li>
</ul>
<blockquote>
<p>链式编程：new Student().study()</p>
<p>每次调用方法之后返回的是另一个对象，而你需要继续调用这个对象的方法，就可以直接.方法名</p>
</blockquote>
<h2 id="44-包">44. 包</h2>
<h3 id="1-作用">1. 作用</h3>
<ul>
<li>把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。</li>
<li>如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。</li>
<li>包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</li>
</ul>
<blockquote>
<p>Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）</p>
</blockquote>
<ul>
<li>区分同名文件，对类文件进行分类管理和存储</li>
</ul>
<h3 id="2-包的划分">2. 包的划分</h3>
<ul>
<li>基本划分
<ul>
<li>按功能分
<ul>
<li>com.dnc.add</li>
<li>com.dnc.delete</li>
<li>com.dnc.update</li>
<li>com.dnc.select</li>
</ul>
</li>
<li>按模块分
<ul>
<li>com.dnc.teacher</li>
<li>com.dnc.student</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-包的定义和注意事项">3. 包的定义和注意事项</h3>
<ul>
<li>格式：
<ul>
<li>package  包名；</li>
<li>多级包用点隔开</li>
</ul>
</li>
<li>注意：
<ul>
<li>package语句必须为程序的第一条语句</li>
<li>一个java文件中只能有一条package语句，且写在第一行</li>
</ul>
</li>
</ul>
<h3 id="4-带包的编译和运行">4. 带包的编译和运行</h3>
<ul>
<li>手动写：编写一个带包的java文件，使用javac编译，手动创建包，将编译后的字节码文件放入包内，回到编写java文件的路径下，用java命令运行，要带包名</li>
</ul>
<pre><code class="language-java">java com.dnc.demo.Demo
</code></pre>
<ul>
<li>自动：编写一个带包的java文件，javac编译时带上包名，回到编写java文件的路径下，用java命令运行</li>
</ul>
<pre><code class="language-java">javac -d . HelloWorld.java
java com.dnc.demo.Demo    
</code></pre>
<h3 id="5-导包">5. 导包</h3>
<ul>
<li>不同包下类之间的访问，每次使用的时候都要加包名，为了解决这个问题，java就提供了导包功能。</li>
<li>格式：import  包名；</li>
<li>注意：
<ul>
<li>用谁导谁，直接导入具体的类，写在package下</li>
<li>虽然包名后面可以写*，不建议</li>
<li>一个java文件中可以有多条import语句</li>
</ul>
</li>
</ul>
<h2 id="45-类和类的组成可用的修饰符">45. 类和类的组成可用的修饰符</h2>
<ul>
<li>修饰符：
<ul>
<li>权限修饰符：private  默认  protected  public</li>
<li>状态修饰符：static  final</li>
<li>抽象修饰符：abstract</li>
</ul>
</li>
<li>类：
<ul>
<li>权限修饰符：默认  public</li>
<li>状态修饰符：final</li>
<li>抽象修饰符：abstract</li>
</ul>
</li>
<li>成员变量：
<ul>
<li>权限修饰符：private  默认 protected  public</li>
<li>状态修饰符：static  final</li>
<li>抽象修饰符：没有</li>
</ul>
</li>
<li>成员方法：
<ul>
<li>权限修饰符：private  默认  protected  public</li>
<li>状态修饰符：static  final</li>
<li>抽象修饰符：abstract</li>
</ul>
</li>
<li>构造方法：
<ul>
<li>权限修饰符：public  private  protected  默认</li>
<li>状态修饰符：没有</li>
<li>抽象修饰符：没有</li>
</ul>
</li>
<li>除此之外的常用组合：
<ul>
<li>成员变量：
<ul>
<li>public static final</li>
</ul>
</li>
<li>成员方法：
<ul>
<li>public static</li>
<li>public abstract</li>
<li>public final</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="46-内部类">46. 内部类</h2>
<h3 id="1-把一个类定义在另一个类的内部这个里面的类就是内部类">1. 把一个类定义在另一个类的内部，这个里面的类就是内部类</h3>
<pre><code class="language-java">class A{
    class B{}				//B为成员内部类
    public void method(){
        class C{}			//C为局部内部类
    }
}
</code></pre>
<h3 id="2-分类">2. 分类</h3>
<h4 id="21-根据内部类在类中定义的位置不同">2.1 根据内部类在类中定义的位置不同</h4>
<ul>
<li>成员内部类</li>
<li>局部内部类</li>
</ul>
<h4 id="22-根据状态修饰符">2.2 根据状态修饰符</h4>
<ul>
<li>非静态内部类</li>
<li>静态内部类（static）</li>
</ul>
<blockquote>
<p>静态内部类无法访问外部类的成员</p>
</blockquote>
<h4 id="23-根据访问权限修饰符">2.3 根据访问权限修饰符</h4>
<ul>
<li>私有内部类（private）</li>
</ul>
<blockquote>
<p>如果你不希望内部类被外部类访问可以使用 private 修饰符</p>
</blockquote>
<ul>
<li>受保护的内部类（protected）</li>
<li>默认的内部类（缺省）</li>
<li>公开的内部类（public）</li>
</ul>
<h3 id="3-成员内部类">3. 成员内部类</h3>
<h4 id="31-格式">3.1 格式</h4>
<pre><code class="language-java">class Outer{
    class Inner{}
}
</code></pre>
<h4 id="32-创建对象格式">3.2 创建对象格式</h4>
<pre><code class="language-java">Outer.Inner i = new Outer().new Inner();
</code></pre>
<h4 id="33-内部类的成员与外部类的成员的使用方式">3.3. 内部类的成员与外部类的成员的使用方式</h4>
<ul>
<li>内部类可以直接访问外部类的东西</li>
<li>外部类必须创建对象才能访问内部类的东西</li>
<li>内部类直接访问外部类成员可以使用以下格式</li>
</ul>
<pre><code class="language-java">Outer.this.成员变量/成员方法()
</code></pre>
<ul>
<li>例：</li>
</ul>
<pre><code class="language-java">public class Outer{
    private int num = 10;
    public class Inner{
        int num = 20;
        public void methodInner(){
            int num = 30;
            System.out.println(num);			//局部变量
            System.out.println(this.num);		//内部类的成员变量
            System.out.println(Outer.this.num);	//外部类的成员变量
            this.show();						//内部类的成员方法
            Outer.this.show();					//外部类的成员方法
        }
        public void show(){
            System.out.println(&quot;Inner show()&quot;);
        }
    }
    public void show(){
        System.out.println(&quot;Outer show()&quot;);
    }
}
</code></pre>
<h4 id="34-成员内部类常见用法和常用修饰符">3.4 成员内部类常见用法和常用修饰符</h4>
<ul>
<li>private：为了保证安全</li>
</ul>
<blockquote>
<p>特殊情况下还需要让别人访问，就提供一个公有的方法，让外界来间接访问</p>
</blockquote>
<pre><code class="language-java">public class Outer{
    private class Inner{
        public void show(){
            System.out.println(&quot;Inner show()&quot;);
        }
    }
    public void methos(){
        Inner i = new Inner();
        i.show();
    }
}
</code></pre>
<ul>
<li>static：为了让数据访问更方便（可以看成外部类的静态成员）</li>
</ul>
<blockquote>
<ol>
<li>静态内部类可以有静态成员，非静态内部类不能有静态成员。</li>
<li>静态内部类的创建不依赖于外部类，非静态内部类必须依赖于外部类的创建而创建。</li>
</ol>
</blockquote>
<pre><code class="language-java">public class Outer{
    private static int num = 2;
    public static class Inner{
        public static void show(){
            System.out.println(num);
        }
    }
}
</code></pre>
<blockquote>
<p>创建对象格式</p>
</blockquote>
<pre><code class="language-java">Outer.Inner i = new Outer.Inner();
</code></pre>
<h3 id="4-局部内部类">4. 局部内部类</h3>
<h4 id="41-定义">4.1 定义：</h4>
<ul>
<li>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。</li>
</ul>
<h4 id="42-格式">4.2 格式：</h4>
<pre><code class="language-java">class Outer{
    private int num = 5;
    public void show(){
        int num = 6;
        //局部内部类
        class Inner{
            public void function(){
                System.out.println(num);
                System.out.println(Outer.this.num);
            }
        }
    }
}
</code></pre>
<h4 id="43-注意事项">4.3 注意事项：</h4>
<ul>
<li>局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的。</li>
<li>局部内部类可以直接访问外部类成员，即使是私有的</li>
<li>局部内部类中访问局部变量，局部变量会被变成final变量，JDK8之后，默认被final修饰，JDK7之前，需要自己添加final修饰符</li>
</ul>
<blockquote>
<p>方法执行结束出栈，局部变量不存在了，但是方法中的局部内部类实例化的对象在堆中依然存在，还会使用局部变量的值，而此时局部变量并不存在，被对象访问的只是一个字面值常量，所以会被final修饰</p>
<p>其实这是规定，无需理解，是延长变量生命周期的一种方式，因为类是加载到方法区中。而局部变量是随意方法的进栈而产生，随着方法的弹栈而消失，所以在局部内部类访问局部变量时，要给局部变量给final修饰使其变成常量，进入常量池，生命周期变长。</p>
</blockquote>
<figure data-type="image" tabindex="12"><img src="http://pic.zyblog.xyz/img/typora/20201110110926.png" alt="img" loading="lazy"></figure>
<ul>
<li>在外部类中不能创建局部内部类的对象</li>
<li>外部类不能直接访问局部内部类，只能在方法体中间接访问局部内部类，且访问必须在内部类定义之后</li>
</ul>
<h3 id="5-匿名内部类">5. 匿名内部类</h3>
<h4 id="51-格式">5.1 格式：</h4>
<pre><code class="language-java">new 父类名或者接口名(){
    //方法重写
}
</code></pre>
<h4 id="52-本质">5.2 本质</h4>
<ul>
<li>是一个继承了父类或者实现了接口的具体子类匿名对象</li>
</ul>
<h4 id="53-例">5.3 例</h4>
<pre><code class="language-java">interface Inter{
    public abstract void show();
}
class Outer{
    public abstract void method(){
        //匿名内部类
        new Inter(){
            public void show(){
                System.out.println(&quot;匿名内部类&quot;);
            }
        }.show();
    }
}
public class Test{
    public static void main(String [] args){
        //接口多态
        Inter i = new Inter(){
            public void show(){
                System.out.println(&quot;匿名内部类&quot;);
            }
        };
        i.show();
    }
}
</code></pre>
<blockquote>
<p>匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护，以下是一段 Android 事件监听代码</p>
</blockquote>
<pre><code class="language-java">scan_bt.setOnClickListener(new OnClickListener() {
    @Override
    public void onClick(View v) {
        // TODO Auto-generated method stub
         
    }
});
 
history_bt.setOnClickListener(new OnClickListener() {
     
    @Override
    public void onClick(View v) {
        // TODO Auto-generated method stub
         
    }
});
</code></pre>
<p>这段代码为两个按钮设置监听器，这里面就使用了匿名内部类</p>
<pre><code class="language-java">new OnClickListener() {
    @Override
    public void onClick(View v) {
        // TODO Auto-generated method stub
         
    }
}
</code></pre>
<h4 id="54-注意事项">5.4 注意事项</h4>
<blockquote>
<p>匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为 Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p>
</blockquote>
<ul>
<li>匿名内部类可以访问外部所有成员，包括私有</li>
<li>匿名内部类访问局部变量时，变量必须要用final修饰，JDK8以后即使没有用final修饰，会自动补上</li>
<li>匿名内部类用于继承其他类或是实现接口，作为参数去给方法传值</li>
</ul>
<h4 id="55-例">5.5 例</h4>
<pre><code class="language-java">public interface Inter{
    public abstract void show();
}
public class Outer{
    public static Inter method(){
        return new Inter(){
            public void show(){
                System.out.println(&quot;我爱**&quot;);
            }
        };
    }
}
public class Test{
    public static void main(String [] args){
        Outer.method().show();
    }
}
</code></pre>
<h3 id="6-lambda表达式">6. Lambda表达式</h3>
<h4 id="61-概述用来实现一个接口本质是一个匿名函数">6.1 概述：用来实现一个接口，本质是一个匿名函数</h4>
<h4 id="62-条件">6.2 条件：</h4>
<ul>
<li>要求被实现接口中有且仅有一个需要被实现的方法（函数式接口）</li>
</ul>
<h4 id="63-函数式接口">6.3 函数式接口：</h4>
<pre><code class="language-java">interface A{
    public abstract void show(); 
}
//标准的函数式接口定义，有且仅有一个需要被实现类重写的方法
</code></pre>
<pre><code class="language-java">interface B{
    public abstract void show();
    default void display(){}
}
//这里为什么说B也是一个函数式接口，是因为在JDK1.8版本中，接口中可以有default方法，default关键字修饰的方法就是初始化的抽象方法。或者说是一个已经实现了的抽象方法，不需要再在其他implement接口位置进行实现。比如定义了一个接口，有大量的类实现了这个接口，但是新需求来了，需要在原有的基础上添加一个方法，而使用default关键字的话就不用每个实现类都实现一次，只要在顶层接口中用default实现此方法，所有实现类就会全部拥有该方法，所以说display（）已经被重写，所以类实现此接口时只需要重写show（）方法，满足函数式接口的定义
</code></pre>
<pre><code class="language-java">interface C{
    public abstract void show();
    public static void display(){}
}
//这里为什么C也是一个函数式接口，是因为在JDK1.8版本中，接口中可以有静态方法，虽然静态方法可以不用实现但是必须有方法体，即{}，在类实现此接口时，不会继承接口中的static的方法，也就重写不了，所以需要被重写的方法只有show（）一个，满足函数式接口的定义
</code></pre>
<pre><code class="language-java">interface D{
    public abstract void show();
    public String toString();
}
//这里为什么说D也是一个函数式接口，是因为在类实现此接口时，由于默认预先继承Object类，而Object类重写了toString（）方法也算重写过了toString（）方法，因此此接口需要被实现的方法只有show（）一个，满足函数式接口的定义
</code></pre>
<h4 id="64-functionalinterface">6.4 @FunctionalInterface</h4>
<ul>
<li>@FunctionalInterface  注解  表示接口是一个函数式接口</li>
<li>可以用来验证某个接口是否为函数式接口</li>
</ul>
<h2 id="47-常用类api">47. 常用类(API)</h2>
<blockquote>
<p>java.lang包下的类使用时无需导包，其他的都需要导包</p>
</blockquote>
<h3 id="1-math类">1. Math类</h3>
<ul>
<li>
<p>所在包：java.lang.Math</p>
</li>
<li>
<p>常用方法：</p>
<ul>
<li>public static double random（）：返回一个大于等于0.0，小于1.0的double型数字</li>
<li>public static double abs（double a）：返回double类型的绝对值</li>
<li>public static float abs（float a）：返回float类型的绝对值</li>
<li>public static int abs（int a）：返回int类型的绝对值</li>
<li>public static long abs（long a）：返回long类型的绝对值</li>
<li>public static double asin（double a）：返回角度的反正弦值</li>
<li>public static double acos（double a）：返回角度的反余弦值</li>
<li>public static double atan（double a）：返回角度的反正切值</li>
<li>public static double sin（double a）：返回角度的正弦值</li>
<li>public static double cos（double a）：返回角度的余弦值</li>
<li>public static double tan（double a）：返回角度的正切值</li>
<li>public static double log（double a）：返回自然对数ln（以e为底）值</li>
<li>public static double pow（double a，double b）：返回a的b次方值</li>
<li>public static long round（double a）：四舍五入为long</li>
<li>public static int round（float a）：四舍五入为int</li>
<li>public static double ceil（double a）：向上取整为double</li>
<li>public static double floor（double a）：向下取整double</li>
<li>public static double sqrt（double a）：返回a的开平方根</li>
</ul>
</li>
</ul>
<h3 id="2-random类">2. Random类</h3>
<ul>
<li>
<p>所在包：jav.util.Random</p>
</li>
<li>
<p>构造方法：</p>
<ul>
<li>public Random（）：创建一个新的随机数生成器</li>
<li>public Random（long seed）：使用种子创建一个新的随机数生成器</li>
</ul>
</li>
<li>
<p>常用方法：</p>
<ul>
<li>public int nextInt()：获取一个随机 int 数字（范围是int类型的范围，有正负两种）</li>
</ul>
<pre><code class="language-java">import java.util.Random;
...
Random r = new Random();    
int num = r.nextInt();  //-2147483648~2147483647  
System.out.println(num);
</code></pre>
<ul>
<li>public int nextInt(int num)：获取一个随机 int 数字，（参数表示范围，左闭右开区间）</li>
</ul>
<pre><code class="language-java">import java.util.Random;
...
Random r = new Random();
int num = r.nextInt(5);//[0,5)
System.out.println(num);
</code></pre>
<ul>
<li>public void setSeed（long seed）：设置随机数种子（有规律可循的伪随机数）</li>
</ul>
<pre><code class="language-java">public static void main(String [] args){
	System.out.println(&quot;未设置随机数种子，取到的随机数&quot;);
    for (int k = 0; k &lt; 5; k++) {
		Random ran = new Random();
		for (int i = 0; i &lt; 10; i++) {
			System.out.print(ran.nextInt(100)+&quot;\t&quot;);
		}
        System.out.println(&quot;&quot;);
	}
    System.out.println(&quot;设置随机数种子后，取到的随机数&quot;);
    for (int j = 0; j &lt; 5; j++) {
		Random ran2 = new Random();
		ran2.setSeed(100);
		for (int i = 0; i &lt; 10; i++) {
			System.out.print(ran2.nextInt(100)+&quot;\t&quot;);
		}
		System.out.println(&quot;&quot;);
	}    
}

//输出结果		
//未设置随机数种子，取到的随机数
58	76	62	95	90	61	53	30	31	20	
87	22	11	77	87	61	9	76	43	81	
17	52	16	94	10	14	11	11	73	83	
11	93	34	66	82	87	30	43	65	81	
12	31	77	91	80	54	58	16	86	46	
//设置随机数种子后，取到的随机数
15	50	74	88	91	66	36	88	23	13	
15	50	74	88	91	66	36	88	23	13	
15	50	74	88	91	66	36	88	23	13	
15	50	74	88	91	66	36	88	23	13	
15	50	74	88	91	66	36	88	23	13	
</code></pre>
</li>
</ul>
<h3 id="3-object类">3. Object类</h3>
<ul>
<li>
<p>所在包：java.lang.Object</p>
</li>
<li>
<p>构造方法：</p>
<ul>
<li>public Object（）</li>
<li>如果一个类没有继承其他类，则去使用Object的无参构造方法</li>
</ul>
</li>
<li>
<p>常用方法：</p>
<ul>
<li>
<p>protected Object clone（）</p>
<ul>
<li>创建一个副本对象</li>
<li>自定义类实现Cloneable接口，是一个标记接口，实现了这个接口的类的对象可以实现自我克隆</li>
<li>自定义类中重写Object中的clone方法</li>
</ul>
<pre><code class="language-java">@Override
protected Object clone() throws CloneNotSupportedException {
	return super.clone();
}
</code></pre>
</li>
<li>
<p>boolean equals（Object obj）</p>
<ul>
<li>比较两个对象是否相等</li>
</ul>
<pre><code class="language-java">public boolean equals(Object obj) {
        return (this == obj);
}
</code></pre>
<ul>
<li>默认的equals方法比较对象引用地址，没有意义，子类应该重写这个方法</li>
</ul>
<pre><code class="language-java">public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof String) {
            String anotherString = (String)anObject;
            int n = value.length;
            if (n == anotherString.value.length) {
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                        return false;
                    i++;
                }
                return true;
            }
        }
        return false;
}
</code></pre>
</li>
<li>
<p>protected void finalize（）</p>
<ul>
<li>当对象不再使用的时候，提醒垃圾回收器来回收对象</li>
</ul>
</li>
<li>
<p>class&lt;?&gt; getClass（）</p>
<ul>
<li>返回当前正在运行的类的字节码文件对象</li>
</ul>
</li>
<li>
<p>int hashCode（）</p>
<ul>
<li>返回对象的哈希Code值</li>
<li>是通过对象地址值计算出来的，并不是对象的真正地址</li>
</ul>
</li>
<li>
<p>String toString（）</p>
<ul>
<li>返回对象的字符串表示形式</li>
</ul>
<pre><code class="language-java">//Object类中的toString方法
public String toString() {
        return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());
}
</code></pre>
<ul>
<li>默认的toString方法没有意义，子类应该去重写该方法</li>
</ul>
<pre><code class="language-java">	@Override
    public String toString() {
        return &quot;Student{&quot; +
                &quot;sname='&quot; + sname + '\'' +
                &quot;, sage=&quot; + sage +
                &quot;, sgender='&quot; + sgender + '\'' +
                '}';
    }
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="4-scanner类">4.  Scanner类</h3>
<ul>
<li>接受键盘标准输入</li>
<li>构造方法
<ul>
<li>Scanner（InputStream in）
<ul>
<li>InputStream in = System.in；</li>
</ul>
</li>
</ul>
</li>
<li>成员方法
<ul>
<li>nextXxxx（）：查找并返回下一个键盘输入数据
<ul>
<li>next（）</li>
<li>nextBoolean（）</li>
<li>nextByte（）</li>
<li>nextDouble（）</li>
<li>nextFloat（）</li>
<li>nextInt（）</li>
<li>nextLine（）</li>
<li>nextLong（）</li>
<li>nextShort（）</li>
</ul>
</li>
<li>hasNextXxxx（）：判断并返回是否存在下一个键盘输入数据
<ul>
<li>hasNext（）</li>
<li>hasNextBoolean（）</li>
<li>hasNextByte（）</li>
<li>hasNextDouble（）</li>
<li>hasNextFloat（）</li>
<li>hasNextInt（）</li>
<li>hasNextLine（）</li>
<li>hasNextLong（）</li>
<li>hasNextShort（）</li>
</ul>
</li>
<li>close（）：关闭Scanner对象</li>
</ul>
</li>
<li>先获取一个数字，再获取一个字符串时，不让输入直接结束了，因为回车也算一个字符
<ul>
<li>可以把两个数据都以字符串形式接受，然后在进行转换</li>
</ul>
</li>
</ul>
<h3 id="5arrays类">5.Arrays类</h3>
<ul>
<li>常用方法
<ul>
<li>sort方法：
<ul>
<li>public static void sort（数组）：数组排序</li>
</ul>
</li>
<li>toString方法：
<ul>
<li>public static String toString（数组）：将数组转为字符串</li>
</ul>
</li>
<li>binarySearch方法：
<ul>
<li>public static int binarySearch（被查找的数组，被查找的值）：使用二分法在指定数组中查找指定值</li>
</ul>
</li>
<li>public static <T> List<T> asList（T... a）：把数组转集合
<ul>
<li>数组转集合后，集合长度不可变</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-system类">6. System类</h3>
<ul>
<li>包：java.lang.System</li>
<li>字段：
<ul>
<li>static printStream err：标准错误输出流</li>
<li>static InputStream in：标准输入流</li>
<li>static PrintStream out：标准输出流</li>
</ul>
</li>
<li>成员方法：
<ul>
<li>public static long currentTimeMillis（）：获取当前时间（单位：毫秒）</li>
<li>public static void exit（int status）：终止当前运行的Java虚拟机
<ul>
<li>status为状态码，按照惯例，非零状态码表示异常终止</li>
</ul>
</li>
<li>public static void gc（）：运行垃圾回收器</li>
<li>public static Properties getProperties（）：获取当前的系统属性</li>
<li>public static void arraycopy（Object src，int srcPos，Object dest，int destPos，int length）
<ul>
<li>src：原数组</li>
<li>srcPos：原数组中的起始位置</li>
<li>dest：目标数组</li>
<li>destPos：目标数组的起始位置</li>
<li>length：要复制的数组元素的数量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="7-collections类">7. Collections类</h3>
<ul>
<li>
<p>包：java.util.Collections</p>
</li>
<li>
<p>常用方法：</p>
<ul>
<li>public static <T> boolean addAll(Collection&lt;? super T&gt; c,  T... elements)：将多个元素加入指定集合中</li>
<li>public static void shuffle（List&lt;?&gt; list）：打乱集合顺序</li>
<li>public static <T> void sort（List<T> list）：将集合按照默认顺序（升序）排列</li>
<li>public static <T> void sort（List<T> list，Comparator&lt;? super T&gt;）：将集合中元素按照指定比较器指定的排序规则排序</li>
</ul>
</li>
</ul>
<h2 id="48-string类">48. String类</h2>
<ul>
<li>包：java.lang.String</li>
<li>注意事项
<ul>
<li>
<p>字符串是常量，一旦被创建出来，不可改变</p>
</li>
<li>
<p>正是因为字符串是不可改变的，所以字符串可以共享使用</p>
</li>
<li>
<p>jdk1.8及以前String使用的是char数组，jdk1.9及以后使用的是byte数组。</p>
<blockquote>
<p>因为开发人员发现人们使用的字符串值是拉丁字符居多而之前使用的char数组每一个char占用两个字节而拉丁字符只需要一个字节就可以存储，剩下的一个字节就浪费了，造成内存的浪费，gc的更加频繁。因此在jdk9中将String底层的实现改为了byte数组。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="1-构造方法">1. 构造方法</h3>
<ul>
<li>public String（）：创建一个空白字符串，不含有任何内容</li>
<li>public String（char[ ] chars）：根据字符数组的内容，来创建对应的字符串</li>
<li>public String（byte[ ] bytes）：根据字节数组的内容，来创建对应的字符串</li>
<li>public String（byte[] bytes,  Charset charset）：按指定字符集解码并创建对应字符串</li>
<li>public String（byte[] bytes,  int offset, int length）：按照字节数组内容，从指定位置开始指定长度创建对应字符串</li>
<li>public String（byte[] bytes,  int offset, int length, Charset charset）：按照字节数组内容按指定编码从指定位置开始指定长度的字节数组内容创建对应字符串</li>
<li>public String（String original）：初始化新创建的String对象</li>
<li>public String（StringBuffer buffer）：将StringBuffer字符序列转为String对象</li>
<li>public String（StringBuilder builder）：将StringBuilder字符序列转为String对象</li>
</ul>
<pre><code class="language-java">String str1 = new String();

char [] c = {'a','b','c'};
String str2 = new String(c);

byte [] b = {65,66,67};//ASCII码：A，B，C
String str3 = new String(b);

//直接创建
String str4 = &quot;String&quot;;
//直接写上双引号，即使没有new，也会创建对象
</code></pre>
<h3 id="2-字符串的常量池">2. 字符串的常量池</h3>
<ul>
<li>JDK1.8之前，字符串常量池位于运行时常量池，运行时常量池存在于方法区中，JDK1.8之后，字符串常量池位于堆中</li>
<li>对于引用类型来说，==比较的是地址值</li>
<li>双引号直接写的字符串在常量池中，new的不在常量池中</li>
<li>Java6和6之前，常量池是存放在方法区（此时hotspot虚拟机对方法区的实现为永久代）中的。</li>
<li>Java7，将字符串常量池是单独存放到了堆中，运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代</li>
<li>Java8之后，取消了整个永久代区域，取而代之的是元空间。运行时常量池和静态常量池存放在元空间中，而字符串常量池依然存放在堆中，只不过方法区的实现从永久代变成了元空间(堆外内存)</li>
</ul>
<blockquote>
<p>在JDK1.8中，使用元空间代替永久代来实现方法区，但是方法区并没有改变，所谓&quot;Your father will always be your father&quot;，变动的只是方法区中内容的物理存放位置。正如上面所说，类型信息（元数据信息）等其他信息被移动到了元空间中；但是运行时常量池和字符串常量池被移动到了堆中。但是不论它们物理上如何存放，逻辑上还是属于方法区的。</p>
<p>JDK1.8中字符串常量池和运行时常量池逻辑上属于方法区，但是实际存放在堆内存中，因此既可以说两者存放在堆中，也可以说两则存在于方法区中，这就是造成误解的地方。</p>
<p>其实，移除永久代的工作从JDK1.7就开始了。JDK1.7中，存储在永久代的部分数据就已经转移到了Java Heap或者是 Native Heap。但永久代仍存在于JDK1.7中，并没完全移除，譬如符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap。</p>
<p>引用自：https://www.cnblogs.com/cosmos-wong/p/12925299.html</p>
</blockquote>
<figure data-type="image" tabindex="13"><img src="http://pic.zyblog.xyz/img/typora/20201111093041.png" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="http://pic.zyblog.xyz/img/typora/20201110212103.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="15"><img src="http://pic.zyblog.xyz/img/typora/20201112110934.png" alt="img" loading="lazy"></figure>
<ul>
<li>问题：<strong>String str1 = new String(&quot;abc&quot;)；创建了多少个对象？</strong></li>
</ul>
<blockquote>
<ol>
<li>从字符串常量池中查找是否存在“abc”对象，如果存在，返回引用地址，如果不存在，则创建一个对象</li>
<li>new String（）在堆中开辟空间创建了一个对象</li>
</ol>
<p>综上所述，创建了两个对象，一个引用</p>
</blockquote>
<ul>
<li>问题：<strong>String str1 = new String(&quot;A&quot;+&quot;B&quot;) ; 会创建多少个对象？</strong></li>
</ul>
<blockquote>
<ol>
<li>“A”如果没有在字符串常量池中被找到，就会被创建</li>
<li>“B”如果没有在字符串常量池中被找到，就会被创建</li>
<li>“AB”如果没有在字符串常量池中被找到，就会被创建</li>
<li>new String（）在堆中开辟空间创建了一个对象</li>
</ol>
<p>综上所述，创建了四个对象，一个引用</p>
</blockquote>
<ul>
<li>问题：<strong>String str2 = new String(&quot;ABC&quot;) + &quot;ABC&quot; ; 会创建多少个对象?</strong></li>
</ul>
<blockquote>
<ol>
<li>“ABC”如果没有在字符串常量池中被找到，就会被创建</li>
<li>“ABC”已经被创建，在字符串常量池中找到，返回引用地址</li>
<li>new String（）在堆中创建了一个对象</li>
<li>“ABCABC”被创建</li>
</ol>
<p>综上所述，创建了三个对象，一个引用</p>
</blockquote>
<h3 id="3-常用方法">3. 常用方法</h3>
<ul>
<li>
<p>public boolean equals（Object obj）</p>
<ul>
<li>参数可以是任何对象，只有参数为一个字符串并且内容相同才会返回true，否则返回false</li>
<li>如果一个常量和一个变量比较
<ul>
<li>&quot;abc&quot;.equals(str)  ✔️推荐使用，当str为null时，返回false，结果依然正确</li>
<li>str.equals(&quot;abc&quot;)​ ​ ❌不推荐使用，当str为null时，会出现NullPointerException空指针异常</li>
</ul>
</li>
</ul>
</li>
<li>
<p>public boolean equalsIgnoreCase(String str)</p>
<ul>
<li>忽略大小写，直接比较内容</li>
</ul>
</li>
<li>
<p>public char charAt（int index）</p>
<ul>
<li>返回指定索引处的字符</li>
</ul>
</li>
<li>
<p>public boolean endsWith（String str）</p>
<ul>
<li>判断字符串是否以制定后缀结尾</li>
</ul>
</li>
<li>
<p>public boolean startsWith（String str）</p>
<ul>
<li>判断字符串是否以指定前缀开头</li>
</ul>
</li>
<li>
<p>public boolean contains(CharSequence s)</p>
<ul>
<li>当且仅当此字符串包含指定的char值序列时才返回true</li>
<li>CharSequence是一个接口，String，StringBuilder，StringBuffer均是此接口的实现</li>
</ul>
</li>
<li>
<p>public byte[ ] getBytes（）</p>
<ul>
<li>使用默认字符集编码将字符串编码为字节数组</li>
</ul>
</li>
<li>
<p>public byte[ ] getBytes（Charset charset）</p>
<ul>
<li>使用给定编码将字符串编码为字节数组</li>
</ul>
</li>
<li>
<p>public int indexOf（String str）</p>
<ul>
<li>返回指定字符串在字符串内第一次出现的索引</li>
</ul>
</li>
<li>
<p>public int indexOf（String str，int fromIndex）</p>
<ul>
<li>返回指定字符串从指定索引处开始在字符串内第一次出现的索引</li>
</ul>
</li>
<li>
<p>public int lastIndexOf（String str）</p>
<ul>
<li>返回指定字符串从在字符串中最后一次出现的位置</li>
</ul>
</li>
<li>
<p>public int lastIndexOf（String str,  int fromIndex）</p>
<ul>
<li>返回指定字符串从指定索引处开始在字符串内最后一次出现的索引</li>
</ul>
</li>
<li>
<p>public boolean isEmpty（）</p>
<ul>
<li>判断字符串是否为空</li>
</ul>
</li>
<li>
<p>public String intern（）</p>
<ul>
<li>返回字符串对象的规范表示</li>
</ul>
</li>
<li>
<p>public int length（）</p>
<ul>
<li>返回该字符串的长度</li>
</ul>
</li>
<li>
<p>public String replace（char oldchar，char newchar）</p>
<ul>
<li>提供被替换的字符，和替换的新字符，返回替换后的字符串结果</li>
</ul>
</li>
<li>
<p>public String replaceAll（String regex，String replacement）</p>
<ul>
<li>提供被替换字符串的正则表达式规则，和替换的字符串，返回替换后的结果</li>
</ul>
</li>
<li>
<p>public String replaceFirst（String regex，String replacement）</p>
<ul>
<li>提供被替换字符串的正则表达式规则，和替换的字符串，只替换第一个满足条件的字符串并返回结果</li>
</ul>
</li>
<li>
<p>public String [ ] split（String regex）</p>
<ul>
<li>提供字符串分割的正则表达式规则，将分割后的结果存入字符串数组并返回</li>
</ul>
</li>
<li>
<p>public String [ ] split（String regex，int limit）</p>
<ul>
<li>提供字符串分割的正则表达式规则，limit控制分割的次数，次数为limit-1，将分割后的结果存入字符串数组并返回</li>
</ul>
<blockquote>
<p><strong>官方解释</strong></p>
<p><code>limit</code> 参数控制模式应用的次数，因此影响所得数组的长度。如果该限制 <em>n</em> 大于 0，则模式将被最多应用 <em>n</em> - 1 次，数组的长度将不会大于 <em>n</em>，而且数组的最后一项将包含所有超出最后匹配的定界符的输入。如果 <em>n</em> 为非正，那么模式将被应用尽可能多的次数，而且数组可以是任何长度。如果 <em>n</em> 为 0，那么模式将被应用尽可能多的次数，数组可以是任何长度，并且结尾空字符串将被丢弃。</p>
</blockquote>
</li>
<li>
<p>public String substring（int beginIndex）</p>
<ul>
<li>提供切割字符串的起始位置，返回切割后的结果，包头不包尾</li>
</ul>
</li>
<li>
<p>public String substring（int beginIndex，int endIndex）</p>
<ul>
<li>提供切割字符串的起始和结束位置，返回切割后的结果，包头不包尾</li>
</ul>
</li>
<li>
<p>public char [ ] toCharArray（）</p>
<ul>
<li>将字符串转为新的字符数组并返回字符数组</li>
</ul>
</li>
<li>
<p>public String toString（）</p>
<ul>
<li>
<p>将字符串转为字符串并返回</p>
<blockquote>
<p>为什么字符串依然有转为字符串的方法，因为java中所有的类都有一个默认的父类Object，toString方法就来自Object</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>public String toLowerCase（）</p>
</li>
<li>
<p>将字符串按照默认语言环境，转小写</p>
</li>
<li>
<p>public String toUpperCase（）</p>
<ul>
<li>将字符串按照默认语言环境，转大写</li>
</ul>
</li>
<li>
<p>public static String valueOf（数据类型 变量名）</p>
<ul>
<li>将任意数据类型转为字符串形式</li>
</ul>
</li>
<li>
<p>public String concat（String str）</p>
</li>
<li>
<p>将指定字符串连接到该字符串末尾</p>
</li>
<li>
<p>public int compareTo（String anotherString）</p>
<ul>
<li>按字典顺序（ASCII码表Unicode码）比较两个字符串
<ul>
<li>一个一个的字符ASCII码依次比较，如果第一个大，直接返回第一个字符码值差值</li>
<li>如果等于返回0</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="49-stringbuffer类">49. StringBuffer类</h2>
<h3 id="1-概述-2">1. 概述</h3>
<ul>
<li>
<p>我们对字符串进行拼接的时候，每次都会产生一个新的String对象，耗时又浪费时间，使用StringBuffer可以解决这个问题</p>
</li>
<li>
<p>线程安全，可变的字符序列</p>
</li>
<li>
<p>包：java.lang.StringBuffer</p>
</li>
</ul>
<h3 id="2-构造方法">2. 构造方法</h3>
<ul>
<li>public StringBuffer（）
<ul>
<li>初始化空内容的字符串缓冲区</li>
</ul>
</li>
<li>public StringBuffer（CharSequence seq）
<ul>
<li>初始化指定字符序列的字符串缓冲区</li>
</ul>
</li>
<li>public StringBuffer（int capacity）
<ul>
<li>初始化指定容量的空内容的字符串（容量是理论值，长度是实际值，默认容量16）</li>
</ul>
</li>
<li>public StringBuffer（String str）
<ul>
<li>初始化指定字符串内容的字符串缓冲区</li>
</ul>
</li>
</ul>
<h3 id="3-常用方法-2">3. 常用方法</h3>
<ul>
<li>
<p>append方法</p>
<ul>
<li>public StringBuffer append（boolean b）</li>
<li>public StringBuffer append（char c）</li>
<li>public StringBuffer append（char [ ] str）</li>
<li>public StringBuffer append（char [ ] str，int offset，int len）</li>
<li>public StringBuffer append（CharSequence s）</li>
<li>public StringBuffer append（CharSequence s，int start，int end）</li>
<li>public StringBuffer append（double d）</li>
<li>public StringBuffer append（float f）</li>
<li>public StringBuffer append（int i）</li>
<li>public StringBuffer append（long lng）</li>
<li>public StringBuffer append（Object obj）</li>
<li>public StringBuffer append（String str）</li>
<li>public StringBuffer append（StringBuffer sb）</li>
</ul>
</li>
<li>
<p>insert方法</p>
<ul>
<li>public StringBuffer insert（int offset，boolean b）</li>
<li>public StringBuffer insert（int offset，char c）</li>
<li>public StringBuffer insert（int offset。char [ ] str）</li>
<li>public StringBuffer insert（int index，char [ ] str，int offset，int len）</li>
<li>public StringBuffer insert（int dstOffset，CharSequence s）</li>
<li>public StringBuffer insert（int dstOffset,  CharSequence s, int start,  int end）</li>
<li>public StringBuffer insert（int offset,  double d）</li>
<li>public StringBuffer insert（int offset,  float f）</li>
<li>public StringBuffer insert（int offset,  int i）</li>
<li>public StringBuffer insert（int offset,  long l）</li>
<li>public StringBuffer insert（int offset,  Object obj）</li>
<li>public StringBuffer insert（int offset,  String str）</li>
</ul>
</li>
<li>
<p>indexOf方法</p>
<ul>
<li>public int indexOf（String str）</li>
<li>public int indexOf（String str，int fromIndex）</li>
<li>public int lastIndexOf（String str）</li>
<li>public int lastIndexOf（String str，int fromIndex）</li>
</ul>
</li>
<li>
<p>常用方法</p>
<ul>
<li>
<p>public int length（）：返回当前长度</p>
</li>
<li>
<p>public int capacity（）：返回当前容量</p>
</li>
<li>
<p>public StringBuffer replace（int start，int end，String str）：用一段字符串替换指定位置长度的字符串</p>
</li>
<li>
<p>public StringBuffer reverse（）：反转字符串</p>
</li>
<li>
<p>public String substring（int start）：从指定位置截取字符串</p>
</li>
<li>
<p>public String substring（int start，int end）：截取指定位置长度的字符串</p>
</li>
<li>
<p>public String toString（）：转为字符串</p>
</li>
<li>
<p>public void setCharAt（int index，char ch）：将指定位置字符替换为ch</p>
</li>
<li>
<p>public void setLength（int newLength）：设置长度</p>
</li>
</ul>
</li>
<li>
<p>delete方法</p>
<ul>
<li>public StringBuffer delete（int start，int end）：删除指定位置开始到指定位置结束的字符串并返回结果</li>
<li>public StringBuffer deleteCharAt（int index）：删除指定位置的字符并返回结果</li>
</ul>
</li>
</ul>
<h2 id="50-stringbuilder">50. StringBuilder</h2>
<ul>
<li>
<p>StringBuffer和StringBuilder的区别</p>
<ul>
<li>线程安全：
<ul>
<li>StringBuffer线程安全
<ul>
<li>因为StringBuffer的所有公开方法都是synchronized修饰的</li>
</ul>
</li>
<li>StringBuilder线程不安全</li>
</ul>
</li>
<li>缓冲区：
<ul>
<li>StringBuffer每次获取toString都会直接使用缓冲区的toStringCache值来构造字符串</li>
<li>StringBuilder每次都要复制一次字符数组来构造一个字符串</li>
<li>StringBuffer 对缓存区优化，不过 StringBuffer 的这个toString 方法仍然是同步的（synchronized）</li>
</ul>
</li>
<li>性能：
<ul>
<li>StringBuffer 是线程安全的，它的所有公开方法都是同步的</li>
<li>StringBuilder 是没有对方法加锁同步的，性能高于StringBuffer</li>
</ul>
</li>
</ul>
<blockquote>
<p>StringBuffer 适用于用在多线程操作同一个 StringBuffer 的场景，如果是单线程场合 StringBuilder 更适合</p>
</blockquote>
</li>
</ul>
<h2 id="51-string作为参数">51. String作为参数</h2>
<h3 id="1-形式参数">1. 形式参数</h3>
<ul>
<li>基本类型：形式参数的改变不影响实参</li>
<li>引用类型：形式参数的改变直接影响实际参数</li>
<li>String比较特殊，作为参数传递的时候，效果和基本类型一样</li>
</ul>
<pre><code class="language-java">package com.demo.javase.demo;

/**
 * @author 絷缘
 * @version 1.0
 * @date 2020/11/13 13:58
 **/
public class StringBufferDemo1 {
    public static void main(String[] args) {
        StringBuffer sb1 = new StringBuffer(&quot;hello&quot;);
        StringBuffer sb2 = new StringBuffer(&quot;world&quot;);
        System.out.println(&quot;sb1=&quot;+sb1+&quot;,sb2=&quot;+sb2);
        change(sb1,sb2);
        System.out.println(&quot;sb1=&quot;+sb1+&quot;,sb2=&quot;+sb2);

    }
    public static void change(StringBuffer sb1,StringBuffer sb2){
        sb1 = sb2;
        sb2.append(sb1);
        System.out.println(&quot;sb1=&quot;+sb1+&quot;,sb2=&quot;+sb2);
    }
}
//输出结果为
//sb1=hello,sb2=world
//sb1=worldworld,sb2=worldworld
//sb1=hello,sb2=worldworld

</code></pre>
<h2 id="52-date类">52. Date类</h2>
<ul>
<li>包：java.util.Date</li>
<li>构造方法：
<ul>
<li>public Date（） ：创建一个Date对象，并初始化为当前时间</li>
<li>public Date（int year，int month，int date）：创建一个Date对象，并初始化为指定时间
<ul>
<li>year：指定年份-1900</li>
<li>month：0-11</li>
<li>date：1-31</li>
</ul>
</li>
<li>public Date（int year，int month，int date，int hrs，int min，int sec）
<ul>
<li>year：指定年份-1900</li>
<li>month：0-11</li>
<li>date：1-31</li>
<li>hrs：0-23</li>
<li>min：0-59</li>
<li>sec：0-59</li>
</ul>
</li>
<li>public Date（long date）：使用给定毫秒值创建Date对象</li>
<li>public Date（String s）：使用字符串内容创建Date对象并初始化它</li>
</ul>
</li>
<li>常用方法：
<ul>
<li>public String toString（）：格式化日期为YYYY-MM--DD字符串</li>
<li>public static Date valueOf（String s）：将JDBC日期字符串转为Date对象</li>
<li>public int getYear（）：获取年份</li>
<li>public int getMonth（）：获取月份</li>
<li>public int getDate（）：获取日期</li>
<li>public int getDay（）：获取星期几</li>
<li>public int getHours（）：获取时</li>
<li>public int getMinutes（）：获取分</li>
<li>public int getSeconds（）：获取秒</li>
<li>public long getTime（）：获取从1970年开始到现在的毫秒数</li>
<li>public void setYear（int year）：设置年份</li>
<li>public void setMonth（int month）：设置月份</li>
<li>public void setDate（int date）：设置日期</li>
<li>public void setHours（int hours）：设置时</li>
<li>public void setMinutes（int minutes）：设置分</li>
<li>public void setSeconds（int seconds）：设置秒</li>
<li>public void setTime（long time）：设置从1970年开始到现在的毫秒数</li>
</ul>
</li>
</ul>
<h2 id="53-dateformat">53. DateFormat</h2>
<ul>
<li>包：java.text.DateFormat</li>
<li>子类：SimpleDateFormat</li>
<li>构造方法：
<ul>
<li>protected DateFormat（）</li>
</ul>
</li>
<li>成员方法：
<ul>
<li>public String format（Date date）：将日期格式化为日期时间字符串</li>
<li>public Calendar getCalendar（）：将日期时间格式化为日历对象</li>
<li>public TimeZone getTimeZone（）：获取时区</li>
<li>public void setCalendar（Calendar newCalendar）</li>
<li>public void setTimeZone（TimeZone zone）</li>
<li>public Date parse（String source）：将字符串格式化为Date类型</li>
</ul>
</li>
<li>子类
<ul>
<li>构造方法
<ul>
<li>SimpleDateFormat（）</li>
<li>SimpleDateFormat（String pattern）：指定模式创建对象</li>
<li>SimpleDateFormat（String pattern，DateFormatSymbols formatSymbols）</li>
<li>SimpleDateFormat（String pattern，Locale locale）</li>
</ul>
</li>
<li>成员方法
<ul>
<li>public void applyLocalizedPattern（String pattern）</li>
<li>public void applyPattern（String pattern）</li>
<li>public boolean equals（Object obj）</li>
<li>public DateFormatSymbols getDateFormatSymbols（）</li>
<li>public void setDateFormatSymbols（DateFormatSymbols newFormatSymbols）</li>
<li>public StringBuffer format（Date date, StringBuffer toAppendTo, FieldPosition pos）</li>
<li>public Date parse（String text,  ParsePosition pos）</li>
<li>public String toLocalizedPattern（）</li>
<li>public String toPattern（）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="54-calendar类">54. Calendar类</h2>
<ul>
<li>
<p>包：java.util.Calendar</p>
</li>
<li>
<p>构造方法：</p>
<ul>
<li>protected Calendar（）：创建日历对象</li>
<li>protected Calendar（TimeZone zone，Locale aLocale）：创建指定时区和区域设置的日历对象</li>
</ul>
</li>
<li>
<p>成员方法：</p>
<ul>
<li>
<p>public abstract void add（int field,  int amount）：为指定字段添加值</p>
<ul>
<li>Calendar.YEAR</li>
<li>Calendar.MONTH</li>
<li>Calendar.DATE</li>
<li>Calendar.HOUR</li>
<li>Calendar.MINUTE</li>
<li>Calendar.SECOND</li>
</ul>
</li>
<li>
<p>public boolean after（Object when）：判断是否为参数时间之后的时间</p>
</li>
<li>
<p>public boolean before（Object when）：判断是否为参数时间之前的时间</p>
</li>
<li>
<p>public boolean equals（Object obj）：判断两个日期是否相同</p>
</li>
<li>
<p>public String getCalendarType（）：获取Calendar的的日历类型</p>
</li>
<li>
<p>public int get（int field）：获取指定日历字段的值</p>
<ul>
<li>Calendar.YEAR</li>
<li>Calendar.MONTH</li>
<li>Calendar.DATE</li>
<li>Calendar.HOUR</li>
<li>Calendar.MINUTE</li>
<li>Calendar.SECOND</li>
</ul>
</li>
<li>
<p>public void set（int field,  int value）：为指定字段设置值</p>
<ul>
<li>Calendar.YEAR</li>
<li>Calendar.MONTH</li>
<li>Calendar.DATE</li>
<li>Calendar.HOUR</li>
<li>Calendar.MINUTE</li>
<li>Calendar.SECOND</li>
</ul>
</li>
<li>
<p>public static Calendar getInstance（）：使用默认时区获取日历对象</p>
</li>
<li>
<p>public Date getTime（）：获取Date对象</p>
</li>
<li>
<p>public long getTimeInMillis（）：获取当前时间毫秒值</p>
</li>
<li>
<p>public TimeZone getTimeZone（）：获取时区</p>
</li>
<li>
<p>public void set（int year,  int month, int date, int hourOfDay, int minute, int second）：设置字段值</p>
</li>
<li>
<p>public void setTimeZone（TimeZone value）：设置指定时区</p>
</li>
<li>
<p>public void setTime（Date date）：使用Date对象设置日历时间</p>
</li>
<li>
<p>public void setTimeInMillis（long millis）：使用毫秒值设置日历时间</p>
</li>
<li>
<p>public Instant toInstant（）：将日历对象转为Instant对象</p>
<ul>
<li>Instant：在时间线上的瞬间点。</li>
<li>调用了Instant的toString方法，输出此瞬间使用ISO-8601表示形式的字符串表示形式。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="55-获取当前时间">55. 获取当前时间</h2>
<ul>
<li>时间戳</li>
</ul>
<pre><code class="language-java">//方法一：耗时最短
System.currentTimeMillis();
//方法二：耗时最长，效率最低
Calendar.getInstance().getTimeInMillis();
//方法三：耗时第二
new Date().getTime();
</code></pre>
<ul>
<li>时间</li>
</ul>
<pre><code class="language-java">SimpleDateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);//设置日期格式
String date = df.format(new Date());// new Date()为获取当前系统时间，也可使用当前时间戳
</code></pre>
<h2 id="56-基本类型包装类">56. 基本类型包装类</h2>
<h3 id="1-概述-3">1. 概述</h3>
<ul>
<li>把基本数据类型封装成类类型，然后我们就可以使用类中的方法来处理数据</li>
<li>常用操作：用于基本数据类型和字符串之间的转换</li>
</ul>
<h3 id="2-包装类">2. 包装类</h3>
<ul>
<li>基本类型：byte short int long float double char boolean</li>
<li>包装类类型：Byte Short Integer Long Float Double Character Boolean</li>
</ul>
<h3 id="3-integer">3. Integer</h3>
<ul>
<li>
<p>包：java.lang.Integer</p>
</li>
<li>
<p>字段</p>
<ul>
<li>BYTES：int型字节数4</li>
<li>MAX_VALUE：int型最大值（2147483647）</li>
<li>MIN_VALUE：int型最小值（-2147483648）</li>
<li>SIZE：int型二进制位数32</li>
<li>TYPE：类的原始类型为int</li>
</ul>
</li>
<li>
<p>构造方法</p>
<ul>
<li>Integer(int value)：将int类型装箱为Integer类型</li>
<li>Integer(String s)：将数字字符串装箱为Integer类型</li>
</ul>
</li>
<li>
<p>常用方法</p>
<ul>
<li>public static int compare（int x，int y）：比较两个int数字值</li>
<li>public int compareTo（Integer anotherInteger）：比较两个Integer对象</li>
<li>public static int compareUnsigned（int x，int y） ：忽略符号比较两个int数字值</li>
<li>public static Integer decode（String nm）：将String解码为Integer</li>
<li>public boolean equals（Object obj）：与指定对象进行比较</li>
<li>public int intValue（）：将Integer转为int</li>
<li>public static int parseInt（Stirng s）：将字符串参数解析为（有符号）十进制整数</li>
<li>public static String toBinaryString（int i）：将int型转换为二进制字符串</li>
<li>public static String toHexString（int i）：将int型转换为十六进制字符串</li>
<li>public static String toOctalString（int i）：将int型转换为八进制字符串</li>
<li>public String toString（）：转为字符串</li>
<li>public static String toString（int i）：把int转为String</li>
<li>public static String toString（int i，int radix）：把int转为指定进制字符串，radix为基数</li>
<li>public static Integer valueOf（int i）：将int类型转为Integer对象</li>
<li>public static Integer valueOf（String s）：将数字字符串转为Integer对象</li>
</ul>
</li>
</ul>
<blockquote>
<p>最大进制为36进制：0-9，A-Z</p>
</blockquote>
<h3 id="4-自动拆箱装箱">4. 自动拆箱装箱</h3>
<blockquote>
<p>从JDK1.5+，支持自动装箱（基本数据类型 -&gt; 包装类型），支持自动拆箱（包装类型 -&gt; 基本数据类型）</p>
</blockquote>
<pre><code class="language-java">Integer it = new Integer(555);
		||
Integer it = 555; 	//自动装箱：把基本数据类型自动装换为包装类类型

it = it + 666;		//自动拆箱：把包装类类型自动转换为基本数据类型

//如果it为null，会报NullPointerException异常
Integer it2 = null;
it2 += 10;
</code></pre>
<h3 id="5-character">5. Character</h3>
<ul>
<li>字段</li>
<li>构造方法
<ul>
<li>public Character（char value）：将char类型装箱成Character</li>
</ul>
</li>
<li>成员方法
<ul>
<li>public char charValue（）：返回Character的值</li>
<li>public static int compare（char x，char y）：比较两个char值</li>
<li>public int compareTo（Charater anotherCharacter）：比较两个Character对象</li>
<li>public boolean equals（Object obj）：比较两个Character对象</li>
<li>public static boolean isDigit（char ch）：确定字符是否是数字</li>
<li>public static boolean isLetter（char ch）：确定字符是否为一个字母</li>
<li>public static boolean isLetterOrDigit（char ch）：确定指定字符是字母还是数字</li>
<li>public static boolean isLowerCase（char ch）：确定字符是否为小写字符</li>
<li>public static boolean isUpperCase（char ch）：确定字符是否为大写字符</li>
<li>public static boolean isSpaceChar（char ch）：确定字符是否为空格字符</li>
<li>public static boolean isWhitespace（char ch）：确定字符是否为空格字符</li>
<li>public static char toLowerCase（char ch）：字符转小写</li>
<li>public static char toUpperCase（cahr ch）：字符转大写</li>
<li>public String toString（）</li>
<li>public static Character valueOf（char c）：将char装箱为Character对象</li>
</ul>
</li>
</ul>
<h3 id="6-boolean">6. Boolean</h3>
<ul>
<li>成员变量
<ul>
<li>FALSE</li>
<li>TRUE</li>
<li>TYPE</li>
</ul>
</li>
<li>构造方法
<ul>
<li>public Boolean（boolean value）：只能是true和false</li>
<li>public Boolean（String s）：只有字符串为true时，为true，其它都为false</li>
</ul>
</li>
<li>成员方法
<ul>
<li>public boolean booleanValue（）：将Boolean拆箱为boolean类型</li>
<li>public static int compareTo（Boolean b）：比较两个Boolean类型</li>
<li>public boolean equals（Object obj）：比较boolean的值是否相等</li>
<li>public static boolean parseBoolean（String s）：将字符串转为boolean值</li>
<li>public static Boolean valueOf（boolean b）：将boolean装箱为Boolean类型</li>
<li>public static Boolean valueOf（String s）：将字符串转为Boolean类型</li>
</ul>
</li>
</ul>
<h3 id="7-double">7. Double</h3>
<ul>
<li>包：java.lang.Double</li>
<li>字段
<ul>
<li>BYTES：用于表示double型字节数</li>
<li>MAX_VALUE：最大正有限值</li>
<li>MIN_VALUE：最小的非零有限值</li>
<li>NaN：Not a Number</li>
<li>SIZE：double所占位数</li>
<li>TYPE：返回类型</li>
</ul>
</li>
<li>构造方法
<ul>
<li>public Double（double value）：将double类型变量装箱为Double类型对象</li>
<li>public Double（String s）：通过字符串的值创建一个Double对象</li>
</ul>
</li>
<li>成员方法
<ul>
<li>public byte byteValue（）：将Double对象拆箱为byte类型</li>
<li>public int compareTo（Double anotherDouble）：比较两个Double对象</li>
<li>public double doubleValue（）：将Double对象拆箱为double对象</li>
<li>public boolean equals（Object obj）：比较两个对象的值</li>
<li>public float floatValue（）：将Double对象拆箱为float类型</li>
<li>public int intValue（）：返回Double对象的int值</li>
<li>public boolean isNaN（）：判断是否为非数字</li>
<li>public static double parseDouble（Stirng s）：将String转为double型</li>
<li>public short shortValue（）：返回Double对象的short值</li>
<li>public static String toHexString（double d）：返回double类型的十六进制字符串</li>
<li>public static Double valueOf（double d）：将double 装箱为Double对象</li>
<li>public static Double valueOf（String s）：将字符串转为Double对象</li>
</ul>
</li>
</ul>
<h2 id="57-正则表达式">57. 正则表达式</h2>
<h3 id="1-概述-4">1. 概述</h3>
<ul>
<li>是一种用来描述匹配特定规则文本的字符串</li>
</ul>
<h3 id="2-正则表达式的规则">2. 正则表达式的规则</h3>
<ul>
<li>本处仅描述常用规则，其他详见 “正则表达式.md”
<ul>
<li>普通字符
<ul>
<li>a，b，c.......</li>
<li>0，1，2.......</li>
</ul>
</li>
<li>转义字符
<ul>
<li>\r：回车符</li>
<li>\n：换行符</li>
<li>\s：任意空字符</li>
<li>\t：制表符</li>
<li>\f：换页符</li>
</ul>
</li>
<li>预定义字符
<ul>
<li>点：任意字符</li>
<li>\d：所有数字</li>
<li>\D：非数字</li>
<li>\b：单词边界</li>
<li>\B：非单词边界</li>
<li>\w：单词字符</li>
<li>\W：非单词字符</li>
</ul>
</li>
<li>字符类
<ul>
<li>[abc]：a或b或c</li>
<li>[^abc]：除了a，b，c</li>
<li>[a-zA-Z]：所有大小写字母</li>
<li>[0-9]：0到9所有数字</li>
</ul>
</li>
<li>边界匹配器
<ul>
<li>^：行的开头</li>
<li>$：行的结尾</li>
</ul>
</li>
<li>数量词
<ul>
<li>？：一次或零次</li>
<li>*：零次或多次</li>
<li>+：一次或多次</li>
<li>{n}：出现n次</li>
<li>{n,m}：出现n到m次</li>
<li>{n,}：至少出现n次</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-正则表达式的应用">3. 正则表达式的应用</h3>
<ul>
<li>判断
<ul>
<li>public boolean  matches（String regex）</li>
</ul>
</li>
<li>分割
<ul>
<li>public String [ ] split（String regex）</li>
</ul>
</li>
<li>替换
<ul>
<li>public String replaceAll（String regex，String replacement）</li>
</ul>
</li>
<li>获取
<ul>
<li>Pattern类和Matcher类</li>
</ul>
</li>
</ul>
<pre><code class="language-java">//将正则表达式编译为模式对象
Pattern p = compile(&quot;\\d+&quot;);
//通过模式对象获取匹配器对象
Matcher m = p.matcher(&quot;zhiyuandnc666&quot;);
//调用匹配器的功能
boolean b = m.matches();
boolean b2 = m.lookingAt();
System.out.println(b);
System.out.println(b2);
System.out.println(b3); 
//返回结果
//false
//false
//true
</code></pre>
<pre><code class="language-java">String str = &quot;momo is a da shuai ge,zhen de shi yi ge da shuai ge,da shuai ge,shuai ge.&quot;;
Pattern p2 = Pattern.compile(&quot;\\b\\w{3}\\b&quot;);
Matcher m2 = p2.matcher(str);
while(m2.find()){
	String group = m2.group();
	System.out.println(group);
}
</code></pre>
<h2 id="58-biginteger">58. BigInteger</h2>
<ul>
<li>
<p>包：java.math.BigInteger</p>
</li>
<li>
<p>字段</p>
<ul>
<li>ONE：常数一</li>
<li>TEN：常数十</li>
<li>ZERO：常数零</li>
</ul>
</li>
<li>
<p>构造方法</p>
<ul>
<li>public BigInteger（byte [ ] val）</li>
<li>public BigInteger（int signum，byte [ ] magnitude）</li>
<li>public BigInteger（String val）</li>
</ul>
</li>
<li>
<p>成员方法</p>
<ul>
<li>
<p>public BigInteger add（BigInteger val）：加法运算</p>
</li>
<li>
<p>public BigInteger subtract（BigInteger val）：减法运算</p>
</li>
<li>
<p>public BigInteger divide（BigInteger val）：除法运算</p>
</li>
<li>
<p>public BigInteger multiply（BigInteger val）：乘法运算</p>
</li>
<li>
<p>public BigInteger remainder（BigInteger val）：取余运算</p>
</li>
<li>
<p>public BigInteger pow（int exponent）：次方运算</p>
</li>
<li>
<p>public BigInteger [ ] divideAndRemainder（BigInteger val）：返回包含商和余数的BigInteger数组</p>
</li>
<li>
<p>public int intValue（）：转为int</p>
</li>
</ul>
</li>
</ul>
<h2 id="59-bigdecimal">59. BigDecimal</h2>
<ul>
<li>
<p>浮点型数据操作容易损失精度</p>
<pre><code class="language-java">System.out.println(0.01+0.09);
System.out.println(0.08+0.02);
System.out.println(1.0-0.33);
System.out.println(1.015*100);
System.out.println(1.211/100);
//输出结果
0.09999999999999999
0.1
0.6699999999999999
101.49999999999999
0.012110000000000001
</code></pre>
<blockquote>
<p>因为浮点型的存储形式参考：https://blog.csdn.net/u014470361/article/details/79820892，导致超过16位的浮点数的精度丢失，我们需要更精确的结果，所以出现了BigDecimal类型，用于对超过16位有效位浮点数进行精确运算</p>
</blockquote>
</li>
<li>
<p>包：java.math.BigDecimal</p>
</li>
<li>
<p>字段：</p>
</li>
<li>
<p>构造方法</p>
<ul>
<li>
<p>BigDecimal(int)</p>
<p>创建一个具有参数所指定整数值的对象</p>
</li>
<li>
<p>BigDecimal(double)</p>
<p>创建一个具有参数所指定双精度值的对象</p>
</li>
<li>
<p>BigDecimal(long)</p>
<p>创建一个具有参数所指定长整数值的对象</p>
</li>
<li>
<p>BigDecimal(String)</p>
<p>创建一个具有参数所指定以字符串表示的数值的对象</p>
</li>
</ul>
</li>
<li>
<p>成员方法</p>
<ul>
<li>
<p>add(BigDecimal)</p>
<p>BigDecimal对象中的值相加，返回BigDecimal对象</p>
</li>
<li>
<p>subtract(BigDecimal)</p>
<p>BigDecimal对象中的值相减，返回BigDecimal对象</p>
</li>
<li>
<p>multiply(BigDecimal)</p>
<p>BigDecimal对象中的值相乘，返回BigDecimal对象</p>
</li>
<li>
<p>divide(BigDecimal)</p>
<p>BigDecimal对象中的值相除，返回BigDecimal对象</p>
</li>
<li>
<p>toString()</p>
<p>将BigDecimal对象中的值转换成字符串</p>
</li>
<li>
<p>doubleValue()</p>
<p>将BigDecimal对象中的值转换成双精度数</p>
</li>
<li>
<p>floatValue()</p>
<p>将BigDecimal对象中的值转换成单精度数</p>
</li>
<li>
<p>longValue()</p>
<p>将BigDecimal对象中的值转换成长整数</p>
</li>
<li>
<p>intValue()</p>
<p>将BigDecimal对象中的值转换成整数</p>
</li>
</ul>
</li>
</ul>
<h2 id="60-stringtokenizer">60. StringTokenizer</h2>
<ul>
<li>包：java.util.StringTokenizer</li>
<li>构造方法：
<ul>
<li>public StringTokenizer（String str）</li>
<li>public StringTokenizer（String str，String delim）
<ul>
<li>str：字符串</li>
<li>delim：分隔符</li>
</ul>
</li>
<li>public StringTokenizer（String str，String delim，boolean returDelims）
<ul>
<li>str：字符串</li>
<li>delim：分隔符</li>
<li>returnDelims：是否返回分隔符</li>
</ul>
</li>
</ul>
</li>
<li>成员方法
<ul>
<li>public int countTokens（）：统计分隔符出现的次数</li>
<li>public boolean hasMoreElements（）：判断字符串中是否存在下一个元素</li>
<li>public Object nextElement（）：获取字符串中的下一个元素</li>
</ul>
</li>
</ul>
<h2 id="61-集合">61. 集合</h2>
<ul>
<li>
<p>概述：集合就是java中用来存储多个不同引用类型的对象的容器</p>
</li>
<li>
<p>数组和集合的区别</p>
<ul>
<li>数组长度固定，既可以存储普通类型，也可以存储引用类型，但是只能存一种数据类型</li>
<li>集合长度可变，只能存储引用类型，但是可以存储不同引用类型</li>
</ul>
</li>
<li>
<p>集合特点</p>
<ul>
<li>智能存储对象，集合长度是可变的，集合可以存储不同类型的对象</li>
</ul>
</li>
<li>
<p>集合框架</p>
<figure data-type="image" tabindex="16"><img src="http://pic.zyblog.xyz/img/typora/20201118161923.gif" alt="集合" loading="lazy"></figure>
</li>
</ul>
<figure data-type="image" tabindex="17"><img src="http://pic.zyblog.xyz/img/typora/20201118162323.jpeg" alt="Collection" loading="lazy"></figure>
<figure data-type="image" tabindex="18"><img src="http://pic.zyblog.xyz/img/typora/20201118162352.png" alt="Map" loading="lazy"></figure>
<h3 id="一-collection集合顶层接口">一. Collection集合（顶层接口）</h3>
<ul>
<li>
<p>包：java.util.Collection</p>
</li>
<li>
<p>Collection集合层次结构中的顶层接口</p>
</li>
<li>
<p>常用方法</p>
<ul>
<li>public boolean add（E e）：将指定元素加入集合</li>
<li>public boolean addAll （Collection&lt;? extends E&gt;）：将指定集合所有元素加入集合</li>
<li>public void clear（）：删除集合中所有元素</li>
<li>public boolean contains（Object o）：判断集合中是否存在指定元素</li>
<li>public boolean containsAll（Collection&lt;?&gt; c）：判断集合中是否存在指定集合所有元素</li>
<li>public boolean equals（Object o）：比较指定对象与集合是否相等</li>
<li>public int hashCode（）：返回此集合的哈希码值</li>
<li>public boolean isEmpty（）：判断集合是否为空</li>
<li>public Iterator<E> iterator（）：返回集合的元素迭代器</li>
<li>public boolean remove（Object o）：从集合中移除指定元素</li>
<li>public boolean removeAll（Collection&lt;?&gt; c）：从集合中移除指定集合中所有元素</li>
<li>public boolean retainAll（Collection&lt;?&gt; c）：仅保留集合中指定集合的所有元素，返回原集合是否被修改
<ul>
<li>原集合如果没有指定集合中的元素，原集合置空</li>
<li>如果两个集合元素相同，原集合保持不变</li>
<li>如果原集合包含指定集合元素，则保留两者交集</li>
</ul>
</li>
<li>public int size（）：返回集合的元素个数</li>
<li>public Object[ ] toArray（）：将集合转为数组</li>
</ul>
</li>
<li>
<p>Collection集合框架</p>
</li>
</ul>
<figure data-type="image" tabindex="19"><img src="http://pic.zyblog.xyz/img/typora/20201118210316.png" alt="img" loading="lazy"></figure>
<h4 id="1-list接口继承自collection接口jdk12列表">1. List接口（继承自Collection接口，JDK1.2）【列表】</h4>
<ul>
<li>
<p>包：java.util.List</p>
</li>
<li>
<p>List接口继承自Collection接口</p>
</li>
<li>
<p>特点：</p>
<ul>
<li>有序的集合（存储和取出元素顺序相同）</li>
<li>允许存储重复的元素</li>
<li>有索引，可以使用for循环直接遍历（这也是有序的一个表现）</li>
</ul>
</li>
<li>
<p>实现类：</p>
<ul>
<li>ArrayList
<ul>
<li>结构是数组，查询快，增删慢：线程不安全，效率高</li>
</ul>
</li>
<li>LinkedList
<ul>
<li>结构是链表，查询慢，增删快：线程不安全，效率高</li>
</ul>
</li>
<li>Vector
<ul>
<li>结构是数组，查询快，增删慢：线程安全，效率低</li>
<li>Stack</li>
</ul>
</li>
</ul>
</li>
<li>
<p>常用方法：</p>
<ul>
<li>public void add（int index，E element）：将指定元素加入到集合指定索引处</li>
<li>public boolean addAll（int index，Collection&lt;? extends E&gt; c）：将指定集合从指定索引处加入集合</li>
<li>public E get（int index）：获取集合中指定索引处元素值</li>
<li>public int indexOf（Object o）：指定元素在集合中第一次出现的索引值</li>
<li>public int lastIndexOf（Object o）：指定元素在集合中最后一次出现的索引值</li>
<li>public ListIterator<E> listIterator（）</li>
<li>public ListIterator<E> listIterator（int index）</li>
<li>public E remove（int index）：移除集合中指定索引的元素</li>
<li>public boolean remove（Object o）：移除集合中指定元素</li>
<li>public boolean removeAll（Collection&lt;?&gt; c）：从集合中移除指定集合中的内容</li>
<li>public E set（int index，E element）：设置集合中指定索引处元素值</li>
<li>public int size（）：获取集合元素个数</li>
<li>public Object[ ] toArray（）：将集合转为Object数组</li>
<li>public List<E> subList（int fromIndex，int toIndex）：从集合中取出一段集合</li>
</ul>
</li>
</ul>
<h4 id="2-set接口继承自collection接口jdk12集合">2. Set接口（继承自Collection接口，JDK1.2）【集合】</h4>
<ul>
<li>包：java.util.Set</li>
<li>Set接口继承自Collection接口</li>
<li>特点：
<ul>
<li>无序的集合</li>
<li>不允许有重复的元素</li>
<li>没有索引，无法用for循环直接遍历，需要迭代器（这也是无序的一个表现）</li>
</ul>
</li>
<li>实现类：
<ul>
<li>TreeSet</li>
<li>HashSet
<ul>
<li>LinkedHashSet</li>
</ul>
</li>
</ul>
</li>
<li>常用方法：
<ul>
<li>public boolean add（E e）：若指定元素在集合中不存在，则加入集合</li>
<li>public boolean addAll（Collection &lt;? extends E&gt; c）：若指定集合中的元素在集合中不存在，则加入集合</li>
<li>public void clear（）：删除集合中所有元素</li>
<li>public boolean contains（Object o）：判断集合中是否包含指定元素</li>
<li>public boolean containsAll（Collection&lt;? extends E&gt; c）：判断集合中是否包含制定集合中的所有元素</li>
<li>public boolean equals（Object o）：比较两个集合是否相等</li>
<li>public boolean isEmpty（）：判断集合是否为空</li>
<li>public Iterator<E> iterator（）：返回集合元素迭代器</li>
<li>public boolean remove（Object o）：从集合中删除指定元素</li>
<li>public boolean removeAll（Collection&lt;? extends E&gt; c）：从集合中删除指定集合中包含的所有元素</li>
<li>public boolean retainAll（Collection&lt;? extends E&gt; c）：取交集</li>
<li>public int size（）：返回集合中元素的个数</li>
<li>public Object[ ] toArray（）：返回集合对象数组</li>
<li>public <T> T[ ] toArray（T [ ] a）：返回指定类型的集合对象数组</li>
</ul>
</li>
</ul>
<h4 id="3-queue接口继承自collection接口jdk15队列">3. Queue接口（继承自Collection接口，JDK1.5）【队列】</h4>
<ul>
<li>Queue接口继承自Collection接口</li>
<li>注意事项：
<ul>
<li>Queue使用时要尽量避免Collection的add()和remove()方法，而是要使用offer()来加入元素，使用poll()来获取并移出元素，它们的优点是通过返回值可以判断是否成功，add()和remove()方法在失败的时候会抛出异常</li>
<li>LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用</li>
</ul>
</li>
<li>特点：
<ul>
<li>先进先出，先添加的元素，最先被删除</li>
<li>队列是一种特殊的线性表，他只允许在表的前端删除元素，在表的后端插入元素</li>
</ul>
</li>
<li>实现类：
<ul>
<li>ArrayDeque</li>
<li>PriorityQueue</li>
</ul>
</li>
<li>Queue集合框架</li>
</ul>
<figure data-type="image" tabindex="20"><img src="http://pic.zyblog.xyz/img/typora/20201118212911.jpeg" alt="img" loading="lazy"></figure>
<blockquote>
<p>（1）. Deque接口（继承自Queue接口）【双端队列】</p>
<ul>
<li>Deque接口继承自Queue接口，同时具有队列和栈的功能</li>
<li>实现类
<ul>
<li>LinkedList：使用双向链表</li>
<li>ArrayDeque：使用循环数组实现双向队列</li>
</ul>
</li>
</ul>
<p>（2）. AbstractQueue类（实现自Queue接口）</p>
<ul>
<li>子类
<ul>
<li>PriorityQueue：优先队列，使用数组实现堆的结构，线程不安全</li>
<li>PriorityBlockingQueue：优先阻塞队列，使用ReentrantLock锁来保持同步，线程安全</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="二-map集合顶层接口">二. Map集合（顶层接口）</h3>
<ul>
<li>包：java.util.Map</li>
<li>Map集合层次接口中的顶层接口</li>
<li>常用方法：
<ul>
<li>public void clear（）：删除Map集合中所有元素</li>
<li>public boolean containsKey（Object key）：判断集合中是否包含指定键</li>
<li>public boolean containsValue（Object value）：判断集合中是否包含指定值</li>
<li>public boolean equals（Object o）：判断集合是否相同</li>
<li>public boolean isEmpty（）：判断集合是否为空</li>
<li>public V get（Object key）：获取指定键对应的值</li>
<li>public Set<K> keySet（）：获取Map集合中键的Set集合</li>
<li>public Set&lt;Map.Entry&lt;K，V&gt;&gt; entrySet（）：获取Map集合映射关系的Set集合</li>
<li>public V put（K key，V value）：将指定键值对加入Map集合</li>
<li>public void putAll（Map&lt;? extends K，? extends V&gt; m）：将指定集合中的所有映射加入到当前集合</li>
<li>public int size（）：返回Map集合中映射数量</li>
<li>public Collection<V> values（）：获取Map集合中值的Collection集合</li>
</ul>
</li>
<li>Map集合框架</li>
</ul>
<figure data-type="image" tabindex="21"><img src="http://pic.zyblog.xyz/img/typora/20201118213122.png" alt="img" loading="lazy"></figure>
<h3 id="三-iterator迭代器">三. Iterator迭代器</h3>
<ul>
<li>迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。</li>
<li>包：java.util.Iterator</li>
<li>获取迭代器对象的方式
<ul>
<li>iterator（）</li>
</ul>
</li>
<li>常用方法：
<ul>
<li>next（）：获取集合中的下一个元素</li>
<li>hasNext（）：判断集合中是否存在下一个元素</li>
<li>remove（）：删除迭代器已迭代元素</li>
</ul>
</li>
</ul>
<pre><code class="language-java"> public static void main(String[] args) {
        Collection c = new ArrayList();
        c.add(&quot;String&quot;);
        c.add(123);
        c.add(true);
        c.add('a');
        c.add(12.0);
        System.out.println(c);
        Iterator it = c.iterator();
        while(it.hasNext()){
            System.out.println(it.next());
        }
        for(;it.hasNext();){
            System.out.println(it.next());
        }
    }
</code></pre>
<h3 id="四-spliterator接口jdk18">四. Spliterator接口（JDK1.8）</h3>
<ul>
<li>包：java.util.Spliterator
<ul>
<li>Spliterator是Java 8中加入的一个新接口；这个名字代表“可拆分迭代器”（splitable iterator）。</li>
<li>和Iterator一样，Spliterator也用于遍历数据源中的元素，但它是为了并行执行而设计的。</li>
<li>Java 8已经为集合框架中包含的所有数据结构提供了一个默认的Spliterator实现。</li>
<li>集合实现了Spliterator接口，接口提供了一个spliterator方法。</li>
</ul>
</li>
<li>获取迭代器对象的方法：
<ul>
<li>spliterator（）</li>
</ul>
</li>
</ul>
<h3 id="五-listiterator接口jdk12">五. ListIterator接口（JDK1.2）</h3>
<ul>
<li>包：java.util.ListIterator</li>
<li>常用方法：
<ul>
<li>public void add（E e）</li>
<li>public boolean hasNext（）</li>
<li>public boolean hasPrevious（）</li>
<li>public E next（）</li>
<li>public int nextIndex（）</li>
<li>public E previous（）</li>
<li>public int previousIndex（）</li>
<li>public void remove（）</li>
<li>public void set（E e）</li>
</ul>
</li>
</ul>
<h2 id="62-arraylist可变数组">62. ArrayList可变数组</h2>
<ul>
<li>数组的长度不可以发生改变</li>
<li>ArrayList的长度可以发生改变</li>
<li>包：java.util.ArrayList</li>
<li>构造方法：
<ul>
<li>ArrayList（）：构造一个初始容量为10的空列表</li>
<li>ArrayList（Collection&lt;? extends E&gt; c）：构造一个包含指定集合的元素列表</li>
<li>ArrayList（int initialCapacity）：构造具有初始容量的空列表</li>
</ul>
</li>
</ul>
<blockquote>
<p>ArrayList<E></p>
<p><E>代表泛型</p>
<p>泛型：也就是装在集合中的所有元素属于什么类型，注意泛型只能是引用类型，不能是基本类型</p>
</blockquote>
<h3 id="1-格式">1. 格式：</h3>
<pre><code class="language-java">ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
</code></pre>
<blockquote>
<p>ArrayList<String> list = new ArrayList<String>();</p>
<p>从JDK1.8开始，右侧尖括号内部可以不写内容，默认与左边相同，JDK1.8之前需要写明内容，但是建议写上</p>
</blockquote>
<ul>
<li>注意事项：
<ul>
<li>对于ArrayList集合来说，直接打印得到的不是地址值，而是内容，如果内容为空，得到的是空的中括号</li>
</ul>
</li>
</ul>
<h3 id="2-向集合中添加一些数据需要用到add方法">2. 向集合中添加一些数据，需要用到add方法</h3>
<pre><code class="language-java">list.add(&quot;赵丽颖&quot;);
list.add(&quot;古力娜扎&quot;);
list.add(&quot;迪丽热巴&quot;);
list.add(&quot;胡歌&quot;);
System.out.println(list);
</code></pre>
<ul>
<li>注意事项：
<ul>
<li>添加的数据类型必须为创建ArrayList集合时使用的类型，否则为错误写法</li>
</ul>
</li>
</ul>
<h3 id="3-常用方法-3">3. 常用方法</h3>
<ul>
<li>public boolean add（E e）：向列表中添加元素，参数类型和创建列表时的泛型一致，返回值为添加是否成功</li>
<li>public E get（int index）：从列表中获取元素，参数是索引编号，返回值就是对应位置的元素</li>
<li>public E set（int index，E element）：为列表中指定位置的元素设置值</li>
<li>public E remove（int index）：从列表当中删除元素，参数是索引编号，返回值就是被删除的元素</li>
<li>public int size（）：获取列表的尺寸，返回值是集合中元素的个数</li>
<li>public void clear（）：从列表中删除所有元素</li>
<li>public boolean addAll（Collection<E> c）：将指定集合的内容（按迭代器返回的顺序）追加到列表的末尾</li>
<li>public boolean contains（Object o）：如果列表中包含指定元素，则返回true</li>
<li>public int indexOf（Object o）：返回此列表指定元素第一次出现的位置，如果不存在，返回-1</li>
<li>public int lastIndexOf（Object o）：返回此列表指定元素最后一次出现的位置，如果不存在，则返回-1</li>
<li>public boolean isEmpty（）：判断列表是否为空</li>
<li>public Object [ ] toArray（）：将列表转为数组</li>
<li>public void trimToSize（）：将列表的容量修改为列表当前大小</li>
</ul>
<h3 id="4-遍历arraylist集合">4. 遍历ArrayList集合</h3>
<pre><code class="language-java">for(int i = 0;i &lt; list.size();i++){
    System.out.println(list.get(i));
}
</code></pre>
<h3 id="5-arraylist存储基本数据类型">5. ArrayList存储基本数据类型</h3>
<ul>
<li>如果希望ArrayList当中存储基本数据类型，就必须使用基本数据类型的 “包装类”</li>
</ul>
<blockquote>
<p>包装类：是引用类型，包装类都位于java.lang包下</p>
<p>基本数据类型						包装类</p>
<p>byte											  Byte</p>
<p>short											Short</p>
<p>int												 Integer</p>
<p>long											  Long</p>
<p>float											  Float</p>
<p>double 										Double</p>
<p>char											  Character</p>
<p>boolean									  Boolean</p>
<p>从JDK1.5+，支持自动装箱（基本数据类型 -&gt; 包装类型），支持自动拆箱（包装类型 -&gt; 基本数据类型）</p>
</blockquote>
<ul>
<li>定义格式</li>
</ul>
<pre><code class="language-java">ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
</code></pre>
<h3 id="6-arraylist的遍历三种">6. ArrayList的遍历(三种)</h3>
<pre><code class="language-java">import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class ArrayListDemo {
    public static void main(String args[]){
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();
        list.add(&quot;鞠婧祎&quot;);
        list.add(&quot;佟丽娅&quot;);
        list.add(&quot;迪丽热巴&quot;);
        //方法一：Iterator（迭代器）遍历
        Iterator it1 = list.iterator();
        while(it1.hasNext()){
            System.out.println(it1.next());
        }
        for(Iterator it2;it2.hasNext();){
            System.out.println(it2.next());
        }
        //方法二：foreach遍历
        for(String li:list){
            System.out.println(li);
        }
        //方法三：for循环遍历
        for(int i = 0;i &lt; list.size();i++){
            System.out.println(list.get(i));
        }
    }    
</code></pre>
<h2 id="63-linkedlist">63. LinkedList</h2>
<ul>
<li>包：java.util.LinkedList</li>
<li>构造方法：
<ul>
<li>LinkedList（）：构造一个空链表</li>
<li>LinkedList（Collection&lt;? extends E&gt; c）：构造一个包含指定集合的空链表</li>
</ul>
</li>
</ul>
<h4 id="1-格式-2">1. 格式：</h4>
<pre><code class="language-java">LinkedList&lt;Student&gt; list = new LinkedList&lt;Student&gt;();
</code></pre>
<h4 id="2-常用方法">2. 常用方法：</h4>
<ul>
<li>public boolean add（E e）：将指定元素追加到集合末尾</li>
<li>public void add（int index，E element）：在集合中指定位置插入指定元素</li>
<li>public boolean addAll（Collection&lt;? extends E&gt; c）：将指定集合内容加入到集合末尾</li>
<li>public boolean addAll（int index，Collection&lt;? extends E&gt; c）：将指定集合内容从指定位置加入到集合</li>
<li>public void addFirst（E e）：在集合首部加入指定元素</li>
<li>public void addLast（E e）：在集合末尾加入指定元素</li>
<li>public void clear（）：删除集合中所有元素</li>
<li>public boolean contains（Object o）：判断集合中是否包含指定元素</li>
<li>public E element（）：</li>
<li>public E get（int index）：获取集合中指定位置的元素</li>
<li>public E getFirst（）：返回集合中第一个元素</li>
<li>public E getLast（）：返回集合中最后一个元素</li>
<li>public int indexOf（Object o）：返回指定元素在集合中第一次出现的位置</li>
<li>public int lastIndexOf（Object o）：返回指定元素在集合中最后一个出现的位置</li>
<li>public ListIterator<E> listIterator（int index）：获取迭代器</li>
<li>public boolean offer（E e）：将指定元素添加到集合的尾部</li>
<li>public boolean offerFirst（E e）：将指定元素添加到集合的首部</li>
<li>public boolean offerLast（E e）：将指定元素添加到集合的尾部</li>
<li>public E element（）：检索但不删除链表的头部（第一个元素）</li>
<li>public E peek（）：检索但不删除链表的头部（第一个元素）</li>
<li>public E peekFirst（）：检索但不删除链表的第一个元素，如果链表为空，返回null</li>
<li>public E peekLast（）：检索但不删除链表的最后一个元素，如果链表为空，返回null</li>
<li>public E poll（）：检索并删除链表的头（第一个元素）</li>
<li>public E pollFirst（）：检索并删除链表的第一个元素，如果链表为空，返回null</li>
<li>public E pollLast（）：检索并删除链表的最后一个元素，如果链表为空，返回null</li>
<li>public E pop（）：</li>
<li>public void push（E e）：</li>
<li>public E remove（）：检索并删除链表的头（第一个元素）</li>
<li>public E remove（int index）：删除链表中指定位置元素</li>
<li>public E removeFirst（）</li>
<li>public E removeLast（）</li>
<li>public E set（int index，E element）</li>
<li>public int size（）</li>
<li>public Spliterator<E> spliterator（）</li>
<li>public Object[ ] toArray（）</li>
<li>public <T> T[ ] toArray（T[ ] a）</li>
</ul>
<h2 id="64-vector">64. Vector</h2>
<ul>
<li>包：java.util.Vectory</li>
<li>构造方法：
<ul>
<li>Vector（）：构造一个初始容量为10的空集合</li>
<li>Vector（Collection&lt;? extends E&gt; c）：构造一个包含指定集合的集合</li>
<li>Vector（int initialCapacity）：构造一个指定容量的集合</li>
<li>Vector（int initialCapacity，int capacityIncrement）：构造一个指定容量指定增量的集合</li>
</ul>
</li>
</ul>
<h4 id="1-格式-3">1. 格式：</h4>
<pre><code class="language-java">Vector v = new Vector(16,2);
</code></pre>
<h4 id="2-常用方法-2">2. 常用方法：</h4>
<ul>
<li>public boolean add（E e）：将指定元素追加到集合末尾</li>
<li>public void add（int index，E element）：将指定元素插入到集合指定位置</li>
<li>public boolean addAll（Collection&lt;? extends E&gt; c）：将指定集合中所有内容追加到当前集合末尾</li>
<li>public boolean addAll（int index，Collection&lt;? extends E&gt; c）：将指定集合中所有内容插入到集合指定位置</li>
<li>public void addElement（E obj）：将指定组件添加到集合的末尾</li>
<li>public int capacity（）：获取集合容量</li>
<li>public void clear（）：删除集合中所有元素</li>
<li>public boolean contains（Object o）：判断集合中是否包含指定元素</li>
<li>public boolean containsAll（Collection&lt;?&gt; c）：判断集合中是否包含指定集合的所有元素</li>
<li>public void copyInto（Object[ ] anArray）：将集合复制到指定数组中</li>
<li>public E elementAt（int index）：获取指定索引处的元素</li>
<li>public Enumeration<E> elements（）：获取集合的元素枚举</li>
<li>public boolean equals（Object o）：将集合与指定对象比较</li>
<li>public E firstElement（）：返回集合的第一个元素</li>
<li>public void forEach（Consumer&lt;? super E&gt; action）：</li>
<li>public E get（int index）：获取指定位置的元素</li>
<li>public int indexOf（Object o）：返回集合中指定元素第一次出现的索引</li>
<li>public int indexOf（Object o，int index）：返回集合中指定元素从指定位置开始第一次出现的索引</li>
<li>public boolean isEmpty（）：检查集合是否为空</li>
<li>public Iterator<E> iterator（）：迭代器</li>
<li>public E lastElement（）：返回集合中最后一个元素</li>
<li>public int lastIndexOf（Object o）：返回集合中指定元素最后一次出现的索引</li>
<li>public int lastIndexOf（Object o，int index）：返回集合中指定元素从指定位置开始最后一次出现的索引</li>
<li>public ListIterator<E> listIterator（）：获取迭代器</li>
<li>public E remove（int index）：删除集合中指定元素</li>
<li>public boolean removeAll（Collection&lt;?&gt; c）：从集合中删除指定集合的所有元素</li>
<li>public void replaceAll（）</li>
<li>public boolean retainAll（Collection&lt;?&gt; c）：保留两集合的交集</li>
<li>public E set（int index，E element）：设置集合中指定位置的元素值</li>
<li>public void setSize（int newSize）：设置集合容量</li>
<li>public int size（）：获取集合元素个数</li>
<li>public List<E> subList（int fromIndex，int toIndex）：从集合中截取一段集合</li>
<li>public Object [ ] toArray（）：转Object数组</li>
<li>public <T> T [ ] toArray（T [ ] a）：转指定类型数组</li>
<li>public void trimToSize（）：修改容量</li>
</ul>
<h2 id="65-enumerationjavautil中的接口现已被iterator取代与enum没有关系">65. Enumeration：java.util中的接口，现已被Iterator取代，与enum没有关系</h2>
<h2 id="66-泛型">66. 泛型</h2>
<ul>
<li>概述：限定统一存储数据类型的一种特殊类型
<ul>
<li>泛型的实现是靠类型擦除技术 类型擦除是在编译期完成的 也就是在编译期 编译器会将泛型的类型参数都擦除成它的限定类型，如果没有则擦除为object类型之后在获取的时候再强制类型转换为对应的类型。 在运行期间并没有泛型的任何信息，因此也没有优化。</li>
</ul>
</li>
<li>格式：&lt;数据类型&gt;
<ul>
<li>数据类型必须是引用类型</li>
</ul>
</li>
<li>好处：
<ul>
<li>类型参数化，让应用类型像参数一样传递</li>
<li>使运行时异常变为编译时异常，减少了编译时的类型检查</li>
<li>泛型方法</li>
<li>减少类型转换，提高代码的安全性</li>
</ul>
</li>
<li>用法：
<ul>
<li>泛型接口</li>
<li>泛型抽象类</li>
<li>泛型类</li>
<li>方法参数类型约束</li>
<li>方法返回类型约束</li>
</ul>
</li>
</ul>
<h4 id="1-泛型类">1. 泛型类</h4>
<pre><code class="language-java">public class 类名&lt;泛型类型&gt;{}
</code></pre>
<h4 id="2-泛型方法">2. 泛型方法</h4>
<pre><code class="language-java">public &lt;泛型返回类型&gt; 返回类型 方法名(泛型类型形参){}
</code></pre>
<h4 id="3-泛型接口">3. 泛型接口</h4>
<pre><code class="language-java">interface 接口名&lt;泛型类型&gt;{}
</code></pre>
<h4 id="4-泛型抽象类">4. 泛型抽象类</h4>
<pre><code class="language-java">public abstract class 类名&lt;泛型类型&gt;{}
</code></pre>
<h4 id="5-泛型通配符">5. 泛型通配符</h4>
<pre><code class="language-java">&lt;?&gt;任意类型，如果不明确，那就是Object以及任意java类
&lt;? extends E&gt;向下限定，E及其子类
&lt;? super E&gt;向上限定，E及其父类
</code></pre>
<h2 id="67-增强for循环">67. 增强for循环</h2>
<pre><code class="language-java">for(元素数据类型 临时变量:多元素容器){
    System.out.println(临时变量);
}
</code></pre>
<ul>
<li>实现原理</li>
</ul>
<pre><code class="language-java">for (Integer i : list) {
   System.out.println(i);
}
</code></pre>
<p>反编译后</p>
<pre><code class="language-java">Integer i;
for(Iterator iterator = list.iterator(); iterator.hasNext(); System.out.println(i)){
   i = (Integer)iterator.next();        
}
</code></pre>
<h2 id="68-静态导入">68. 静态导入</h2>
<ul>
<li>
<p>直接导入到方法级别（方法必须是静态的）</p>
<ul>
<li>import static packageName.className.methodName；</li>
</ul>
</li>
<li>
<p>注意事项：</p>
<ul>
<li>方法必须为静态方法</li>
<li>如果有多个静态方法，就不知道用哪个，就需要加方法的绝对包路径进行调用</li>
</ul>
</li>
<li>
<p>例：</p>
</li>
</ul>
<pre><code class="language-java">import static java.lang.Math.abs;
import static java.lang.Math.pow;
import static java.lang.Math.max;
public class Demo{
    public static void main(String [] args){
        System.out.println(abs(111));
        System.out.println(pow(3,2));
        System.out.println(max(3,2));
    }
}
</code></pre>
<h2 id="69-可变参数">69. 可变参数</h2>
<ul>
<li>概述：
<ul>
<li>不知道方法将来需要多少个参数</li>
</ul>
</li>
<li>格式：
<ul>
<li>修饰符  返回值类型  方法名（数据类型... 变量名）{ }</li>
</ul>
</li>
<li>注意：
<ul>
<li>这里的变量其实是一个数组</li>
<li>如果一个方法既有可变参，也有其他参数，那么，可变参必须是最后一个</li>
<li>可变参只能有一个，且放在参数列表最后</li>
</ul>
</li>
<li>例：</li>
</ul>
<pre><code class="language-java">public static int sum(int... a){
    return a;
}
public static String method(Object... o){
    return o.toString();
}
</code></pre>
<h2 id="70-treeset">70. TreeSet</h2>
<ul>
<li>包：java.util.TreeSet</li>
<li>父类：java.util.AbstractSet</li>
<li>实现了SortedSet接口</li>
<li>构造方法：
<ul>
<li>public TreeSet（）：构造一个空的集合</li>
<li>public TreeSet（Collection&lt;? extends E&gt; c）：构造一个包含指定集合元素的新集合，根据元素自然排序进行排序</li>
<li>public TreeSet（Comparator&lt;? super E&gt; comparator）：按照指定比较器的顺序构造一个空的集合</li>
<li>public TreeSet（SortedSet<E> s）：构造一个包含指定集合元素的新集合，按照默认排序</li>
</ul>
</li>
<li>常用方法：
<ul>
<li>public boolean add（E e）：将指定元素添加到集合中</li>
<li>public boolean addAll（Collection&lt;? extends E&gt; c）：将指定集合中所有元素加入到集合中</li>
<li>public E ceiling（E e）：查找集合中大于等于指定元素的最小元素，如果没有，返回null</li>
<li>public Object clone（）：返回集合的浅拷贝</li>
<li>public void clear（）：删除集合中所有元素</li>
<li>public boolean contains（Object o）：判断集合中是否包含指定元素</li>
<li>public E first（）：返回集合中第一个元素</li>
<li>public E floor（E e）：查找集合中小于等于指定元素的最大元素，如果没有，返回null</li>
<li>public boolean isEmpty（）：判断集合是否为空</li>
<li>public Iterator<E> iterator（）：以升序返回集合元素迭代器</li>
<li>public Iterator<E> descendingIterator（）：以降序返回集合元素迭代器</li>
<li>public NavigableSet<E> descendingSet（）：返回集合元素反向排序集合</li>
<li>public E last（）：返回集合中最后一个元素</li>
<li>public E lower（E e）：查找集合中小于指定元素的最大元素，如果没有，返回null</li>
<li>public E higher（E e）：查找集合中大于指定元素的最小元素，如果没有，返回null</li>
<li>public E pollFirst（）：检索并删除集合中第一个元素</li>
<li>public E pollLast（）：检索并删除集合中最后一个元素</li>
<li>public boolean remove（Object o）：从集合中删除指定元素</li>
<li>public int size（）：返回集合中元素个数</li>
<li>public Spliterator<E> spliterator（）</li>
<li>public NavigableSet<E> subSet（E fromElement，boolean fromInclusive，E toElement，boolean toInclusive）：截取一段集合</li>
<li>public SortedSet<E> subSet（E fromElement，E toElement）：截取一段集合</li>
<li>public SortedSet<E> tailSet（E fromElement）：返回集合中大于等于指定元素的部分集合</li>
<li>public NavigableSet<E> tailSet（E fromElement，boolean inclusive）</li>
</ul>
</li>
<li>实现原理</li>
</ul>
<figure data-type="image" tabindex="22"><img src="http://pic.zyblog.xyz/img/typora/20201126165845.png" alt="img" loading="lazy"></figure>
<blockquote>
<p>比较器</p>
<ul>
<li>包：java.lang.Comparable</li>
<li>红黑树完成的自然排序实际上是依赖于Comparable接口中的compareTo（）方法，所以想要按照自己的方式进行数据排序，必须实现此接口并重写该方法</li>
<li>需要比较的对象的类去实现Comparable接口并重写compareTo（）方法</li>
<li>需要比较的对象的类也可以去实现Comparator接口并重写compare（）方法</li>
</ul>
<p>Comparable和Comparator的区别</p>
<ul>
<li><img src="http://pic.zyblog.xyz/img/typora/20201204135756.png" alt="img" loading="lazy"></li>
</ul>
</blockquote>
<h2 id="71-hashset">71. HashSet</h2>
<ul>
<li>
<p>底层数据结构是哈希表（元素是链表的数组）</p>
</li>
<li>
<p>包：java.util.HashSet</p>
</li>
<li>
<p>父类：java.util.AbstractSet</p>
</li>
<li>
<p>构造方法：（初始容量16，负载因子0.75）</p>
<ul>
<li>public HashSet（）：构造一个空集合</li>
<li>public HashSet（Collection&lt;? extends E&gt; c）：构造一个包含指定集合中所有元素的集合</li>
<li>public HashSet（int initialCapacity）：构造一个之指定容量的空集合</li>
<li>public HashSet（int initialCapacity，float loadFactor）：构造一个指定容量，指定负载因子的空集合</li>
</ul>
</li>
<li>
<p>常用方法：</p>
<ul>
<li>
<p>public boolean add（E e）：将指定元素加入集合</p>
</li>
<li>
<p>public void clear（）：删除集合中所有元素</p>
</li>
<li>
<p>public Object clone（）：返回HashSet的浅拷贝</p>
</li>
<li>
<p>public boolean isEmpty（）：判断集合是否为空</p>
</li>
<li>
<p>Iterator<E> iterator（）：返回集合元素迭代器</p>
</li>
<li>
<p>public boolean remove（Object o）：移除集合中指定元素</p>
</li>
<li>
<p>public int size（）：返回集合中元素个数</p>
</li>
</ul>
</li>
</ul>
<h2 id="72-linkedhashset">72. LinkedHashSet</h2>
<ul>
<li>底层数据结构是哈希表（元素是双向链表的数组）</li>
<li>元素存取有序</li>
<li>包：java.util.LinkedHashSet</li>
<li>父类：java.util.HashSet</li>
<li>构造方法：
<ul>
<li>public LinkedHashSet（）：构造一个默认容量16，负载因子0.75的空集合</li>
<li>public LinkedHashSet（Collection&lt;? extends E&gt; c）：构造包含指定集合的集合</li>
<li>public LinkedHashSet（int initialCapacity）：构造指定初始容量的空集合</li>
<li>public LinkedHashSet（int initialCapacity，float loadFactor）：构造指定初始容量和指定负载因子的空集合</li>
</ul>
</li>
<li>常用方法：继承自父类（HashSet的方法）
<ul>
<li>public boolean add（E e）：将指定元素加入集合</li>
<li>public void clear（）：删除集合中所有元素</li>
<li>public Object clone（）：返回HashSet的浅拷贝</li>
<li>public boolean isEmpty（）：判断集合是否为空</li>
<li>Iterator<E> iterator（）：返回集合元素迭代器</li>
<li>public boolean remove（Object o）：移除集合中指定元素</li>
<li>public int size（）：返回集合中元素个数</li>
</ul>
</li>
</ul>
<h2 id="73-hashmap">73. HashMap</h2>
<ul>
<li>包：java.util.HashMap</li>
<li>构造方法：
<ul>
<li>public HashMap（）：构造一个空的HashMap集合，初始容量为16，负载因子为0.75</li>
<li>public HashMap（int initialCapacity）：构造一个指定容量的HashMap集合</li>
<li>public HashMap（int initialCapacity，int loadFactor）：构造一个具有指定容量和指定负载因子的HashMap集合</li>
<li>public HashMap（Map&lt;? extends K,? extends V&gt; m）：构造一个包含指定Map集合所有映射关系的HashMap集合</li>
</ul>
</li>
<li>常用方法：
<ul>
<li>public void clear（）：删除集合中所有映射关系</li>
<li>public Object clone（）：获得集合的浅拷贝</li>
<li>public boolean containsKey（Object key）：判断集合中是否包含指定键</li>
<li>public boolean containsValue（Object value）：判断集合中是否包含指定值</li>
<li>public boolean isEmpty（）：判断集合是否为空</li>
<li>public V get（Object key）：获取指定键对应的值</li>
<li>public Set<K> keySet（）：获取Map集合中键的Set集合</li>
<li>public Set&lt;Map.Entry&lt;K，V&gt;&gt; entrySet（）：获取Map集合映射关系的Set集合</li>
<li>public V put（K key，V value）：将指定键值对加入Map集合（若指定键存在，则将指定值与之关联，说白了就是修改映射关系）</li>
<li>public void putAll（Map&lt;? extends K，? extends V&gt; m）：将指定集合中的所有映射加入到当前集合</li>
<li>public int size（）：返回Map集合中映射数量</li>
<li>public Collection<V> values（）：获取Map集合中值的Collection集合</li>
<li>public V remove（Object key）：删除指定键对应的键值对</li>
<li>public boolean remove（Object key，Object value）：删除唯一对应关系的键值对</li>
</ul>
</li>
</ul>
<h2 id="74linkedhashmap">74.LinkedHashMap</h2>
<ul>
<li>包：java.util.LinkedHashMap</li>
<li>父类：java.util.HashMap</li>
<li>构造方法：
<ul>
<li>public LinkedHashMap（）：构造一个空的LinkedHashMap集合，初始容量为16，负载因子为0.75</li>
<li>public LinkedHashMap（int initialCapacity）：构造一个指定容量的LinkedHashMap集合</li>
<li>public LinkedHashMap（int initialCapacity，int loadFactor）：构造一个具有指定容量和指定负载因子的LinkedHashMap集合</li>
<li>public LinkedHashMap（Map&lt;? extends K,? extends V&gt; m）：构造一个包含指定Map集合所有映射关系的LinkedHashMap集合</li>
<li>public LinkedHashMap（int initialCapacity，int loadFactor，boolean accessOrder）：构造一个具有指定初始容量和指定负载因子以及制定订购模式的LinkedHashMap集合</li>
</ul>
</li>
<li>常用方法：
<ul>
<li>public void clear（）：删除集合中所有映射关系</li>
<li>public boolean containsValue（Object value）：判断集合中是否存在指定值</li>
<li>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet（）：获取集合中所有映射关系组成的Set集合</li>
<li>public V get（Object key）：获取指定键对应的值</li>
<li>public Set<K> keySet（）：获取集合中所有键组成的Set集合</li>
<li>public Collection<V> values（）：获取集合中所有键组成的Collection集合</li>
</ul>
</li>
</ul>
<h2 id="75-treemap">75. TreeMap</h2>
<ul>
<li>
<p>包：java.util.TreeMap</p>
</li>
<li>
<p>父类：java.util.AbstractMap</p>
</li>
<li>
<p>构造方法：</p>
<ul>
<li>public TreeMap（）：构造一个（默认使用键自然排序）空TreeMap集合</li>
<li>public TreeMap（Comparator&lt;? super K&gt; comparator）：构造一个（按照指定比较器规则排序）空TreeMap集合</li>
<li>public TreeMap（Map&lt;? extends K，? extends V&gt; m）：构造一个包含指定Map集合所有映射关系的（按照指定Map集合中key的自然排序）TreeMap集合</li>
<li>public TreeMap（SortedMap&lt;K，? extends V&gt; m）：构造一个包含指定SortedMap集合中所有映射关系的并按照SortedMap中的排序规则排序的TreeMap集合</li>
</ul>
</li>
<li>
<p>常用方法：</p>
<ul>
<li>public void clear（）：删除集合中所有映射关系</li>
</ul>
</li>
<li>
<p>public Object clone（）：获取集合的浅拷贝</p>
<ul>
<li>public Comparator&lt;? super K&gt; comparator（）：返回集合的比较器</li>
</ul>
</li>
<li>
<p>public boolean containsKey（Object key）：判断集合中是否包含指定键</p>
<ul>
<li>public boolean containsValue（Object value）：判断集合中是否包含指定值</li>
</ul>
</li>
<li>
<p>public NavigableSet<K> descendingKeySet（）：返回相反顺序的键的Set集合</p>
<ul>
<li>public NavigableMap&lt;K，V&gt; descendingMap（）：返回相反顺序的映射关系的Map集合</li>
</ul>
</li>
<li>
<p>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet（）：获取集合中所有映射关系组成的Set集合</p>
<ul>
<li>public Map.Entry&lt;K，V&gt; firstEntry（）：获取集合中第一个键对应的映射关系</li>
</ul>
</li>
<li>
<p>public K firstKey（）：获取集合中第一个键的值</p>
</li>
<li>
<p>public Map.Entry&lt;K，V&gt; floorEntry（）：获取集合中最后一个键对应的映射关系</p>
</li>
<li>
<p>public K floorKey（）：获取集合中最后一个键的值</p>
</li>
<li>
<p>public V get（Object key）：获取指定键对应的值</p>
</li>
<li>
<p>public Set<K> keySet（）：获取集合中所有键构成的Set集合</p>
</li>
<li>
<p>public Collection<V> values（）：获取集合中所有值构成的Collection集合</p>
</li>
<li>
<p>public V put（K key，V value）：将指定映射关系加入集合中，若指定键已存在，则修改对应值</p>
</li>
<li>
<p>public void putAll（Map&lt;? extends K，? extends V&gt; m）：将指定Map集合中所有映射关系加入集合中</p>
</li>
<li>
<p>public V remove（Object key）：删除指定键对应的映射关系</p>
</li>
<li>
<p>public int size（）：返回集合中映射数量</p>
</li>
</ul>
<h2 id="76-异常">76. 异常</h2>
<h3 id="1-分类">1. 分类</h3>
<ul>
<li>运行时异常：所有RuntimeException类及子类都属于运行时异常
<ul>
<li>运行时异常一般是代码问题，提高代码健壮性</li>
</ul>
</li>
<li>编译时异常：除运行时异常外都属于编译时异常
<ul>
<li>编译时异常必须显示处理，否则无法编译通过</li>
</ul>
</li>
<li>自定义异常</li>
</ul>
<h3 id="2-处理异常">2. 处理异常</h3>
<ul>
<li>
<p>try...catch...finally</p>
<ul>
<li>
<p>变形格式：try...catch</p>
<pre><code class="language-java">try{
    //try里的代码越少越好，因为每捕获一次异常，JVM就会启动分配一次资源
}catch(异常名 变量名){
    //catch里面必须有内容，哪怕只给一个简单的提示
}
</code></pre>
</li>
<li>
<p>一个异常的处理，写一个<code>try{}catch{}</code></p>
</li>
<li>
<p>多个异常的处理，写一个<code>try{}</code>，写多个<code>catch(){}</code>，但是一个一场被捕获到就直接走catch语句了，无法捕获另外的异常</p>
</li>
<li>
<p>注意事项：</p>
<ul>
<li>能明确的异常尽量明确，实在不明确异常再使用Exception</li>
<li>如果有明确的异常，同级的异常前后无所谓，不同级的异常，明确的异常在前，Exception必须放置于最后，因为Exception可以匹配所有异常，是明确异常的父类的父类</li>
</ul>
</li>
<li>
<p>JDK1.7出现了一个新的异常处理方案：</p>
<pre><code class="language-java">try{
    
}catch(Exception1 | Exception2 | Exception3 | ... variableName){
    
}
</code></pre>
<ul>
<li>可以通过或将多个异常连接在一起，使得catch可以同时处理多个异常，但是**<code>注意：这种方式异常中不可以有Exception</code>**</li>
</ul>
</li>
</ul>
</li>
<li>
<p>异常中需要了解的方法：</p>
<ul>
<li>public String getMessage（）：返回异常的详细信息</li>
<li>public String toString（）：返回异常的简单介绍
<ul>
<li>这个对象的类的name（全路径名）</li>
<li>“：”（一个冒号和一个空格）</li>
<li>调用这个对象的**<code>getLocalizedMessage()</code><strong>方法的结果，默认返回</strong><code>getMessage()</code>**</li>
</ul>
</li>
<li>public void printStackTrace（）：将toString的内容以及异常出现的位置输出到控制台</li>
<li>public void printStackTrace（PrintStream s）：将异常内容保存到日志文件中，方便查看</li>
</ul>
</li>
<li>
<p>throws：有些异常我们无法处理或者权限不够时，就需要将异常抛出</p>
<ul>
<li>throws必须跟在方法的括号后面</li>
<li>编译期异常被抛出，将来的调用者必须处理</li>
<li>运行时异常被抛出，将来的调用者可以不处理</li>
<li>throws后可以跟多个异常，中间用逗号隔开</li>
</ul>
</li>
<li>
<p>throw：如果出现了异常情况，我们需要抛出该异常的对象，使用throw new 异常名（）；</p>
<ul>
<li>使用throw一定抛出了异常</li>
<li>使用throws可能抛出异常，并不一定会发生异常</li>
</ul>
</li>
<li>
<p>throw和throws的区别</p>
<ul>
<li>
<p>放在方法声明后面，跟的是异常类名</p>
</li>
<li>
<p>可以跟多个异常类名，用逗号隔开</p>
</li>
<li>
<p>表示抛出异常，由该方法的调用者来处理</p>
</li>
<li>
<p>throws表示出现异常的可能性，并不一定会抛出异常</p>
<hr>
</li>
<li>
<p>放在方法体内，跟的是对象名</p>
</li>
<li>
<p>只能抛出一个异常对象</p>
</li>
<li>
<p>表示抛出异常，有方法体内语句处理</p>
</li>
<li>
<p>throw表示抛出了异常，执行throw一定会抛出异常</p>
</li>
</ul>
</li>
<li>
<p>finally</p>
<ul>
<li>格式：<code>try{}catch(){}finally{}</code></li>
<li>finally 里的语句一定会被执行</li>
<li>用于释放资源，在IO流和数据库操作中常见</li>
</ul>
</li>
<li>
<p><strong><code>如果catch中有return语句，finally中的语句依然会被执行，且在return之前</code></strong></p>
</li>
<li>
<p>try...catch的几种变形</p>
<ul>
<li>try...catch...finally</li>
<li>try...catch</li>
<li>try...catch...catch</li>
<li>try...catch...catch...finally</li>
<li>try...finally（主要为了释放资源）</li>
</ul>
</li>
</ul>
<h3 id="3-自定义异常">3. 自定义异常</h3>
<ul>
<li>
<p>继承自Exception</p>
<ul>
<li>
<pre><code class="language-java">public class MyException extends Exception{
    public MyException(){}
    public MyException(String message){
        super(message);
    }
}

public class Teacher{
    public void checkScore(int score) throws MyException{
        if(score &gt; 0 &amp;&amp; score &lt; 100){
            System.out.println(&quot;分数正常&quot;);
        }else{
            throw new MyException(&quot;分数不正常&quot;);
        }
    }
}
public class Demo{
    public static void main(String [] args){
        Teacher t = new Teacher();
        t.checkScore(50);
        t.checkScore(120);
    }
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="77-io流">77. I/O流</h2>
<h3 id="1-file类路径名的表示形式文件是否存在还不一定">1. File类（路径名的表示形式，文件是否存在还不一定）</h3>
<ul>
<li>包：java.io.File</li>
<li>构造方法：
<ul>
<li>public File（File parent，String child）：创建在父路径对象（File parent）下的指定子文件（String child）的File对象</li>
<li>public File（String pathname）：创建一个绝对路径文件的File对象</li>
<li>public File（String parent，String child）：创建在父路径（String parent）下的指定子文件（String child）的File对象</li>
<li>public File（URI uri）：创建一个统一资源标识符表示的文件的File对象</li>
</ul>
</li>
<li>常用方法：
<ul>
<li>
<p>public boolean canExecute（）：测试文件是否具有可执行权限</p>
</li>
<li>
<p>public boolean canRead（）：测试文件是否具有可读权限</p>
</li>
<li>
<p>public boolean canWrite（）：测试文件是否具有可写权限</p>
</li>
<li>
<p>public int comparaTo（File pathname）：</p>
</li>
<li>
<p>public boolean createNewFile（）：当且仅当前文件不存在时创建新文件</p>
</li>
<li>
<p>public boolean delete（）：删除File对象对应的文件或目录</p>
</li>
<li>
<p>public void deleteOnExit（）：在虚拟机终止时删除File对象对应的文件或目录</p>
</li>
<li>
<p>public boolean equals（Object obj）：比较是否相等</p>
</li>
<li>
<p>public boolean exists（）：测试该文件是否存在</p>
</li>
<li>
<p>public File getAbsoluteFile（）：返回File对象的绝对路径的File对象</p>
</li>
<li>
<p>public String getAbsolutePath（）：返回File对象的绝对路径的字符串</p>
</li>
<li>
<p>public String getCanonicalPath（）：返回File对象的规范化绝对路径，（带.和..的路径格式）</p>
</li>
<li>
<p>public File getCanoncialFile（）：返回File对象的规范化表示File对象</p>
</li>
<li>
<p>public String getName（）：获取File对象表示的文件名或目录名</p>
</li>
<li>
<p>public String getParent（）：获取File对象父目录的字符串</p>
</li>
<li>
<p>public File getParentFile（）：获取File对象父目录的File对象</p>
</li>
<li>
<p>public String getPath（）：将定义File对象时的路径返回</p>
</li>
<li>
<p>public long getTotalSpace（）：获取File对象表示的文件所在的磁盘分区的总容量（单位：Byte）</p>
</li>
<li>
<p>public long getFreeSpace（）：获取File对象表示的文件所在的磁盘分区的剩余容量（单位：Byte）</p>
</li>
<li>
<p>public boolean isAbsolute（）：判断File对象的路径名是否为绝对路径</p>
</li>
<li>
<p>public boolean isDirectory（）：判断File对象所表示的文件是否为目录</p>
</li>
<li>
<p>public boolean isFile（）：判断File对象所表示的文件是否为文件</p>
</li>
<li>
<p>public boolean isHidden（）：判断File对象所表示的文件是否为隐藏文件</p>
</li>
<li>
<p>public long lastModified（）：获取File对象所表示的文件最后一次修改时间</p>
</li>
<li>
<p>public long length（）：获取File对象多表示的文件的大小（单位：Byte）</p>
</li>
<li>
<p>public String[ ] list（）：将File对象表示的目录中所有文件名加入到字符串数组中，如果File对象不表示目录，返回null</p>
</li>
<li>
<p>public String[ ] list（FilenameFilter filter）：将File对象表示的目录中所有文件名满足过滤器规则的加入到字符串数组中，如果File对象不表示目录，返回null</p>
<ul>
<li>
<p>FilenameFilter文件名过滤器</p>
<ul>
<li>
<p>包：java.io.FilenameFilter（函数式接口）</p>
</li>
<li>
<p>方法：public boolean accept（File dir，String name）</p>
</li>
<li>
<pre><code class="language-java">//匿名内部类写法
File file = new File(&quot;E:\\壁纸&quot;);
String [] list = file.list(new FilenameFilter(){
   @Override
    public boolean accept(File dir,String name){
        return name.toLowerCase().endsWith(&quot;.png&quot;);
    }
});
//Lambda表达式写法
File file = new File(&quot;E:\\壁纸&quot;);
String [] list = file.list((File dir,String name) -&gt; {
	return name.toLowerCase().endsWith(&quot;.png&quot;);
});        
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>public File[ ] listFiles（）：将File对象表示的目录中所有文件加入到文件对象数组中，如果File对象不表示目录，返回null</p>
</li>
<li>
<p>pubic File[ ] listFiles（FileFilter filter）：将File对象表示的目录中所有满足过滤器规则的文件加入到文件对象数组中，如果File对象不表示目录，返回null</p>
</li>
<li>
<p>public File[ ] listFiles（FilenameFilter filter）：将File对象表示的目录中所有满足过滤器规则的文件加入到文件对象数组中，如果File对象不表示目录，返回null</p>
</li>
<li>
<p>public static File[ ] listRoots（）：获取所有文件系统根目录，即盘符</p>
<ul>
<li>
<pre><code class="language-java">File[] files = File.listRoots();
for (int i = 0; i &lt; files.length; i++) {
	System.out.println(files[i]);
}
//输出结果
C:\
D:\
E:\
F:\
</code></pre>
</li>
</ul>
</li>
<li>
<p>public boolean mkdir（）：创建File对象对应的目录</p>
</li>
<li>
<p>public boolean mkdirs（）：创建File对象对应的目录，包括任何必须但不存在的父目录</p>
</li>
<li>
<p>public boolean renameTo（File dest）：重命名File对象所表示的文件</p>
</li>
<li>
<p>public Path toPath（）：将File对象转为Path对象（java.nio.file.Path）</p>
</li>
<li>
<p>public String toString（）：将File对象转为字符串</p>
</li>
<li>
<p>public String toURI（）：将File对象转为URI对象</p>
</li>
<li>
<p>public URL toURL（）：将File对象转为URL对象，已弃用，建议使用URI.toURL（）方法</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-递归">2. 递归</h3>
<ul>
<li>
<p>概述：方法定义中调用方法本身的现象</p>
</li>
<li>
<p>注意</p>
<ul>
<li>递归一定要有出口，否则就是死递归</li>
<li>递归次数不能太多，否则栈内存溢出【递归次数(即方法调用次数)×方法栈帧 &gt; 栈大小  <strong><code>导致</code></strong>  栈溢出】</li>
<li>构造方法不能递归使用</li>
</ul>
</li>
<li>
<p>例</p>
<ul>
<li>
<pre><code class="language-java">//递归求阶乘
public static void main(String [] args){
    factorical(5);
}
public static void factorial(int number){
    if(number==1){
        return 1;
    }else{
        return number*factorical(number-1);
    }
}
</code></pre>
</li>
<li>
<pre><code class="language-java">//递归求不死神兔问题(斐波那契数列)1，1，2，3，5，8...
public static void mian(String [] args){
    fib(10);
}
public static int fib(int number){
    if(number==1 || number==2){
        return 1;
    }else{
        return fib(number-1)+fib(number-2);
    }
}
</code></pre>
</li>
<li>
<pre><code class="language-java">//递归查找某路径下所有以指定后缀.mp4结尾的文件
public static void main(String [] args){
    
}
public static void getAllFilePathMp4(File srcFolder){
   	File[] files = srcFolder.listFiles();
    for(File f:files){
        if(f.isDirectory()){
            getAllFilePathMp4(f);
        }else{
            if(f.getName().endsWith(&quot;.mp4&quot;)){
                System.out.println(&quot;Name:&quot;+f.getName()+&quot;[&quot;+&quot;Path:&quot;+f.getAbsolutePath()+&quot;]&quot;);
            }
        }
    }
} 
</code></pre>
</li>
<li>
<pre><code class="language-java">//递归删除指定目录下所有文件
public static void deleteAllFile(File srcFolder){
    File[] files = srcFolder.listFiles();
    if(files.length==0){
        srcFolder.delete();
    }else{
        for(File f:files){
            if(f.isDirectory()){
                deleteAllFile(f);
            }else{
                System.out.println(&quot;Name:&quot;+f.getName()+&quot;\tDeleteState:&quot;+f.delete());
            }
        }
        System.out.println(&quot;Name:&quot;+ srcFolder.getName()+&quot;\tDeleteState:&quot;+srcFolder.delete());
    }
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="3-字节流万能的流">3. 字节流（万能的流）</h3>
<h4 id="31-字节输入流javaioinputstream抽象类">3.1 字节输入流(java.io.InputStream抽象类)</h4>
<ul>
<li>FileInputStream
<ul>
<li>包：java.io.FileInputStream</li>
<li>构造方法
<ul>
<li>public FileInputStream（File file）</li>
<li>public FileInputStream（FileDescriptor fdObj）</li>
<li>public FileInputStream（String name）</li>
</ul>
</li>
<li>常用方法
<ul>
<li>public int available（）</li>
<li>public void close（）：关闭输入流并释放资源</li>
<li>protected void finalize（）</li>
<li>public FileChannel getChannel（）</li>
<li>public FileDescriptor getFD（）</li>
<li>public int read（）</li>
<li>public int read（byte[ ] b）：从输入流中读取b.length字节的数据，返回读入b缓冲区的字节数，如果读取完毕返回-1，（一次读取多个字节数据，提高读写速度）</li>
<li>public int read（byte[ ] b，int off，int len）</li>
<li>public long skip（long n）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="32-字节输出流javaiooutputstream抽象类">3.2 字节输出流(java.io.OutputStream抽象类)</h4>
<ul>
<li>FileOutputStream
<ul>
<li>包：java.io.FileOutputStream</li>
<li>构造方法
<ul>
<li>
<p>public FileOutputStream（File file）</p>
</li>
<li>
<p>public FileOutputStream（File file，boolean append）</p>
</li>
<li>
<p>public FileOutputStream（FileDescriptor fdObj）</p>
</li>
<li>
<p>public FileOutStream（String name）</p>
</li>
<li>
<p>public FileOutputStream（String name，boolean append）</p>
</li>
<li>
<blockquote>
<p>如果文件不存在，会自动创建，但如果目录不存在，不会自动创建，抛异常</p>
</blockquote>
</li>
</ul>
</li>
<li>常用方法：
<ul>
<li>public void close（）：关闭输出流，并释放资源</li>
<li>protected void finalize（）</li>
<li>public FileChannel getChannel（）</li>
<li>public FileDescriptor getFD（）</li>
<li>public void write（byte[ ] b）</li>
<li>public void write（byte[ ] b，int off，int len）</li>
<li>public void write（int b）</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>字符串是utf-8编码，一个汉字三个字节，一个字母一个字节。<br>
字符串是gbk编码时，一个汉字两个字节，一个字母一个字节。</p>
<p>计算机如何判断将三个字节拼成一个汉字？</p>
<p>文件的编码格式，以及单字节的格式</p>
<p>不同系统的换行符识别不同</p>
<ul>
<li>\r（Mac系统）</li>
<li>\n（Linux系统）</li>
<li>\r\n（Windows系统）</li>
</ul>
</blockquote>
<h4 id="33-字节缓冲流提高fileinputstream的读写效率装饰设计模式">3.3 字节缓冲流（提高FileInputStream的读写效率）装饰设计模式</h4>
<ul>
<li>BufferedInputStream
<ul>
<li>包：java.io.BufferedInputStream</li>
<li>构造方法：
<ul>
<li>public BufferedInputStream（InputStream in）</li>
<li>public BufferedInputStream（InputStream in，int size）：可以指定缓冲区byte数组大小</li>
</ul>
</li>
<li>常用方法：
<ul>
<li>public int read（）</li>
<li>public int read（byte[ ] b，int off，int len）：</li>
<li>public void reset（）</li>
<li>public long skip（long n）</li>
</ul>
</li>
</ul>
</li>
<li>BufferedOutputStream
<ul>
<li>包：java.io.BufferedOutputStream</li>
<li>构造方法：
<ul>
<li>public BufferedOutputStream（OutputStream out）</li>
<li>public BufferedOutputStream（OutputStream out，int size）</li>
</ul>
</li>
<li>常用方法：
<ul>
<li>public void flush（）：刷新缓冲输出流</li>
<li>public void write（byte [ ] b，int off，int len）：从指定字节数组写入len个字节</li>
<li>public void write（int b）：将指定字节写入缓冲输出流</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>读写文件效率比较</p>
<pre><code class="language-java">public class Demo5 {
    public static void main(String[] args) throws IOException {
        long startTime = System.currentTimeMillis();
//        methodA(&quot;E:\\视频教程\\java\\day02\\day01\\视频\\1_2020-09-09.mp4&quot;,&quot;F:\\copy1.mp4&quot;);//半个小时，我吐了
//        methodB(&quot;E:\\视频教程\\java\\day02\\day01\\视频\\1_2020-09-09.mp4&quot;,&quot;F:\\copy2.mp4&quot;);//共耗时：5246毫秒
//        methodC(&quot;E:\\视频教程\\java\\day02\\day01\\视频\\1_2020-09-09.mp4&quot;,&quot;F:\\copy3.mp4&quot;);//共耗时：13230毫秒
//        methodD(&quot;E:\\视频教程\\java\\day02\\day01\\视频\\1_2020-09-09.mp4&quot;,&quot;F:\\copy4.mp4&quot;);//共耗时：1389毫秒
        long endTime = System.currentTimeMillis();
        System.out.println(&quot;共耗时：&quot;+ (endTime-startTime) +&quot;毫秒&quot;);
    }
    public static void methodA(String srcFolder,String destFolder) throws IOException {
        FileInputStream fis = new FileInputStream(srcFolder);
        FileOutputStream fos = new FileOutputStream(destFolder);
        int flag = 0;
        while((flag=fis.read())!=-1){
            fos.write(flag);
        }
        fos.close();
        fis.close();
    }
    public static void methodB(String srcFolder,String destFolder) throws IOException {
        FileInputStream fis = new FileInputStream(srcFolder);
        FileOutputStream fos = new FileOutputStream(destFolder);
        int flag = 0;
        byte [] b = new byte[1024];
        while((flag=fis.read(b))!=-1){
            fos.write(b);
        }
        fos.close();
        fis.close();
    }
    public static void methodC(String srcFolder,String destFolder) throws IOException {
        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(srcFolder));
        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destFolder));
        int flag = 0;
        while((flag=bis.read())!=-1){
            bos.write(flag);
        }
        bos.close();
        bis.close();
    }
    public static void methodD(String srcFolder,String destFolder) throws IOException {
        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(srcFolder));
        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destFolder));
        int flag = 0;
        byte [] b = new byte[1024];
        while((flag=bis.read(b))!=-1){
            bos.write(b);
        }
        bos.close();
        bis.close();
    }
}
</code></pre>
</blockquote>
<h3 id="4-字符流为了操作文本数据java提供了字符流将字节流转换为字符流">4. 字符流（为了操作文本数据，Java提供了字符流，将字节流转换为字符流）</h3>
<h4 id="41-字符输入流javaioreader">4.1 字符输入流(java.io.Reader)</h4>
<ul>
<li>InputStreamReader
<ul>
<li>
<p>构造方法</p>
<ul>
<li>public InputStreamReader（InputStream in）：使用默认字符集将字节输入流转为字符输入流</li>
<li>public InputStreamReader（InputStream in，Charset cs）：创建指定字符集将字节输入流转为字符输入流</li>
<li>public InputStreamReader（InputStream in，CharsetDecoder dec）：创建指定字符集解码器输入流</li>
<li>public InputStreamReader（InputStream in，String charsetName）：创建指定字符集输入流</li>
</ul>
</li>
<li>
<p>常用方法</p>
<blockquote>
<p>String(byte [ ] bytes，String charsetName)：通过指定字符集编码字节数组</p>
<p>byte[ ] getBytes(String charsetName)：使用指定字符集编码把字符串编码为字节数组</p>
</blockquote>
<ul>
<li>public void close（）：关闭输入流释放资源</li>
<li>public String getEncoding（）：返回字符集编码名称</li>
<li>public int read（）：读一个字符</li>
<li>public int read（char[ ] cbuf，int offset，int length）：将字符输入流读入数组的一部分</li>
<li>public boolean ready（）：告诉这个流是否准备好被读取</li>
<li>public void mark（int readAheadLimit）：标记流中当前位置</li>
<li>public boolean markSupport（）：告诉这个流是否支持mark操作</li>
<li>public int read（char[ ] cbuf）：将字符输入流读入数组</li>
<li>public int read（CharBuffer target）：将字符输入流读入指定字符缓冲区</li>
<li>public void reset（）：重置流</li>
<li>public long skip（long n）：跳过指定长度字符</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="42-字符输出流javaiowriter">4.2 字符输出流(java.io.Writer)</h4>
<ul>
<li>OutputStreamWriter
<ul>
<li>构造方法：
<ul>
<li>public OutputStreamWriter（OutputStream out）：使用默认字符集将字节输出流转为字符输出流</li>
<li>public outputStreamWriter（OutputStream out，Charset cs）：使用指定字符集解码将字节输出流转为字符输出流</li>
<li>public OutputStreamWriter（OutputStream out，CharsetEncoder enc）：创建指定字符集解码的字符输出流</li>
<li>public OutputStreamWriter（OutputStream out，Stirng charsetName）：创建指定名字编码解码的字符输出流</li>
</ul>
</li>
<li>常用方法：
<ul>
<li>public void close（）：关闭流，释放资源（会先刷新流，即调用flush（）方法）</li>
<li>public void flush（）：刷新流</li>
<li>public String getEncoding（）：返回该字符输出流的编码格式</li>
<li>public void write（char[ ] cbuf，int off，int len）：写入字符数组的一部分</li>
<li>public void write（int c）：写入一个字符</li>
<li>public void write（String str，int off，int len）：写入一个字符串的一部分</li>
<li>public Writer append（char c）：追加指定字符</li>
<li>public Writer append（CharSequence csq）：追加指定字符序列</li>
<li>public Writer append（CharSequence csq，int start，int end）：追加指定字符序列子序列</li>
<li>public abstract void close（）：关闭流</li>
<li>public abstract void flush（）：刷新流</li>
<li>public void write（char[ ] cbuf）：写入一个字符数组</li>
<li>public void write（String str）：写入字符串</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="43-转换流简化写法">4.3 转换流简化写法</h4>
<ul>
<li>FileWriter = FileOutputStream + 字符编码</li>
<li>FileReader = FileInputStream + 字符编码</li>
</ul>
<h4 id="44-字符缓冲流">4.4 字符缓冲流</h4>
<ul>
<li>BufferedReader</li>
<li>BufferedWriter</li>
</ul>
<p><strong><code>复制文本文件</code></strong></p>
<p>复制图片</p>
<p>把ArrayList中的字符串数据存储到文本文件</p>
<p>从文本文件读取一行数据保存到集合中，并遍历</p>
<p>复制单级文件夹</p>
<p>复制多级文件夹</p>
<p>键盘输入几个学生信息，按照年龄排序，存入文本文件</p>
<p>加入a.txt文件中一串字符串“asdlfjsdaldjasf”</p>
<p>请编写代码实现读取内容，然后排序后写入b.txt</p>
<p>登录注册io版</p>
<h3 id="5-打印流只有写数据的没有读数据的">5. 打印流（只有写数据的没有读数据的）</h3>
<h4 id="51-字节打印流javaioprintstream">5.1 字节打印流（java.io.PrintStream）</h4>
<h4 id="52-字符打印流javaioprintwriter">5.2 字符打印流（java.io.PrintWriter）</h4>
<h4 id="53-特点">5.3 特点：</h4>
<ul>
<li>
<p>只有写数据没有读取数据</p>
</li>
<li>
<p>可以操作任意类型的数据</p>
</li>
<li>
<p>如果启动了自动刷新，无需手动刷新</p>
<ul>
<li>
<pre><code class="language-java">PrintWriter pw = new PrintWriter(new FileWriter(&quot;E:\\a.txt&quot;),true)
</code></pre>
</li>
</ul>
</li>
<li>
<p>可以直接操作文本文件</p>
</li>
</ul>
<h3 id="6-序列化流">6. 序列化流</h3>
<blockquote>
<p>序列化是指把一个Java对象变成二进制内容，本质上就是一个byte[]数组。</p>
<p>为什么要把Java对象序列化呢？</p>
<p>因为序列化后可以把byte[]保存到文件中，或者把byte[]通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。 有序列化，就有反序列化，即把一个二进制内容（也就是byte[]数组）变回Java对象。有了反序列化，保存到文件中的byte[]数组又可以“变回”Java对象，或者从网络上读取byte[]并把它“变回”Java对象</p>
</blockquote>
<h4 id="61-objectoutputstream序列化">6.1 ObjectOutputStream（序列化）</h4>
<ul>
<li>
<p>父类：OutputStream</p>
</li>
<li>
<p>包：java.io.ObjectOutputStream</p>
</li>
<li>
<p>构造方法：</p>
<ul>
<li>public ObjectOutputStream（OutputStream out）</li>
</ul>
</li>
<li>
<p>常用方法：</p>
<ul>
<li>public void writeObject（Object obj）：写出对象</li>
</ul>
<pre><code class="language-java">//类的序列化由实现java.io.Serializable接口的类启用。 不实现此接口的类将不会使任何状态序列化或反序列化。 可序列化类的所有子类型都是可序列化的。 序列化接口没有方法或字段，仅用于标识可串行化的语义。 
</code></pre>
<ul>
<li>public void close（）：关闭输出流</li>
</ul>
</li>
</ul>
<h4 id="62-objectinputstream反序列化">6.2 ObjectInputStream（反序列化）</h4>
<ul>
<li>
<p>父类：InputStream</p>
</li>
<li>
<p>包：java.io.ObjectInputStream</p>
</li>
<li>
<p>构造方法：</p>
<ul>
<li>public ObjectInputStream（InputStream in）</li>
</ul>
</li>
<li>
<p>常用方法：</p>
<ul>
<li>public Object readObject（）：从ObjectOutputStream中读取对象</li>
<li>public void close（）：关闭输入流</li>
</ul>
</li>
<li>
<p>例</p>
</li>
</ul>
<pre><code class="language-java">package com.demo.javase;

import java.io.Serializable;
/**
 * @author 絷缘
 * @version 1.0
 * @date 2020/12/9 8:56
 **/
public class Student implements Serializable {
    private String name;
    private int age;
    public Student(){}
    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;Student{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                '}';
    }
}
</code></pre>
<pre><code class="language-java">public static void main(String[] args) throws IOException, ClassNotFoundException {
	ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;F:\\b.txt&quot;));
    oos.writeObject(new Student(&quot;zhiyuan&quot;,22));
    oos.close();
    ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;F:\\b.txt&quot;));
    Object o = ois.readObject();
    if(o instanceof Student){
		System.out.println(o);
	}        
}
</code></pre>
<blockquote>
<p>java.io.InvalidClassException：</p>
<pre><code class="language-java">Exception in thread &quot;main&quot; java.io.InvalidClassException: com.demo.javase.Student; 
local class incompatible: stream classdesc serialVersionUID = -2157397684930231136, 
local class serialVersionUID = 1206998284855657234
</code></pre>
<ul>
<li>
<p>若在序列化对象时，类未被修改，序列化后，手动修改了类文件，那么进行反序列化时会有异常</p>
<ul>
<li>可序列化的类的版本号serialVersionUID不同，抛出InvalidClassException</li>
</ul>
</li>
<li>
<p>若在序列化对象时，类没有无参构造方法，序列化后，进行反序列化时会有异常</p>
</li>
<li>
<p>若在序列化对象时，类中有未知的数据类型，序列恶化后，进行反序列化时会有异常</p>
</li>
</ul>
<h3 id="serialversionuid和transient">serialVersionUID和transient</h3>
<ul>
<li>serialVersionUID（Serializable的底层比较方式）
<ul>
<li>官方手册：强烈建议声明可序列化类的版本号</li>
<li><strong><code>private static final long serialVersionUID = 25L;</code></strong></li>
</ul>
</li>
</ul>
<p>声明此版本号后，手动修改类文件后，反序列化未发生错误</p>
<ul>
<li>transient（类中成员不想被序列化和反序列化）
<ul>
<li>被transient修饰的成员，不参与序列化与反序列化，被反序列化后依据成员本身类型给默认值</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="7-特殊操作流">7. 特殊操作流</h3>
<h4 id="71-properties">7.1 Properties</h4>
<ul>
<li>
<p>父类：java.util.Hashtable&lt;Object，Object&gt;</p>
</li>
<li>
<p>包：java.util.Properties</p>
</li>
<li>
<p>Properties是一个Map体系的集合类，可以直接保存到流中或从流中加载</p>
</li>
<li>
<p>构造方法：</p>
<ul>
<li>public Properties（）</li>
<li>public Properties（Properties defaults）</li>
</ul>
</li>
<li>
<p>常用方法：</p>
<ul>
<li>public String getProperty（String key）：根据指定key，获取value</li>
<li>public String getProperty（String key，String defaultValue）</li>
<li>public void list（PrintStream out）：把属性列表打印到指定输出流</li>
<li>public void list（PrintWriter out）：把属性列表打印到输出流</li>
<li>public void load（InputStream in）：从输入字节流读取属性列表</li>
<li>public void load（Reader reader）：</li>
<li>public void loadFromXML（InputStream in）：从指定XML文件输入流中读取所有属性加入properties中</li>
<li>public Enumeration&lt;?&gt; propertiesNames（）：返回属性表的所有key的枚举</li>
<li>public Object setProperty（String key，String value）：调用HashTable的put（）方法，向属性集合中加入数据</li>
<li>public void store（OutputStream out，String comments）</li>
<li>public void store（Writer writer，String comments）</li>
<li>public void storeToXML（OutputStream os，String comment）</li>
<li>public void storeToXML（OutputStream os，Stirng comment，Stirng encoding）</li>
<li>public Set<String> stringPropertyNames（）：键的集合</li>
</ul>
<pre><code class="language-java">public static void main(String[] args) throws IOException {
        Properties pt = new Properties();
        pt.setProperty(&quot;username&quot;,&quot;root&quot;);
        pt.setProperty(&quot;password&quot;,&quot;123456&quot;);
        Set&lt;String&gt; keys = pt.stringPropertyNames();
        Iterator&lt;String&gt; it = keys.iterator();
        for(;it.hasNext();){
            System.out.println(it.next());
        }
        pt.store(new BufferedWriter(new FileWriter(&quot;F:\\c.txt&quot;)),null);
        Properties pt2 = new Properties();
        pt2.load(new BufferedReader(new FileReader(&quot;F:\\c.txt&quot;)));
        for (String key:pt2.stringPropertyNames()) {
            System.out.println(key+&quot;=&quot;+pt2.getProperty(key));
        }
    }
</code></pre>
</li>
</ul>
<h2 id="78-多线程">78. 多线程</h2>
<h3 id="1-进程系统资源分配的最小单位">1. 进程：系统资源分配的最小单位</h3>
<h3 id="2-线程是进程的执行单元是cpu调度的最小单位">2. 线程：是进程的执行单元，是CPU调度的最小单位</h3>
<ul>
<li>单线程</li>
<li>多线程</li>
</ul>
<h3 id="3-多线程实现方式">3. 多线程实现方式</h3>
<h4 id="31-继承thread类javalangthread">3.1 继承Thread类（java.lang.Thread）</h4>
<ul>
<li>继承Thread类并重写run方法，使用start方法启动线程</li>
</ul>
<pre><code class="language-java">public static void main(String[] args) {
        MyThread mt1 = new MyThread();
        MyThread mt2 = new MyThread();
        mt1.start();
        mt2.start();
    }

public class MyThread extends Thread{
    @Override
    public void run() {
        for (int i = 0; i &lt; 1000; i++) {
            System.out.print(i+&quot;\t&quot;);
        }
    }
}
</code></pre>
<ul>
<li>设置和获取线程名称</li>
</ul>
<pre><code class="language-java">//第一种，使用setName设置线程名称
public static void main(String[] args) {
        MyThread mt1 = new MyThread();
        MyThread mt2 = new MyThread();
        mt1.setName(&quot;线程A&quot;);
        mt2.setName(&quot;线程B&quot;);
        mt1.start();
        mt2.start();
    }

public class MyThread extends Thread{
    @Override
    public void run() {
        for (int i = 0; i &lt; 1000; i++) {
            System.out.print(getName()+&quot;:&quot;+i+&quot;\t&quot;);
        }
    }
}
//第二种，使用父类带参构造设置线程名称
public static void main(String[] args) {
        MyThread mt1 = new MyThread(&quot;线程A&quot;);
        MyThread mt2 = new MyThread(&quot;线程B&quot;);
        mt1.start();
        mt2.start();
    }

public class MyThread extends Thread{
    @Override
    public void run() {
        for (int i = 0; i &lt; 1000; i++) {
            System.out.print(getName()+&quot;:&quot;+i+&quot;\t&quot;);
        }
    }
    public MyThread(String name){
        super(name);
    }
}
</code></pre>
<ul>
<li>获取启动线程的线程名</li>
</ul>
<pre><code class="language-java">String name = Thread.currentThread().getName();
System.out.println(name);
</code></pre>
<ul>
<li>
<p>线程调度</p>
<ul>
<li>分时调度模型</li>
<li>抢占式调度模型</li>
</ul>
</li>
</ul>
<pre><code class="language-java">  public final int getPriority()：返回此线程的优先级
  public final void setPriority()：更改线程优先级    
  Thread.MAX_PRIORITY=10
  Thread.MIN_PRIORITY=1
  Thread.NORM_PRIORITY=5    
</code></pre>
<pre><code class="language-java">      public static void main(String[] args) {
          ThreadPriority tp1 = new ThreadPriority(&quot;线程A&quot;);
          ThreadPriority tp2 = new ThreadPriority(&quot;线程B&quot;);
          tp1.setPriority(5);
          tp2.setPriority(6);
          tp1.start();
          tp2.start();
      }
  
  public class ThreadPriority extends Thread{
      @Override
      public void run() {
          for (int i = 0; i &lt; 100; i++) {
              System.out.println(getName()+&quot;:&quot;+i);
          }
      }
      public ThreadPriority(String name){
          super(name);
      }
  }
</code></pre>
<ul>
<li>
<p>线程控制</p>
<ul>
<li>public static sleep(long millis)：使当前正在执行的线程停留指定毫秒数</li>
<li>public void join()：等待这个线程死亡</li>
<li>public void setDaemon(boolean on)：将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出</li>
<li>public static void yield()：使当前占用资源的线程主动让出资源</li>
</ul>
</li>
</ul>
<pre><code class="language-java">//sleep()
public static void main(String[] args) {
        ThreadSleep ts1 = new ThreadSleep();
        ThreadSleep ts2 = new ThreadSleep();
        ts1.start();
        ts2.start();
    }

public class ThreadSleep extends Thread{
    @Override
    public void run() {
        for (int i = 0; i &lt; 100; i++) {
            System.out.println(i);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
//join()
public static void main(String[] args) {
        ThreadJoin tj1 = new ThreadJoin(&quot;A&quot;);
        ThreadJoin tj2 = new ThreadJoin(&quot;B&quot;);
        tj1.start();
        try {
            tj1.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        tj2.start();
    }

public class ThreadJoin extends Thread {
    @Override
    public void run() {
        for (int i = 0; i &lt; 1000; i++) {
            System.out.print(getName()+&quot;:&quot;+i+&quot;\t&quot;);
        }
    }
    public ThreadJoin(String name){
        super(name);
    }
}
//setDaemon()
public static void main(String[] args) {
        ThreadDaemon td1 = new ThreadDaemon(&quot;A&quot;);
        ThreadDaemon td2 = new ThreadDaemon(&quot;B&quot;);

        Thread.currentThread().setName(&quot;C&quot;);
        td1.setDaemon(true);
        td2.setDaemon(true);
        td1.start();
        td2.start();
        for (int i = 0; i &lt; 100; i++) {
            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);
        }
    }

public class ThreadDaemon extends Thread{
    @Override
    public void run() {
        for (int i = 0; i &lt; 100; i++) {
            System.out.println(getName()+&quot;:&quot;+i);
        }
    }
    public ThreadDaemon(String name){
        super(name);
    }
}
</code></pre>
<ul>
<li>线程生命周期
<ul>
<li>创建线程对象</li>
<li>线程就绪等待分配资源</li>
<li>分配到资源开始运行</li>
<li>线程结束</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="24"><img src="http://pic.zyblog.xyz/img/typora/20201209223414.png" alt="image-20201209223406529" loading="lazy"></figure>
<h4 id="32-实现runnable接口javalangrunnable">3.2 实现Runnable接口（java.lang.Runnable）</h4>
<ul>
<li>定义一个类实现Runnable接口</li>
<li>重写run方法</li>
<li>创建该类对象，并将对象作为参数构造Thread对象</li>
<li>启动线程</li>
</ul>
<pre><code class="language-java">public class RunnableDemo1 implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i &lt; 100; i++) {
            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);
        }
    }
    public RunnableDemo1(String s){
        Thread.currentThread().setName(s);
    }
}
public class Demo6 {
    public static void main(String[] args) {
        Thread t1 = new Thread(new RunnableDemo1());
        Thread t2 = new Thread(new RunnableDemo1());
        Thread t3 = new Thread(new RunnableDemo1(), &quot;线程C&quot;);
        t1.start();
        t2.start();
        t3.start();
    }
}
</code></pre>
<blockquote>
<p>推荐使用实现Runnable接口的方式实现多线程</p>
<p>原因：</p>
<ul>
<li>Java中只能单继承，所以放我们继承Thread类实现多线程后，想要继续继承其他类就不可能了</li>
<li>实现Runnable接口的多继承可以实现资源共享</li>
</ul>
</blockquote>
<h4 id="33-实现callable接口javautilconcurrentcallable">3.3 实现Callable接口（java.util.concurrent.Callable）</h4>
<ul>
<li>定义一个类实现Callable接口</li>
<li>重写call方法</li>
<li>创建该类对象，启动线程</li>
</ul>
<pre><code class="language-java">public class MyCallableDemo implements Callable {
    @Override
    public Object call() throws Exception {
        for (int i = 0; i &lt; 100; i++) {
            System.out.println(Thread.currentThread().getName()+&quot;-&quot;+i);
        }
        return null;
    }
}

public class Demo7 {
    public static void main(String[] args) {
        MyCallableDemo myCallableDemo = new MyCallableDemo();
        ExecutorService service = Executors.newFixedThreadPool(5);
        service.submit(myCallableDemo);

    }
}
</code></pre>
<h4 id="34-匿名内部类实现多线程">3.4 匿名内部类实现多线程</h4>
<pre><code class="language-java">    public void ThreadDemo(){
        Thread t1 = new Thread(){
            @Override
            public void run() {
                for (int i = 0; i &lt; 100; i++) {
                    System.out.println(Thread.currentThread().getName()+&quot;-&quot;+i);
                }
            }
        };
        t1.start();
    }
    public void RunnableDemo(){
        Runnable r1 = new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i &lt; 100; i++) {
                    System.out.println(Thread.currentThread().getName()+&quot;-&quot;+i);
                }
            }
        };
        new Thread(r1,&quot;线程A&quot;).start();
        new Thread(r1,&quot;线程B&quot;).start();
    }

</code></pre>
<h3 id="4-线程同步">4. 线程同步</h3>
<pre><code class="language-java">//卖票问题
public class SellTicket implements Runnable {
    private int tickets = 100;

    @Override
    public void run() {
        while(true){
            if (tickets &gt; 0) {
                System.out.println(Thread.currentThread().getName()+&quot;正在出售第&quot;+tickets+&quot;票&quot;);
                tickets--;
            }else{
                break;
            }
        }
    }
}

public class SellTicketDemo {
    public static void main(String[] args) {
        SellTicket st = new SellTicket();
        Thread t1 = new Thread(st, &quot;窗口1&quot;);
        Thread t2 = new Thread(st, &quot;窗口2&quot;);
        Thread t3 = new Thread(st, &quot;窗口3&quot;);
        t1.start();
        t2.start();
        t3.start();
    }
}
</code></pre>
<h4 id="41-出现了问题多线程数据安全问题">4.1 出现了问题（多线程数据安全问题）</h4>
<ul>
<li>相同的票出现了多次
<ul>
<li>资源被其他线程抢占，其他线程资源又被其他线程抢占</li>
</ul>
</li>
<li>出现了负数票数
<ul>
<li>当某个线程抢到CPU执行权，而且正在出售第1张票，票数减一变为0，而此时其他线程抢到了执行权，票数减一变为-1</li>
</ul>
</li>
</ul>
<h4 id="42-解决办法">4.2 解决办法</h4>
<ul>
<li>同步代码块：锁定多条语句操作共享数据的代码
<ul>
<li>优点：解决了多线程的数据安全问题</li>
<li>缺点：当线程较多的时候，每个线程都回去判断同步上的锁，耗费资源，降低运行效率</li>
</ul>
</li>
</ul>
<pre><code class="language-java">synchronized(任意对象){
    多条语句操作共享数据的代码
}
synchronized(任意对象)：相当于给代码加锁了，任意对象就可以看成是一把锁
</code></pre>
<pre><code class="language-java">public class SellTicket implements Runnable {
    private int tickets = 100;
    private Object object = new Object();

    @Override
    public void run() {
        while(true){
            synchronized(object){
                if (tickets &gt; 0) {
                    System.out.println(Thread.currentThread().getName()+&quot;正在出售第&quot;+tickets+&quot;票&quot;);
                    tickets--;
                }else{
                    break;
                }
            }
        }
    }
}

public class SellTicketDemo {
    public static void main(String[] args) {
        SellTicket st = new SellTicket();
        Thread t1 = new Thread(st, &quot;窗口1&quot;);
        Thread t2 = new Thread(st, &quot;窗口2&quot;);
        Thread t3 = new Thread(st, &quot;窗口3&quot;);
        t1.start();
        t2.start();
        t3.start();
    }
}

</code></pre>
<ul>
<li>同步方法：把<code>synchronized</code>关键字加到方法上
<ul>
<li>同步方法的锁对象：this</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class SellTicket implements Runnable {
    private int tickets = 100;
    private Object object = new Object();
    private int i = 0;

    @Override
    public void run() {
        while(true){
            if(i%2==0){
                synchronized(this){
                    if (tickets &gt; 0) {
                        System.out.println(Thread.currentThread().getName()+&quot;正在出售第&quot;+tickets+&quot;票&quot;);
                        tickets--;
                    }else{
                        break;
                    }
                }
                i++;
            }else{
                sellTicket();
            }

        }
    }

    public synchronized void sellTicket(){
        if (tickets &gt; 0) {
            System.out.println(Thread.currentThread().getName()+&quot;正在出售第&quot;+tickets+&quot;票&quot;);
            tickets--;
        }
    }
}

public class SellTicketDemo {
    public static void main(String[] args) {
        SellTicket st = new SellTicket();
        Thread t1 = new Thread(st, &quot;窗口1&quot;);
        Thread t2 = new Thread(st, &quot;窗口2&quot;);
        Thread t3 = new Thread(st, &quot;窗口3&quot;);
        t1.start();
        t2.start();
        t3.start();
    }
}
</code></pre>
<ul>
<li>同步静态方法：在static后加上synchronized关键字
<ul>
<li>同步静态方法的锁对象：类名.class（反射）</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class SellTicket implements Runnable {
    private static int tickets = 100;
    private Object object = new Object();
    private int i = 0;

    @Override
    public void run() {
        while(true){
            if(i%2==0){
                synchronized(SellTicket.class){
                    if (tickets &gt; 0) {
                        System.out.println(Thread.currentThread().getName()+&quot;正在出售第&quot;+tickets+&quot;票&quot;);
                        tickets--;
                    }else{
                        break;
                    }
                }
                i++;
            }else{
                sellTicket();
            }

        }
    }

    public static synchronized void sellTicket(){
        if (tickets &gt; 0) {
            System.out.println(Thread.currentThread().getName()+&quot;正在出售第&quot;+tickets+&quot;票&quot;);
            tickets--;
        }
    }
}

public class SellTicketDemo {
    public static void main(String[] args) {
        SellTicket st = new SellTicket();
        Thread t1 = new Thread(st, &quot;窗口1&quot;);
        Thread t2 = new Thread(st, &quot;窗口2&quot;);
        Thread t3 = new Thread(st, &quot;窗口3&quot;);
        t1.start();
        t2.start();
        t3.start();
    }
}
</code></pre>
<h3 id="5-线程安全的类">5. 线程安全的类</h3>
<h4 id="51-stringbuffer在多线程中会被使用到">5.1 StringBuffer(在多线程中会被使用到)</h4>
<h4 id="52-vector不常被使用">5.2 Vector（不常被使用）</h4>
<h4 id="53-hashtable不常被使用">5.3 Hashtable（不常被使用）</h4>
<blockquote>
<p>常使用Collections.synchronizedList（new ArrayList<String>()）将线程不安全的集合类变成线程安全的集合类</p>
</blockquote>
<h3 id="6-锁lockjdk15">6. 锁Lock（JDK1.5）</h3>
<ul>
<li>
<p>Lock实现同步比使用synchronized方法和语句可以获得更广泛的锁定操作</p>
</li>
<li>
<p>常用方法：</p>
<ul>
<li>public void lock（）：获得锁</li>
<li>public void unlock（）：释放锁</li>
</ul>
</li>
<li>
<p>实现类：ReentrantLock</p>
<ul>
<li>构造方法：
<ul>
<li>public ReentrantLock（）</li>
</ul>
</li>
<li>实现</li>
</ul>
<pre><code class="language-java">public class SellTicket implements Runnable {
    private static int tickets = 100;
    private Object object = new Object();
    private int i = 0;
    private Lock lock = new ReentrantLock();

    @Override
    public void run() {
        while (true) {
            try{
                lock.lock();
                if (tickets &gt; 0) {
                    System.out.println(Thread.currentThread().getName() + &quot;正在出售第&quot; + tickets + &quot;票&quot;);
                    tickets--;
                } else {
                    break;
                }
            }finally{
                lock.unlock();
            }
        }
    }
}

public class SellTicketDemo {
    public static void main(String[] args) {
        SellTicket st = new SellTicket();
        Thread t1 = new Thread(st, &quot;窗口1&quot;);
        Thread t2 = new Thread(st, &quot;窗口2&quot;);
        Thread t3 = new Thread(st, &quot;窗口3&quot;);
        t1.start();
        t2.start();
        t3.start();
    }
}
</code></pre>
</li>
</ul>
<h3 id="7-死锁问题">7. 死锁问题</h3>
<figure data-type="image" tabindex="25"><img src="http://pic.zyblog.xyz/img/typora/20201216100635.png" alt="image-20201216100627936" loading="lazy"></figure>
<h4 id="71-同步弊端">7.1 同步弊端</h4>
<ul>
<li>效率低</li>
<li>如果出现了同步嵌套，容易出现死锁</li>
</ul>
<h4 id="72-死锁的产生">7.2 死锁的产生</h4>
<ul>
<li>
<p>概述：死锁或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于<em>死锁</em>状态或系统产生了<em>死锁</em>，这些永远在互相等待的进程称为<em>死锁</em>进程。</p>
</li>
<li>
<p>产生：我们在解决多线程共享资源的线程同步问题时，会使用synchronized关键字修饰方法或者通过Lock加锁方式修饰方法、代码块，防止多个线程访问统一资源产生的线程安全问题。但是当线程X持有锁A，等待锁B，而线程Y此时持有锁B，等待锁A时，就会出现X，Y两个线程互相等待的情况，这种情况就是死锁。</p>
</li>
<li>
<p>产生条件</p>
<ul>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>保持和请求条件：一个进程因请求资源而阻塞时，对已获得资源保持不放。</li>
<li>不可剥夺条件：进程已获得资源，在未使用完成前，不能被剥夺。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
</li>
</ul>
<h4 id="73-死锁的解决">7.3 死锁的解决</h4>
<ul>
<li>只要破坏其中任意一个条件，就可以避免死锁，其中最简单的就是破环循环等待条件。按同一顺序访问对象，加载锁，释放锁。</li>
</ul>
<h3 id="8-线程间的通信等待唤醒机制">8. 线程间的通信（等待唤醒机制）</h3>
<h4 id="81-概述">8.1 概述</h4>
<ul>
<li>多个线程在处理同一个资源，但是处理的任务不相同</li>
</ul>
<h4 id="82-等待唤醒机制">8.2 等待唤醒机制</h4>
<ul>
<li>
<p>多个线程间的⼀种协作机制。谈到线程我们经常想到的是线程间的竞争( race )，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司你你和你的同事，你们可能存在在晋升时的竞争，但更多时候你们更多是⼀起合作以完成某些任务。</p>
<p>就是在⼀个线程进行了规定操作后，就进⼊等待状态( wait（）)，等待其他线程执行完他们的指定代码过后再将其唤醒( notify（） )；在有多个线程进⾏等待时，如果需要，可以使⽤ notifyAll（）来唤醒所有的等待线程。</p>
<p>wait/notify 就是线程间的⼀种协作机制。</p>
</li>
<li>
<p>常用方法：</p>
<ul>
<li>wait（）：线程不再活动，不再参与调度，进入wait set中，因此不会浪费CPU资源，也不会去竞争锁，此时线程状态为WAITING，等待其他线程完成指定任务，使用notify通知当前线程从wait set中释放出来，重新进入调度队列</li>
<li>notify（）：通知处在wait set中的线程释放进入调度队列</li>
<li>notifyAll（）：通知所有处在wait set中的线程释放进入调度队列</li>
</ul>
<blockquote>
<p>注意：<br>
哪怕只通知了⼀个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，<br>
所以它需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调⽤ wait 方法之后的地方恢复执行。<br>
总结如下：</p>
<ul>
<li>如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态；</li>
<li>否则，从 wait set 出来，又进⼊ entry set，线程就从WAITING状态⼜变成BLOCKED 状态。</li>
</ul>
</blockquote>
</li>
<li>
<p>注意事项</p>
<ul>
<li>wait方法与notify方法必须要由同⼀个锁对象调用。因为：对应的锁对象可以通过notify唤<br>
醒使用同⼀个锁对象调用的wait方法后的线程。</li>
<li>wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对<br>
象的所属类都是继承了Object类的。</li>
<li>wait方法与notify方法必须要在同步代码块或者是同步函数中使⽤。因为：必须要通过锁对<br>
象调用这2个方法。</li>
</ul>
</li>
</ul>
<h4 id="83-生产者消费者问题">8.3 生产者消费者问题</h4>
<figure data-type="image" tabindex="26"><img src="http://pic.zyblog.xyz/img/typora/20201216110343.png" alt="image-20201216110342885" loading="lazy"></figure>
<figure data-type="image" tabindex="27"><img src="http://pic.zyblog.xyz/img/typora/20201216110904.png" alt="image-20201216110904509" loading="lazy"></figure>
<ul>
<li>代码实现</li>
</ul>
<pre><code class="language-java">public class BaoZi {
    private String pi;
    private String xian;
    private boolean flag = false;

    public String getPi() {
        return pi;
    }

    public String getXian() {
        return xian;
    }

    public boolean isFlag() {
        return flag;
    }

    public void setPi(String pi) {
        this.pi = pi;
    }

    public void setXian(String xian) {
        this.xian = xian;
    }

    public void setFlag(boolean flag) {
        this.flag = flag;
    }
}

public class BaoZiPu implements Runnable{
    private BaoZi bz;

    public BaoZiPu(BaoZi bz) {
        this.bz = bz;
    }

    @Override
    public void run() {
        int count = 0;
        while(true){
            synchronized (bz){
                if(bz.isFlag()){
                    try {
                        bz.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }else{
                    if(count%2==0){
                        bz.setPi(&quot;薄皮&quot;);
                        bz.setXian(&quot;猪肉大葱&quot;);
                    }else{
                        bz.setPi(&quot;冰皮&quot;);
                        bz.setXian(&quot;韭菜鸡蛋&quot;);
                    }
                    count++;
                    System.out.println(&quot;包子铺正在做：&quot;+bz.getPi()+bz.getXian()+&quot;包子&quot;);
                    try {
                        Thread.sleep(300);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    bz.setFlag(true);
                    bz.notify();
                    System.out.println(&quot;包子已经做好了：&quot;+bz.getPi()+bz.getXian()+&quot;包子，大家可以来买了&quot;);
                }
            }
        }

    }
}

public class ChiHuo implements Runnable{
    private BaoZi bz;

    public ChiHuo(BaoZi bz) {
        this.bz = bz;
    }

    @Override
    public void run() {
        while(true){
            synchronized (bz){
                if(!bz.isFlag()){
                    try {
                        bz.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }else{
                    System.out.println(&quot;吃货正在吃：&quot;+bz.getPi()+bz.getXian()+&quot;的包子&quot;);
                    try {
                        Thread.sleep(300);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    bz.setFlag(false);
                    bz.notify();
                    System.out.println(&quot;吃货已经把：&quot;+bz.getPi()+bz.getXian()+&quot;的包子吃完了&quot;);
                    System.out.println(&quot;===================================================&quot;);
                }
            }
        }
    }
}

public class Demo {
    public static void main(String[] args) {
        BaoZi bz = new BaoZi();
        new Thread(new BaoZiPu(bz)).start();
        new Thread(new ChiHuo(bz)).start();
    }
}
</code></pre>
<h3 id="9-线程池">9. 线程池</h3>
<ul>
<li>概述：我们使用线程时如果并发的线程数量很多，并且每个线程都是执行一个很短的任务就结束了，这样频繁地创建线程就会大大降低系统的效率</li>
<li>线程池：就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，以避免消耗过多的资源</li>
<li>原理：集合容器，队列思想
<ul>
<li><img src="http://pic.zyblog.xyz/img/typora/20201216114458.png" alt="image-20201216114457792" loading="lazy"></li>
<li><img src="http://pic.zyblog.xyz/img/typora/20201216114530.png" alt="image-20201216114530635" loading="lazy"></li>
</ul>
</li>
<li>代码实现：
<ul>
<li>包：<code>java.util.concurrent.Executors</code>：线程池的工厂类，用来生成线程池</li>
<li>静态方法：
<ul>
<li><code>public static ExecutorService newFixedThreadPool（int nThreads）</code>：创建一个可重用的线程数的线程池
<ul>
<li>参数：<code>int nThread</code>（创建线程池中包含的线程数量）</li>
<li>返回值：<code>ExecutorService</code>接口，返回ExecutorService接口的实现类对象
<ul>
<li><code>java.util.concurrent.ExecutorService</code>：线程池接口
<ul>
<li><code>submit（Runnable task）</code>：提交一个Runnable任务用于执行</li>
<li><code>void shutdown（） </code>：关闭销毁线程池的方法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>线程池使用步骤
<ol>
<li>使用线程池的工厂类Executors里提供的静态方法newFixedThreadPool生成一个指定数量的线程池</li>
<li>创建一个类，实现Runnable接口，重写run方法，设置线程任务</li>
<li>调用ExecutorService中的静态方法submit，传递线程任务（实现类），开启线程，执行run方法</li>
<li>调用ExecutorService中的方法shutdown销毁线程池（不建议执行）</li>
</ol>
</li>
</ul>
<pre><code class="language-java">public class ThreadPoolDemo{
    public static void main(String [] args){
        //1.使用线程池的工厂类Executors里提供的静态方法newFixedThreadPool生成一个指定数量的线程池
        ExecutorService es = Executors.newFixedThreadPool(2);
        //2.创建一个类，实现Runnable接口，重写run方法，设置线程任务
        //3.调用ExecutorService中的静态方法submit，传递线程任务（实现类），开启线程，执行run方法
        es.submit(new MyThread()));
        es.submit(new MyThread()));
        es.submit(new MyThread()));
        es.shutdown();
        es.submit(new MyThread()));//抛异常，线程池已经被销毁了，不能再获取线程了
    }
}
public class MyThread implements Runnable{
    @Override
    public void run(){
        System.out.println(Thread.currentThread().getName()+&quot;创建了一个新线程&quot;);
    }
}
</code></pre>
<h3 id="10-线程组">10. 线程组</h3>
<figure data-type="image" tabindex="30"><img src="http://pic.zyblog.xyz/img/typora/20201216121657.jpeg" alt="img" loading="lazy"></figure>
<ul>
<li>可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式</li>
<li>线程组的作用是：可以批量管理线程或线程组对象，有效地对线程或线程组对象进行组织</li>
<li>包：java.lang.ThreadGroup</li>
<li>构造方法
<ul>
<li>ThreadGroup（String name）</li>
<li>ThreadGroup（ThreadGroup parent，String name）</li>
</ul>
</li>
<li>代码实现</li>
</ul>
<pre><code class="language-java">public class MyThread implements Runnable{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }
}
public class ThreadGroupDemo {
    public static void main(String[] args) {
        ThreadGroup g1 = new ThreadGroup(&quot;线程组1&quot;);
        Thread t1 = new Thread(g1, new MyThread(), &quot;a&quot;);
        Thread t2 = new Thread(g1, new MyThread(), &quot;b&quot;);
        System.out.println(t1.getThreadGroup());
        System.out.println(t2.getThreadGroup());

    }
}
</code></pre>
<ul>
<li>多线程实现文件上传</li>
</ul>
<pre><code class="language-java">
</code></pre>
<ul>
<li>多线程实现文件下载</li>
</ul>
<pre><code class="language-java">
</code></pre>
<h3 id="11-定时器">11. 定时器</h3>
<ul>
<li>线程工具，用来调度多个定时任务，以后台线程的方式执行</li>
</ul>
<h4 id="111-类javautiltimer-和-javautiltimertask">11.1 类：java.util.Timer 和 java.util.TimerTask</h4>
<ul>
<li>java.util.Timer</li>
<li>线程调度任务以供将来在后台线程中执行的功能。 任务可以安排一次执行，或定期重复执行。
<ul>
<li>方法
<ul>
<li>void schedule（TimeTasj task，Data time）</li>
<li>void cancle（）</li>
</ul>
</li>
</ul>
</li>
<li>java.util.TimerTask
<ul>
<li>方法
<ul>
<li>boolean cancle（）</li>
<li>abstract void run（）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="12-小结">12. 小结</h3>
<blockquote>
<ol>
<li>多线程的实现方式有几种</li>
<li>同步有几种方式</li>
<li>启动线程的方式</li>
<li>sleep和wait方法的区别</li>
<li>为什么wait和notify方法在Object中</li>
<li>线程的生命周期</li>
<li>练习：多线程网络编程群聊</li>
</ol>
</blockquote>
<h2 id="79-网络编程">79. 网络编程</h2>
<h3 id="1-计算机网络">1. 计算机网络</h3>
<ul>
<li>计算机之间为了实现资源共享和信息传递，通过通信线路连接起来的若干计算机组成的网络
<ul>
<li>局域网</li>
<li>城域网</li>
<li>广域网</li>
</ul>
</li>
</ul>
<h3 id="2-网络模型osi">2. 网络模型（OSI）</h3>
<ul>
<li>OSI（Open System Interconnection开放式系统互联）参考模型（理论模型，但实际上没有人用这个标准）
<ul>
<li>物理层：负责为设备之间的数据通信提供传输信号和物理介质</li>
<li>数据链路层：负责通过协议保证传输数据的正确性MAC</li>
<li>网络层：负责定义能够表示所有网络节点的逻辑地址IP地址</li>
<li>传输层：负责是否选择差错恢复协议、数据流重用、错误顺序重排</li>
<li>会话层：负责使应用建立和维持会话，使通信在失效时继续恢复通信</li>
<li>表示层：负责定义转换数据格式及加密</li>
<li>应用层：负责文件访问和管理、可靠传输服务、远程操作服务（HTTP、FTP、SMTP）</li>
</ul>
</li>
<li>TCP/IP模型
<ul>
<li>网络接口层</li>
<li>网络层</li>
<li>传输层</li>
<li>应用层</li>
</ul>
</li>
</ul>
<h3 id="3-通信协议">3. 通信协议</h3>
<ul>
<li>TCP协议（Transmission Control Protocol传输控制协议）：三次握手，四次挥手</li>
<li>UDP协议（User Datagram Protocol用户数据报协议）：无连接的传输协议，不可靠的信息传输服务，每个包最大64KB</li>
<li>IP协议（Internet Protocol互联网协议/网际协议）：负责数据从一台机器发送到另一台机器，给互联网每台设备分配一个唯一的标识IP地址
<ul>
<li>IPv4（4字节32位二进制标识地址）：4段8位二进制数</li>
<li>IPv6（16字节128位二进制标识地址）：8段十六进制数</li>
</ul>
</li>
</ul>
<h3 id="4-ip地址与端口号">4. IP地址与端口号</h3>
<ul>
<li>IP地址：用于在网络中唯一标识一台主机的一段地址（主机）</li>
<li>端口号：用于在通信实体上进行网络通讯应用程序的标识（进程）
<ul>
<li>常用端口号：
<ul>
<li>MySQL：3306</li>
<li>Oracle：1521</li>
<li>Tomcat：8080</li>
<li>HTTP：80</li>
<li>FTP：21</li>
<li>SMTP：25</li>
</ul>
</li>
<li>用户端口（1024以后的端口）</li>
</ul>
</li>
</ul>
<h3 id="5-java网络编程">5. Java网络编程</h3>
<h4 id="51-inetaddress">5.1 InetAddress</h4>
<ul>
<li>包：java.net.InetAddress</li>
<li>子类：
<ul>
<li>Inet4Address</li>
<li>Inet6Address</li>
</ul>
</li>
<li>无构造方法</li>
<li>常用方法：
<ul>
<li>public static InetAddress[ ] getAllByName（String host）：根据指定主机名称的配置返回InetAddress对象数组</li>
<li>public static InetAddress getByAddress（byte[ ] addr）：根据指定IP地址字节数组返回InetAddress对象</li>
<li>public static InetAddress getByAddress（String host，byte[ ] addr）：根据指定主机名称和IP地址字节数组返回InetAddress对象</li>
<li>public boolean equals（Object obj）：比较两个对象</li>
<li>public byte[ ] getAddress（）：返回InetAddress对象的原始IP地址</li>
<li>public static InetAddress getLocalHost（）：获取本机主机InetAddress对象</li>
<li>public String getHostAddress（）：获取IP地址字符串</li>
<li>public String getHostName（）：获取IP地址对应主机名</li>
<li>public boolean isReachable（int timeout）：测试改地址是否可达，参数单位毫秒</li>
<li>public String toString（）：将IP地址转为String</li>
</ul>
</li>
</ul>
<h4 id="52-socket编程">5.2 Socket编程</h4>
<ul>
<li>
<p>socket（套接字）是网络中的一个通信节点：网络中通信端点的抽象</p>
<ul>
<li>客户端Socket</li>
<li>服务器ServerSocket</li>
</ul>
</li>
<li>
<p>通信要求：IP地址+端口号</p>
</li>
<li>
<p>开发步骤</p>
<ul>
<li>
<p>服务器端：</p>
<ul>
<li>创建ServerSocket，指定端口号</li>
<li>调用accept等待客户端接入</li>
<li>使用输入流，接收请求数据到服务器</li>
<li>使用输出流，发送响应数据给客户端</li>
<li>释放资源</li>
</ul>
</li>
<li>
<p>客户端：</p>
<ul>
<li>创建Socket，指定服务器IP地址+端口号</li>
<li>使用输出流，发送请求数据给服务器</li>
<li>使用输入流，接受相应数据到客户端</li>
<li>释放资源</li>
</ul>
</li>
</ul>
</li>
<li>
<p>ServerSocket类</p>
<ul>
<li>包：java.net.ServerSocket</li>
<li>子类：java.net.SSLServerSocket</li>
<li>构造方法：
<ul>
<li>public ServerSocket（）：创建未绑定的服务器套接字</li>
<li>public ServerSocket（int port）：创建绑定到指定端口号的服务器套接字</li>
<li>public ServerSocket（int port，int backlog）：创建服务器套接字并绑定到指定本地端口号和backlog</li>
<li>public ServerSocket（int port，int backlog，InetAddress bindAddr）：创建绑定指定端口号的套接字，backlog和本地IP地址绑定</li>
</ul>
</li>
<li>常用方法：
<ul>
<li>public Socket accept（）：监听客户端数据，并返回客户端的Socket</li>
<li>public void bind（SocketAddress endpoint）：将ServerSocket绑定到特定IP地址和端口号</li>
<li>public void bind（SocketAddress endpoint，int backlog）</li>
<li>public void close（）：关闭套接字</li>
<li>public ServerSocketChannel getChannel（）</li>
<li>public InetAddress getInetAddress（）：返回ServerSocket的本地地址</li>
<li>public int getLocalPort（）：返回ServerSocket正在使用的端口号</li>
<li>public SocketAddress getLocalSocketAddress（）</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>案例1：TCP编程实现客户端发送数据给服务器端</p>
<pre><code class="language-java">package com.demo.javase;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * 基于TCp协议的服务端开发
 * ①.创建ServerSocket，并绑定端口号
 * ②.调用accept（）接收客户端请求
 * ③.获取输入流，读取客户端发送数据
 * ④.获取输出流，发送数据给客户端
 * @author 絷缘
 * @version 1.0
 * @date 2020/12/8 21:46
 **/
public class TCPServer {
    public static void main(String[] args) throws IOException {
        System.out.println(&quot;服务器已启动......&quot;);
        //①.创建ServerSocket，并绑定端口号
        ServerSocket listener = new ServerSocket(8890);
        //②.调用accept（）接收客户端请求，阻塞方法，如果没有客户端请求，则阻塞
        Socket socket = listener.accept();
        InputStream inputStream = socket.getInputStream();
        BufferedReader br = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8));
        String data = br.readLine();
        System.out.println(&quot;客户端IP：&quot; + socket.getInetAddress() + &quot;\t发送数据：&quot; + data + &quot;\t时间：&quot; + new SimpleDateFormat(&quot;yyyy-MM-dd kk:mm:ss&quot;).format(new Date(System.currentTimeMillis())));
        br.close();
        socket.close();
        listener.close();
    }
}
</code></pre>
<pre><code class="language-java">package com.demo.javase;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.net.Socket;
import java.nio.charset.StandardCharsets;

/**
 * 基于TCP的客户端开发
 * ①.创建客户端套接字，并指定服务器的IP地址和端口号
 * ②.获取输出流，发送数据给服务器
 * ③.获取输入流，接收服务器返回数据
 * ④.关闭，释放资源
 * @author 絷缘
 * @version 1.0
 * @date 2020/12/8 22:04
 **/
public class TCPClient {
    public static void main(String[] args) throws IOException {
        System.out.println(&quot;客户端已启动......&quot;);
        //①.创建客户端套接字，并指定服务器的IP地址和端口号
        Socket socket = new Socket(&quot;127.0.0.1&quot;,8890);
        //②.获取输出流，发送数据给服务器
        OutputStream outputStream = socket.getOutputStream();
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(outputStream, StandardCharsets.UTF_8));
        bw.write(&quot;Are you OK ?&quot;);
        bw.close();
        socket.close();
    }
}
</code></pre>
</blockquote>
<h4 id="53-udp协议发送接收数据">5.3 UDP协议发送接收数据</h4>
<ul>
<li>
<p>步骤</p>
<ul>
<li>创建发送端的Socket对象</li>
<li>创建数据，把数据打包</li>
<li>调用Socket对象的方法发送数据</li>
<li>释放资源</li>
<li>创建接收端的Socket对象</li>
<li>创建接收数据包容器</li>
<li>接收数据并解析数据</li>
<li>释放资源</li>
</ul>
<pre><code class="language-java">public class UDPSend {
    public static void main(String[] args) throws IOException {
        DatagramSocket ds = new DatagramSocket();
        byte[] bytes = &quot;你好！&quot;.getBytes();
        DatagramPacket dp = new DatagramPacket(bytes,bytes.length, InetAddress.getLocalHost(),8090);
        ds.send(dp);
    }
}

public class UDPReceive {
    public static void main(String[] args) throws IOException {
        //创建接收端Socket
        DatagramSocket ds = new DatagramSocket(8090);
        //创建一个数据包，作为接收容器
        byte [] bys = new byte[1024];
        DatagramPacket dp = new DatagramPacket(bys,bys.length);
        ds.receive(dp);
        //接收数据，解析数据并打印到控制台
        byte[] data = dp.getData();
        String str = new String(data,0,data.length);
        System.out.println(new StringBuffer().append(&quot;发送方IP：&quot;).append(dp.getAddress()).append(&quot;\t发送内容：&quot;).append(str).toString());
        //关闭资源
    }
}
</code></pre>
</li>
</ul>
<h4 id="54-tcp协议发送接收数据">5.4 TCP协议发送接收数据</h4>
<ul>
<li>创建客户端的Socket对象（Socket）</li>
<li>获取输出流对象，写数据</li>
<li>释放资源</li>
<li>创建服务器端的Socket对象（ServerSocket）</li>
<li>获取输入流对象，读数据</li>
<li>释放资源</li>
</ul>
<pre><code class="language-java">public class TCPClient {
    public static void main(String[] args) throws IOException {
        System.out.println(&quot;客户端已启动......&quot;);
        //①.创建客户端套接字，并指定服务器的IP地址和端口号
        Socket socket = new Socket(&quot;127.0.0.1&quot;,8890);
        //②.获取输出流，发送数据给服务器
        OutputStream outputStream = socket.getOutputStream();
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(outputStream, StandardCharsets.UTF_8));
        bw.write(&quot;Are you OK ?&quot;);
        bw.close();
        socket.close();
    }
}
public class TCPServer {
    public static void main(String[] args) throws IOException {
        System.out.println(&quot;服务器已启动......&quot;);
        //①.创建ServerSocket，并绑定端口号
        ServerSocket listener = new ServerSocket(8890);
        //②.调用accept（）接收客户端请求，阻塞方法，如果没有客户端请求，则阻塞
        Socket socket = listener.accept();
        InputStream inputStream = socket.getInputStream();
        BufferedReader br = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8));
        String data = br.readLine();
        System.out.println(&quot;客户端IP：&quot; + socket.getInetAddress() + &quot;\t发送数据：&quot; + data + &quot;\t时间：&quot; + new SimpleDateFormat(&quot;yyyy-MM-dd kk:mm:ss&quot;).format(new Date(System.currentTimeMillis())));
        br.close();
        socket.close();
        listener.close();
    }
}
</code></pre>
<ul>
<li>服务器可以反馈</li>
</ul>
<pre><code class="language-java">public class TCPServer {
    public static void main(String[] args) throws IOException {
        System.out.println(&quot;服务器已启动......&quot;);
        //①.创建ServerSocket，并绑定端口号
        ServerSocket listener = new ServerSocket(8890);
        //②.调用accept（）接收客户端请求，阻塞方法，如果没有客户端请求，则阻塞
        Socket socket = listener.accept();
        InputStream inputStream = socket.getInputStream();
        BufferedReader br = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8));
        String data = br.readLine();
        System.out.println(&quot;客户端IP：&quot; + socket.getInetAddress() + &quot;\t发送数据：&quot; + data + &quot;\t时间：&quot; + new SimpleDateFormat(&quot;yyyy-MM-dd kk:mm:ss&quot;).format(new Date(System.currentTimeMillis())));
        //给反馈
        OutputStream outputStream = socket.getOutputStream();
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(outputStream,StandardCharsets.UTF_8));
        bw.write(&quot;Hello!Thank you!Thank you very much!&quot;);
        bw.newLine();
        bw.flush();

        socket.close();
        listener.close();
    }
}


public class TCPClient {
    public static void main(String[] args) throws IOException {
        System.out.println(&quot;客户端已启动......&quot;);
        //①.创建客户端套接字，并指定服务器的IP地址和端口号
        Socket socket = new Socket(&quot;127.0.0.1&quot;,8890);
        //②.获取输出流，发送数据给服务器
        OutputStream outputStream = socket.getOutputStream();
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(outputStream, StandardCharsets.UTF_8));
        bw.write(&quot;Are you OK ?&quot;);
        bw.newLine();
        bw.flush();
        //接受反馈
        InputStream inputStream = socket.getInputStream();
        BufferedReader br = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8));
        String str = br.readLine();
        System.out.println(&quot;服务器：&quot; + str);

        bw.close();
        br.close();
        socket.close();
    }
}
//在此处我犯了一个严重的错误，如果使用BufferedWriter 不加newLine()和flush()的话，服务端BufferedReader的readline()方法就读取不到msg,会一直阻塞下去。
</code></pre>
<h3 id="6-网络编程模型">6. 网络编程模型</h3>
<h4 id="61-bio网络编程模型同步阻塞的bioblocking-io">6.1 BIO网络编程模型（同步阻塞的BIO）【Blocking I/O】</h4>
<ul>
<li>JDK1.4之前，我们使用的都是BIO，我们想要实现ServerSocket和Socket之间的通信，需要使用多线程来处理大量请求</li>
<li>同步阻塞I/O，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制来改善。BIO方式适用于连接数目比较小且固定的架构，这种方式对服务端资源要求比较高，并发局限于应用中，在jdk1.4以前是唯一的io现在，但程序直观简单易理解</li>
</ul>
<figure data-type="image" tabindex="31"><img src="http://pic.zyblog.xyz/img/typora/20201210143814.png" alt="image-20201210143814190" loading="lazy"></figure>
<h4 id="62-nio网络编程模型同步非阻塞nionon-blocking-io">6.2 NIO网络编程模型（同步非阻塞NIO）【Non-blocking I/O】</h4>
<ul>
<li>NIO是基于事件驱动思想来完成的</li>
<li>同步非阻塞I/O，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有IO请求时才启动一个线程进行处理。NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，jdk1,4开始支持</li>
</ul>
<figure data-type="image" tabindex="32"><img src="http://pic.zyblog.xyz/img/typora/20201210144443.png" alt="image-20201210144443494" loading="lazy"></figure>
<h4 id="63-aio网络编程模型异步非阻塞aio">6.3 AIO网络编程模型（异步非阻塞AIO）</h4>
<ul>
<li>异步非阻塞I/O，服务器实现模式为一个有效请求一个线程，客户端的IO请求都是由操作系统先完成了再通知服务器用其启动线程进行处理。AIO方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，jdk1.7开始支持。</li>
</ul>
<h3 id="7-nio">7. NIO</h3>
<figure data-type="image" tabindex="33"><img src="http://pic.zyblog.xyz/img/typora/20201210140416.png" alt="image-20201210140343354" loading="lazy"></figure>
<blockquote>
<p>参考文档：https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html</p>
</blockquote>
<h4 id="71-nio与传统io的区别">7.1 NIO与传统IO的区别</h4>
<ul>
<li>NIO简介
<ul>
<li>Java NIO（New IO/Non-Blocking IO）是从Java1.4版本开始引入的一个新的IO，为了替代传统的阻塞式IO，NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的、基于通道的IO操作，NIO将以更加高效的方式进行文件的读写操作。</li>
</ul>
</li>
<li>区别
<ul>
<li>传统的IO是面向流的，NIO是面向缓冲区的</li>
<li>传统的IO是阻塞式IO，NIO是非阻塞式的</li>
<li>传统的IO没有选择器，NIO有选择器</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="34"><img src="http://pic.zyblog.xyz/img/typora/20201213100459.png" alt="image-20201213100451064" loading="lazy"></figure>
<h4 id="72-通道channel和缓冲区buffer">7.2 通道（Channel）和缓冲区（Buffer）</h4>
<ul>
<li>
<p>概述：</p>
<ul>
<li>Java NIO系统的核心在于：通道（Channel）和缓冲区（Buffer），通道用于建立起到IO设备的连接（例如：文件、套接字），所以如果需要使用NIO时，首先就要获取一个连接到IO设备的通道，然后通过与缓冲区结合，对数据进行读写处理</li>
</ul>
<blockquote>
<p>简而言之：Channel负责传输，Buffer负责存储</p>
</blockquote>
</li>
</ul>
<h4 id="73-缓冲区buffer">7.3 缓冲区（Buffer）</h4>
<ul>
<li>
<p>java.nio.Buffer：抽象类</p>
</li>
<li>
<p>概述：负责数据存取，缓存区底层就是数组</p>
</li>
<li>
<p>根据数据类型的不同，提供了相应的缓冲区（Boolean除外）</p>
<ul>
<li>ByteBuffer</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
<li>CharBuffer</li>
</ul>
</li>
<li>
<p>四个重要属性：</p>
<ul>
<li>Capacity：容量</li>
<li>Position：位置</li>
<li>Limit：上限</li>
<li>Mark：标记</li>
</ul>
</li>
<li>
<p>常用方法：</p>
<ul>
<li>public int capacity（）：返回缓冲区容量</li>
<li>public Buffer clear（）：清除此缓冲区</li>
<li>public Buffer flip（）：反转这个缓冲区，由写变读，由读变写</li>
<li>public boolean hasRemaining（）：当前位置position到上限limit是否存在元素</li>
<li>public int limit（）：返回缓冲区的上限</li>
<li>public Buffer limit（int newLimit）：设置此缓冲区的上限</li>
<li>public Buffer mark（）：设置此缓冲区的标记</li>
<li>public int position（）：返回此缓冲区的位置</li>
<li>public Buffer position（int newPosition）：设置此缓冲区的位置</li>
<li>public int remaining（）：返回当前位置和上限之间的元素</li>
<li>public Buffer reset（）：将此缓冲区的位置重置为上一次标记的位置</li>
<li>public Buffer rewind（）：倒带缓冲区四大属性</li>
</ul>
</li>
<li>
<p>非直接缓冲区（使用allocate方法获取缓冲区对象，创建在JVM内存中）</p>
<ul>
<li>allocate（）：获取非直接缓冲区对象</li>
<li>put（）：存入数据到缓冲区中</li>
<li>get（）：从缓冲区中读取数据</li>
<li>limit（）：获取缓冲区上限</li>
<li>position（）：获取缓冲区位置</li>
<li>capacity（）：获取缓冲区容量</li>
<li>mark（）：设置缓冲区标记</li>
<li>reset（）：重置position到上一次mark处</li>
<li>clear（）：清除缓冲区，position为0，limit为capacity</li>
</ul>
<pre><code class="language-java">//使用allocate分配一个指定大小的缓冲区
System.out.println(&quot;=================allocate()方法创建缓冲区后===================&quot;);
ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
System.out.println(&quot;position:&quot; + byteBuffer.position());
System.out.println(&quot;limit:&quot; + byteBuffer.limit());
System.out.println(&quot;capacity:&quot; + byteBuffer.capacity());
System.out.println(&quot;===================put()方法加入数据后=================&quot;);
byteBuffer.put(&quot;HelloWorld!&quot;.getBytes());
System.out.println(&quot;position:&quot; + byteBuffer.position());
System.out.println(&quot;limit:&quot; + byteBuffer.limit());
System.out.println(&quot;capacity:&quot; + byteBuffer.capacity());
System.out.println(&quot;===================flip()方法切换读数据模式后================&quot;);
byteBuffer.flip();
System.out.println(&quot;position:&quot; + byteBuffer.position());
System.out.println(&quot;limit:&quot; + byteBuffer.limit());
System.out.println(&quot;capacity:&quot; + byteBuffer.capacity());
System.out.println(&quot;===================get()方法读取数据后================&quot;);
byte [] dst = new byte[byteBuffer.limit()];
byteBuffer.get(dst);
System.out.println(&quot;position:&quot; + byteBuffer.position());
System.out.println(&quot;limit:&quot; + byteBuffer.limit());
System.out.println(&quot;capacity:&quot; + byteBuffer.capacity());
System.out.println(&quot;====================rewind()方法执行后===================&quot;);
byteBuffer.rewind();
System.out.println(&quot;position:&quot; + byteBuffer.position());
System.out.println(&quot;limit:&quot; + byteBuffer.limit());
System.out.println(&quot;capacity:&quot; + byteBuffer.capacity());
System.out.println(&quot;==================clear()方法执行后=======================&quot;);
byteBuffer.clear();
System.out.println(&quot;position:&quot; + byteBuffer.position());
System.out.println(&quot;limit:&quot; + byteBuffer.limit());
System.out.println(&quot;capacity:&quot; + byteBuffer.capacity());
/*
clear()方法并非删除了数据，而是将position变为0，limit变为capacity的大小，数据依然存在
*/
System.out.println((char)byteBuffer.get(1));
byte [] bys = new byte[1024];
System.out.println((char)byteBuffer.get(1));
byteBuffer.get(bys,0,2);
System.out.println(new String(bys,0,bys.length));
byteBuffer.mark();
byteBuffer.get(bys,2,4);
System.out.println(new String(bys,0,bys.length));
byteBuffer.reset();
byteBuffer.get(bys,2,4);
System.out.println(new String(bys,0,bys.length));

=================allocate()方法创建缓冲区后===================
position:0
limit:1024
capacity:1024
===================put()方法加入数据后=================
position:11
limit:1024
capacity:1024
===================flip()方法切换读数据模式后================
position:0
limit:11
capacity:1024
===================get()方法读取数据后================
position:11
limit:11
capacity:1024
====================rewind()方法执行后===================
position:0
limit:11
capacity:1024
==================clear()方法执行后=======================
position:0
limit:1024
capacity:1024
e
He                                                                            
HelloW                                                                                 
HelloW                                                                                 
</code></pre>
</li>
<li>
<p>直接缓冲区（使用allocateDirect方法获取缓冲区对象，创建在物理内存中）</p>
<ul>
<li>allocateDirect（）：获取直接缓冲区对象</li>
<li>put（）：存入数据到缓冲区中</li>
<li>get（）：从缓冲区中读取数据</li>
<li>limit（）：获取缓冲区上限</li>
<li>position（）：获取缓冲区位置</li>
<li>capacity（）：获取缓冲区容量</li>
<li>mark（）：设置缓冲区标记</li>
<li>reset（）：重置position到上一次mark处</li>
<li>clear（）：清除缓冲区，position为0，limit为capacity</li>
</ul>
<pre><code class="language-java">ByteBuffer byteBuffer = ByteBuffer.allocateDirect(1024);
byteBuffer.put(&quot;zhiyuan&quot;.getBytes());
System.out.println(byteBuffer.isDirect());
</code></pre>
</li>
<li>
<p>直接缓冲区和非直接缓冲区的区别</p>
</li>
</ul>
<figure data-type="image" tabindex="35"><img src="http://pic.zyblog.xyz/img/typora/20201213184555.jpeg" alt="非直接缓冲区" loading="lazy"></figure>
<hr>
<figure data-type="image" tabindex="36"><img src="http://pic.zyblog.xyz/img/typora/20201213184622.jpeg" alt="直接缓冲区" loading="lazy"></figure>
<h4 id="74-通道channel">7.4 通道（Channel）</h4>
<ul>
<li>
<p>用于建立起与IO设备的连接，结合缓冲区实现读写数据</p>
</li>
<li>
<p>特性</p>
<ul>
<li>双向性：类似于流，但不同于InputStream和OutputStream，流具有单向性和独占性，通道则偏向于数据的流通性，一个Channel支持双向传输（输入、输出）</li>
<li>非阻塞式</li>
<li>操作唯一性</li>
</ul>
</li>
<li>
<p>实现</p>
<ul>
<li>文件类：FileChannel</li>
<li>UDP类：DatagramChannel</li>
<li>TCP类：ServerSocketChannel / SocketChannel</li>
</ul>
</li>
<li>
<p>获取通道</p>
<ol>
<li>通过支持通道的类提供的<code>getChannel()</code>获取
<ul>
<li>FileInputStream/FileOutputStream</li>
<li>RandomAccessFile</li>
<li>ServerSocket/Socket</li>
<li>DatagramSocket</li>
</ul>
</li>
<li>JDK1.7以后NIO2针对各个类提供了静态方法<code>open()</code>获取</li>
<li>JDK1.7以后NIO2的Files工具类提供了<code>newByteChannel()</code>获取</li>
</ol>
</li>
<li>
<p>利用通道完成文件的复制</p>
</li>
</ul>
<pre><code class="language-java">//使用非直接缓冲区完成文件的复制
public static void test1() throws IOException {
        FileInputStream fis = new FileInputStream(&quot;E:\\壁纸\\壁纸\\212.jpg&quot;);
        FileOutputStream fos = new FileOutputStream(&quot;copy1.jpg&quot;);
        FileChannel inChannel = fis.getChannel();
        FileChannel outChannel = fos.getChannel();
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        while(inChannel.read(buffer)!=-1){
            buffer.flip();
            outChannel.write(buffer);
            buffer.clear();
        }
        outChannel.close();
        inChannel.close();
        fos.close();
        fis.close();
    }
//使用直接缓冲区通道写数据
public static void test2() throws IOException{
        FileInputStream fis = new FileInputStream(&quot;E:\\壁纸\\壁纸\\212.jpg&quot;);
        FileOutputStream fos = new FileOutputStream(&quot;copy2.jpg&quot;);
        FileChannel inChannel = fis.getChannel();
        FileChannel outChannel = fos.getChannel();
        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(1024);
        while(inChannel.read(byteBuffer)!=-1){
            byteBuffer.flip();
            outChannel.write(byteBuffer);
            byteBuffer.clear();
        }
        outChannel.close();
        inChannel.close();
        fos.close();
        fis.close();
    }
//使用直接缓冲区完成文件的复制（使用内存映射文件的方式）
public static void test3() throws IOException, URISyntaxException {
        FileChannel inChannel = FileChannel.open(Paths.get(&quot;E:\\壁纸\\壁纸\\212.jpg&quot;), StandardOpenOption.READ);
        FileChannel outChannel = FileChannel.open(Paths.get(&quot;copy3.jpg&quot;),StandardOpenOption.READ,StandardOpenOption.WRITE,StandardOpenOption.CREATE);
        //内存映射文件
        MappedByteBuffer inMapBuffer = inChannel.map(FileChannel.MapMode.READ_ONLY, 0, inChannel.size());
        MappedByteBuffer outMapBuffer = outChannel.map(FileChannel.MapMode.READ_WRITE, 0, inChannel.size());
        //直接对缓冲区进行数据的读写操作
        byte [] dst = new byte[inMapBuffer.limit()];
        inMapBuffer.get(dst);
        outMapBuffer.put(dst);
        inChannel.close();
        outChannel.close();
    }
//使用直接缓冲区完成文件复制（使用通道数据交换的方式）
    public static void test4() throws IOException{
        FileChannel inChannel = FileChannel.open(Paths.get(&quot;E:\\壁纸\\壁纸\\212.jpg&quot;), StandardOpenOption.READ);
        FileChannel outChannel = FileChannel.open(Paths.get(&quot;copy4.jpg&quot;),StandardOpenOption.READ,StandardOpenOption.WRITE,StandardOpenOption.CREATE);
        inChannel.transferTo(0, inChannel.size(), outChannel);
//        outChannel.transferFrom(inChannel,0,inChannel.size());
        inChannel.close();
        outChannel.close();
    }
//耗时对比
    public static void main(String[] args) throws IOException, URISyntaxException {
        long startTime = System.currentTimeMillis();
//        test1();//52毫秒（非直接缓冲区使用Buffer复制）
//        test2();//41毫秒（直接缓冲区使用Buffer复制）
//        test3();//24毫秒（直接缓冲区使用文件映射复制）
//        test4();//17毫秒（直接缓冲区使用通道数据交换复制）
        long endTime = System.currentTimeMillis();
        long useTime = endTime - startTime;
        System.out.println(&quot;耗时：&quot; + useTime + &quot;毫秒&quot;);
    }
</code></pre>
<ul>
<li>
<p>分散（Scatter）读取和聚集（Gather）写入</p>
<ul>
<li>分散读取：将通道中数据分散到多个缓冲区中</li>
<li>聚集写入：将多个缓冲区的数据聚集到通道中</li>
</ul>
<pre><code class="language-java">//首先创建一个随机访问文件
RandomAccessFile raf= new RandomAccessFile(&quot;test.txt&quot;, &quot;rw&quot;);
//根据随机获取通道
FileChannel channel = raf.getChannel();
//分配指定大小指定缓冲区
ByteBuffer buf1=ByteBuffer.allocateDirect(200);
ByteBuffer buf2=ByteBuffer.allocateDirect(1024);
// 分散读取
ByteBuffer[] bufs={buf1,buf2};
channel.read(bufs);//采用通道分散读取数据
for (ByteBuffer byteBuffer : bufs) {
    // 切换成读模式
    byteBuffer.flip();
}
System.out.println(new String(bufs[0].array(),0,bufs[0].limit()));
System.out.println(&quot;-------------------------------------------------&quot;);
System.out.println(new String(bufs[1].array(),1,bufs[1].limit()));
System.out.println(&quot;------聚集写入---------&quot;);
        //创建一个随机写入文件
RandomAccessFile raf2= new RandomAccessFile(&quot;test2.txt&quot;, &quot;rw&quot;);
//获取写入通道
FileChannel channel2 = raf2.getChannel();
channel2.write(bufs);//采用通道写入数据
raf2.close();//关闭
raf.close();//关闭
</code></pre>
</li>
</ul>
<h4 id="75-字符集charset">7.5 字符集（Charset）</h4>
<ul>
<li>编码：字符串 -&gt; 字节数组</li>
<li>解码：字节数组 -&gt; 字符串</li>
</ul>
<pre><code class="language-java">public static void main(String[] args) {
        SortedMap&lt;String, Charset&gt; map = Charset.availableCharsets();
        Set&lt;Map.Entry&lt;String, Charset&gt;&gt; set = map.entrySet();
        for (Map.Entry&lt;String, Charset&gt; s : set) {
            System.out.println(s.getKey() + &quot;\t&quot; + s.getValue() + &quot;\t&quot; + s.getClass());
        }
   		 //创建编码格式
        Charset gbk = Charset.forName(&quot;GBK&quot;);
        //获取编码器
        CharsetEncoder charsetEncoder = gbk.newEncoder();
        //获取解码器
        CharsetDecoder charsetDecoder = gbk.newDecoder();
        //编码
        CharBuffer cb = CharBuffer.allocate(1024);
        cb.put(&quot;HelloWord!&quot;);
        cb.flip();
        ByteBuffer encode = charsetEncoder.encode(cb);
        System.out.print(&quot;[&quot;);
        for (int i = 0; i &lt; encode.limit(); i++) {
            System.out.print(encode.get(i)+&quot;,&quot;);
        }
        System.out.print(&quot;]&quot;);
        //解码
        encode.rewind();
        CharBuffer decode = charsetDecoder.decode(encode);
        System.out.print(&quot;\n[&quot;);
        for (int i = 0; i &lt; decode.limit(); i++) {
            System.out.print(decode.get(i)+&quot;,&quot;);
        }
        System.out.print(&quot;]&quot;);
}
</code></pre>
<h4 id="76-nio的非阻塞简述">7.6 NIO的非阻塞简述</h4>
<figure data-type="image" tabindex="37"><img src="http://pic.zyblog.xyz/img/typora/20201210140416.png" alt="image-20201210140343354" loading="lazy"></figure>
<ul>
<li>在客户端与服务器之间，建立一个选择器（Selector），将每一个用于传输数据的通道（Channel）注册到该选择器（Selector）上，选择器（Selector）来监控各个通道的IO（WRITE、READ、ACCEPT、CONNECT）状态，当客户端IO状态准备就绪时，选择器（Selector）通知服务器开始处理各种IO</li>
</ul>
<h4 id="77-nio阻塞式编程">7.7 NIO阻塞式编程</h4>
<ul>
<li>
<p>三个核心</p>
<ul>
<li>
<p>第一步：创建通道（Channel），负责建立IO设备连接</p>
<ul>
<li>java.nio.channels.Channel接口
<ul>
<li>SelectableChannel
<ul>
<li>ServerSocketChannel</li>
<li>SocketChannel</li>
<li>DatagramChannel</li>
<li>Pipe.SinkChannel</li>
<li>Pipe.SourceChannel</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>FileChannel不能切换成非阻塞模式</p>
</blockquote>
</li>
<li>
<p>第二步：创建缓冲区（Buffer），负责数据的存取</p>
</li>
<li>
<p>第三步：创建选择器（Selector），是SelectableChannel的多路复用器，负责监控SelectableChannel的IO状态</p>
</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class TCPDemo {
    @Test
    public void client() throws IOException {
        SocketChannel socketChannel = null;
        FileChannel inChannel = null;

        //1.建立IO通道
        try {
            socketChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;,8090));
        } catch (IOException e) {
            e.printStackTrace();
        }
        //2.建立缓冲区
        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(1024);
        //3.读取本地图片发送到服务器
        try {
            inChannel = FileChannel.open(Paths.get(&quot;E:\\壁纸\\壁纸\\212.jpg&quot;), StandardOpenOption.READ);
        } catch (IOException e) {
            e.printStackTrace();
        }
        while(inChannel.read(byteBuffer)!=-1){
            byteBuffer.flip();
            socketChannel.write(byteBuffer);
            byteBuffer.clear();
        }
        inChannel.close();
        socketChannel.close();
    }

    @Test
    public void server() throws IOException {
        //1.建立IO通道
        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
        //2.绑定端口号
        serverSocketChannel.bind(new InetSocketAddress(8090));
        //3.获取客户端连接的通道
        SocketChannel socketChannel = serverSocketChannel.accept();
        //4.接收客户端的数据，并保存到本地
        FileChannel outChannel = FileChannel.open(Paths.get(&quot;client1.jpg&quot;), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);
        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
        while(socketChannel.read(byteBuffer)!=-1){
            byteBuffer.flip();
            outChannel.write(byteBuffer);
            byteBuffer.clear();
        }
        //5.关闭资源
        socketChannel.close();
        serverSocketChannel.close();
        outChannel.close();
    }
}
</code></pre>
<h4 id="78-nio非阻塞式编程">7.8 NIO非阻塞式编程</h4>
<ul>
<li>TCP</li>
</ul>
<pre><code class="language-java">
</code></pre>
<ul>
<li>UDP</li>
</ul>
<pre><code class="language-java">
</code></pre>
<h4 id="79-管道pipe">7.9 管道（Pipe）</h4>
<pre><code class="language-java">//1. 获取Pipe管道
Pipe pipe = Pipe.open();
//2. 将缓冲区中的数据写入管道
ByteBuffer buffer = ByteBuffer.allocate(1024);
Pipe.SinkChannel sinkChannel = pipe.sink();
buffer.put(&quot;Pipe&quot;.getBytes());
buffer.flip();
sinkChannel.write(buffer);
//3. 读取缓冲区中的数据
Pipe.SourceChannel sourceChannel = pipe.source();
buffer.flip();
int length = sourceChannel.read(buffer);
System.out.println(new String(buffer.array(),0,length));
sourceChannel.close();
sinkChannel.close();
</code></pre>
<h4 id="72-selector选择器多路复用器">7.2 Selector：选择器/多路复用器</h4>
<ul>
<li>
<p>作用：I/O就绪状态选择</p>
</li>
<li>
<p>地位：NIO网络编程的基础</p>
</li>
<li>
<p>事件</p>
<ul>
<li>SelectionKey.OP_CONNECT（连接就绪）</li>
<li>SelectionKey.OP_ACCEPT（接受就绪）</li>
<li>SelectionKey.OP_READ（读就绪）</li>
<li>SelectionKey.OP_WRITE（写就绪）</li>
</ul>
</li>
<li>
<p>实现</p>
<pre><code class="language-java">//创建Selector
Selector selector = Selector.open();
//将Channel注册到Selector上，监听读就绪事件
SelectionKey selectionKey = channel.register(selector,SelectionKey.OP_READ);
//阻塞等待Channel有就绪事件发生
int selectNum = selector.select();
//获取发生就绪事件的Channel集合
Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();
</code></pre>
</li>
</ul>
<h4 id="74-nio编程实现步骤">7.4 NIO编程实现步骤</h4>
<ul>
<li>第一步：创建Selector</li>
<li>第二步：创建ServerSocketChannel，并绑定监听端口</li>
<li>第三步：将Channel设置为非阻塞模式</li>
<li>第四步：将Channel注册到Selector上，监听连接事件</li>
<li>第五步：循环调用Selector的select方法，检查就绪情况</li>
<li>第六步：调用selectedKeys方法获取就绪Channel集合</li>
<li>第七步：判断就绪事件种类，调用业务处理方法</li>
<li>第八步：根据业务需要，决定是否再次注册监听事件，重复执行第三步操作</li>
</ul>
<h4 id="75-nio网络编程实战">7.5 NIO网络编程实战</h4>
<pre><code class="language-java">
</code></pre>
<h4 id="76-分散读取scatter和聚集写入gather">7.6 分散读取Scatter和聚集写入Gather</h4>
<ul>
<li>分散读取：从Channel中读取数据分散到多个Buffer中</li>
<li>聚集写入：把多个Buffer的数据聚集写入Channel中</li>
</ul>
<pre><code class="language-java">public static void main(String[] args){
    RandomAccessFile raf = new RandomAccessFile(&quot;a.txt&quot;,&quot;rw&quot;);
    
    FileChannel channel = raf.getChannel();
    
    ByteBuffer bb1 = ByteBuffer.allocate(10*3);
    ByteBuffer bb2 = ByteBuffer.allocate(100*3);
    
    Byter[] bbs = {bb1,bb2};
    channel.read(bbs);
    
    for(ByteBuffer bb : bbs){
        bb.flip();
        System.out.println(new String(bb.array(),0,bb.limit));
    }
    System.out.println(&quot;-----------------------------------&quot;);
    
    RandomAccessFile raf2 = new RandomAccessFile(&quot;b.txt&quot;,&quot;rw&quot;);
    FileChannel channel2 = raf2.getChannel();
    channel2.write(bb2);
}
</code></pre>
<h4 id="77-编解码">7.7 编解码</h4>
<ul>
<li>Charset</li>
</ul>
<h2 id="80-反射和注解">80. 反射和注解</h2>
<h3 id="1-反射">1. 反射</h3>
<h4 id="11-类加载">1.1 类加载</h4>
<ul>
<li>
<p>概述：当程序要使用某个类时，如果该类还未被加载进内存中，则系统会通过**<code>类的加载</code><strong>，</strong><code>类的连接</code><strong>，</strong><code>类的初始化</code>**这三个步骤来对类进行初始化</p>
</li>
<li>
<p>类加载</p>
<ul>
<li>将class文件读入内存，并为其创建一个java.lang.Class对象</li>
<li>任何类被使用时，系统都会为其建立一个java.lang.Class对象</li>
</ul>
</li>
<li>
<p>类的连接</p>
<ul>
<li>验证阶段：用于检验被加载的类是否有正确的内部结构，并和其他类协调一致</li>
<li>准备阶段：负责为类的类变量分配内存，并设置默认初始值</li>
<li>解析阶段：将类的二进制数据中的符号引用替换为直接引用</li>
</ul>
</li>
<li>
<p>类的初始化</p>
<ul>
<li>在该阶段，主要就是对类变量进行初始化</li>
</ul>
</li>
<li>
<p>类的初始化步骤</p>
<ol>
<li>
<p>假如类还未被加载和连接，则程序先加载并连接该类</p>
</li>
<li>
<p>假如该类的直接父类还未被初始化，则先初始化其直接父类（初始化直接父类也遵循1-3）</p>
</li>
<li>
<p>假如类中有初始化语句，则系统依次执行这些初始化语句</p>
</li>
</ol>
</li>
<li>
<p>类的初始化时机</p>
<ol>
<li>创建类的实例</li>
<li>调用类的类方法</li>
<li>访问类或者接口的类变量，或者为类变量赋值</li>
<li>使用反射方式来强制创建某个类或者接口对应的java.langClass对象</li>
<li>初始化某个类的子类</li>
<li>直接使用java.exe命令来运行某个主类</li>
</ol>
</li>
</ul>
<h4 id="12-类加载器">1.2 类加载器</h4>
<ul>
<li>
<p>作用：负责将class文件加载进内存中，并为之生成对应的java.lang.Class对象</p>
</li>
<li>
<p>JVM的类加载机制</p>
<ul>
<li>全盘负责：就是当一个类加载器负责加载某个class时，该class所依赖的和引用的其他class也将由类加载器负责载入，除非显式使用另外一个类加载器来载入</li>
<li>父类委托：就是当一个类加载器负责加载某个class时，先让父类加载器试图加载该class，只有在父类加载器无法加载该类时才尝试从自己的了一路径中加载该类</li>
<li>缓存机制：保证所有加载过的class都会被缓存，当程序需要使用某个class对象时，类加载器先从缓存区中搜索该class，只有当缓存区中不存在该class对象时，系统才会读取该类对应的二进制数据，并将其转换成class对象，存储到缓存区</li>
</ul>
</li>
<li>
<p>包：java.lang.ClassLoader（抽象类）</p>
</li>
<li>
<p>常用方法：</p>
<ul>
<li>public ClassLoader getParent（）：返回父类加载器</li>
<li>public static ClassLoader getSystemClassLoader（）：返回系统类加载器</li>
</ul>
</li>
<li>
<p>Java运行时内置类加载器</p>
<ul>
<li>BootstrapClassLoader：虚拟机内置类加载器，通常为null</li>
<li>ExtensionClassLoader：平台类加载器（JDK1.9变为PlatFormClassLoader）</li>
</ul>
<blockquote>
<p>The extension class loader has been renamed; it is now the platform class loader. All classes in the Java SE Platform are guaranteed to be visible through the platform class loader. In addition, the classes in modules that are standardized under the Java Community Process but not part of the Java SE Platform are guaranteed to be visible through the platform class loader.</p>
<p>Just because a class is visible through the platform class loader does not mean the class is actually defined by the platform class loader. Some classes in the Java SE Platform are defined by the platform class loader while others are defined by the bootstrap class loader. Applications should not depend on which class loader defines which platform class.</p>
</blockquote>
<ul>
<li>SystemClassLoader：应用程序类加载器</li>
</ul>
<blockquote>
<p>类加载器的继承关系：System的父加载器为Extension，而Extension的父加载器为Bootstrap</p>
</blockquote>
</li>
</ul>
<figure data-type="image" tabindex="38"><img src="http://pic.zyblog.xyz/img/typora/20201211113018.png" alt="img" loading="lazy"></figure>
<pre><code class="language-java">public class Demo {
    public static void main(String[] args) {
        ClassLoader c1 = ClassLoader.getSystemClassLoader();
        System.out.println(c1);//AppClassLoader
        ClassLoader c2 = c1.getParent();
        System.out.println(c2);//ExtClassLoader
        ClassLoader c3 = c2.getParent();
        System.out.println(c3);//null
    }
}
//sun.misc.Launcher$AppClassLoader@18b4aac2
//sun.misc.Launcher$ExtClassLoader@1b6d3586
//null
</code></pre>
<h4 id="13-反射">1.3 反射</h4>
<figure data-type="image" tabindex="39"><img src="http://pic.zyblog.xyz/img/typora/20201211115906.png" alt="image-20201211115906252" loading="lazy"></figure>
<ul>
<li>
<p>概述：是指在运行时获取一个类的变量和方法信息。然后通过获取到的信息来创建对象，调用方法的一种机制，由于这种动态性，可以极大地增强程序的灵活性，程序不用在编译期就完成确定，在运行期仍然可以扩展</p>
</li>
<li>
<p>获取Class类的对象</p>
<ul>
<li>使用class属性，获取所属类对应的对象</li>
<li>使用getClass（）方法，获取所属类对应的对象（Object类中的方法）</li>
<li>使用Class类中的静态方法forName（String className），字符串参数为某个类的全路径</li>
</ul>
<pre><code class="language-java">public class Demo2 {
    public static void main(String[] args) {
        Class&lt;Student&gt; c1 = Student.class;
        Student stu = new Student();
        Class&lt;? extends Student&gt; c2 = stu.getClass();
        Class&lt;?&gt; c3 = null;
        try {
            c3 = Class.forName(&quot;com.demo.javase.Student&quot;);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;c1:&quot;+c1+&quot;\tc2:&quot;+c2+&quot;\tc3:&quot;+c3);
    }
}
//c1:class com.demo.javase.Student	c2:class com.demo.javase.Student	c3:class com.demo.javase.Student
</code></pre>
</li>
<li>
<p>反射获取构造方法并使用</p>
<ul>
<li>public Constructor&lt;?&gt;[ ]  getConstructors（）：获取所有public的构造方法</li>
<li>public Constructor&lt;?&gt;[ ]  getDeclaredConstructors（）：获取所有构造方法</li>
<li>public Constructor<T> getConstructor（Class&lt;?&gt; ... parameterTypes）：获取指定public构造方法</li>
<li>public Constructor<T> getDeclaredConstructor（Class&lt;?&gt; ... parameterTypes）：获取指定构造方法</li>
<li>public T newInstance（Object... initargs）：根据指定构造方法创建对象</li>
</ul>
</li>
</ul>
<pre><code class="language-java">//获取class对象
Class&lt;?&gt; c = Class.forName(&quot;com.demo.javase.Student&quot;);
Constructor&lt;?&gt;[] cons = c.getConstructors();
for(Constructor con : cons){
    System.out.println(con);
}
//public com.demo.javase.Student(java.lang.String,int)
//public com.demo.javase.Student()

Constructor&lt;?&gt;[] allCons = c.getDeclaredConstructors();
for (Constructor&lt;?&gt; allCon : allCons) {
	System.out.println(allCon);
}
//public com.demo.javase.Student(java.lang.String,int)
//com.demo.javase.Student(int)
//private com.demo.javase.Student(java.lang.String)
//public com.demo.javase.Student()

//基本类型和引用类型都可以通过class属性来获取对应的类对象
Constructor&lt;?&gt; con = c.getConstructor(String.class,int.class);
Object o = con.newInstance(&quot;zhiyuan&quot;,23);
System.out.println(o);
//学生{name='zhiyuan', age=23}

Constructor&lt;?&gt; con2 = c.getDeclaredConstructor(int.class);
System.out.println(con2.newInstance(22));
//学生{name='null', age=22}
//私有构造方法可以获取到但无法使用私有构造方法创建对象
Constructor&lt;?&gt; con3 = c.getDeclaredConstructor(String.class);
//System.out.println(con3.newInstance(&quot;zhiyuan&quot;));

</code></pre>
<ul>
<li>暴力反射（使用私有构造方法创建对象）</li>
</ul>
<pre><code class="language-java">//私有构造方法可以获取到但无法使用私有构造方法创建对象，若要使用，可以用暴力反射
Constructor&lt;?&gt; con3 = c.getDeclaredConstructor(String.class);
con3.setAccessible(true);
System.out.println(con3.newInstance(&quot;zhiyuan&quot;));
//学生{name='zhiyuan', age=0}
</code></pre>
<ul>
<li>反射获取成员变量并使用
<ul>
<li>public Field[ ] getFields（）：获取所有公共成员变量和类变量</li>
<li>public Field getField（String name）：获取指定公共成员变量和类变量</li>
<li>public Field[ ] getDeclaredFields（）：获取所有成员变量和类变量</li>
<li>public Field getDeclaredField（String name）：获取指定成员变量和类变量
<ul>
<li>Field类中用于给变量赋值的方法
<ul>
<li>public void set（Object obj，Object value）：给obj对象的成员变量赋值为value</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-java">Class&lt;?&gt; c = Class.forName(&quot;com.demo.javase.Student&quot;);
Field[] fields = c.getFields();
for (Field field : fields) {
	System.out.println(field);
}
//public java.lang.String com.demo.javase.Student.gender

Field[] declaredFields = c.getDeclaredFields();
for (Field declaredField : declaredFields) {
	System.out.println(declaredField);
}
//private java.lang.String com.demo.javase.Student.name
//private int com.demo.javase.Student.age
//int com.demo.javase.Student.count
//public java.lang.String com.demo.javase.Student.gender
//static int com.demo.javase.Student.num

Field genderField = c.getField(&quot;gender&quot;);
Constructor&lt;?&gt; con = c.getConstructor(String.class,int.class);
Object o = con.newInstance(&quot;zhiyuan&quot;,25);
genderField.set(o,&quot;male&quot;);
System.out.println(o);
//Student{name='zhiyuan', age=25, count=0, gender='male'}
</code></pre>
<ul>
<li>暴力反射（给私有成员变量赋值）</li>
</ul>
<pre><code class="language-java">Field nameField = c.getDeclaredField(&quot;name&quot;);
Object zhiyuan = con.newInstance(&quot;zhiyuan&quot;, 26);
nameField.setAccessible(true);
nameField.set(zhiyuan,&quot;zhiyuan002&quot;);
System.out.println(zhiyuan);
//Student{name='zhiyuan002', age=26, count=0, gender='null'}
</code></pre>
<ul>
<li>反射获取成员方法并使用
<ul>
<li>public Method [ ] getMethods（）：获取所有公共的方法（包含继承过来的方法）</li>
<li>public Method [ ] getDeclaredMethods（）：获取所有的方法（不包含继承过来的方法）</li>
<li>public Method getMethod（）：获取指定的公共方法</li>
<li>public Method getDeclaredMethod（）：获取指定的方法
<ul>
<li>Method类中用于使用方法的方法
<ul>
<li>public Object invoke（Object obj，Object... args）：obj为调用方法的对象，args是方法需要的参数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-java">Class&lt;?&gt; c = Class.forName(&quot;com.demo.javase.Student&quot;);
Method[] methods = c.getMethods();
for (Method method : methods) {
	System.out.println(method);
}
System.out.println(&quot;=================================================================&quot;);
Method[] declaredMethods = c.getDeclaredMethods();
for (Method declaredMethod : declaredMethods) {
	System.out.println(declaredMethod);
}
/*
public java.lang.String com.demo.javase.Student.toString()
public java.lang.String com.demo.javase.Student.getName()
public void com.demo.javase.Student.setName(java.lang.String)
public int com.demo.javase.Student.getAge()
public void com.demo.javase.Student.setAge(int)
public final void java.lang.Object.wait() throws java.lang.InterruptedException
public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException
public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException
public boolean java.lang.Object.equals(java.lang.Object)
public native int java.lang.Object.hashCode()
public final native java.lang.Class java.lang.Object.getClass()
public final native void java.lang.Object.notify()
public final native void java.lang.Object.notifyAll()
=================================================================
public java.lang.String com.demo.javase.Student.toString()
public java.lang.String com.demo.javase.Student.getName()
public void com.demo.javase.Student.setName(java.lang.String)
public int com.demo.javase.Student.getAge()
private void com.demo.javase.Student.show()
static void com.demo.javase.Student.why()
public void com.demo.javase.Student.setAge(int)
*/

Method setName = c.getMethod(&quot;getName&quot;);
Constructor&lt;?&gt; con = c.getConstructor(String.class, int.class);
Object zhiyuan = con.newInstance(&quot;zhiyuan&quot;, 22);
Object o = setName.invoke(zhiyuan);
System.out.println(o);
//zhiyuan

Method setName = c.getMethod(&quot;setName&quot;,String.class);
Constructor&lt;?&gt; con = c.getConstructor(String.class, int.class);
Object zhiyuan = con.newInstance(&quot;zhiyuan&quot;, 22);
Object o = setName.invoke(zhiyuan,&quot;Hulk&quot;);
System.out.println(o);
System.out.println(zhiyuan);
//null
//Student{name='Hulk', age=22, count=0, gender='null'}
</code></pre>
<ul>
<li>暴力反射（调用私有方法）</li>
</ul>
<pre><code class="language-java">Method show = c.getDeclaredMethod(&quot;show&quot;);
Constructor&lt;?&gt; con2 = c.getConstructor(String.class, int.class);
Object hulk = con2.newInstance(&quot;Hulk&quot;, 50);
show.setAccessible(true);
show.invoke(hulk);
</code></pre>
<h4 id="14-反射练习">1.4 反射练习</h4>
<ul>
<li>向**<code>ArrayList&lt;Integer&gt;</code>**集合中添加一个字符串数据</li>
</ul>
<pre><code class="language-java">ArrayList&lt;Integer&gt; integers = new ArrayList&lt;&gt;();
Class&lt;?&gt; c = integers.getClass();
Method add = c.getDeclaredMethod(&quot;add&quot;, Object.class);
add.invoke(integers,&quot;我吐&quot;);
add.invoke(integers,&quot;反射真神奇&quot;);
System.out.println(integers);
//[我吐, 反射真神奇]
</code></pre>
<h3 id="2-注解">2. 注解</h3>
<h4 id="21-概述">2.1 概述：</h4>
<ul>
<li>注解（Annotation），一种代码级别的说明，它是JDK1.5以后版本引入的一个特性，与类、接口、枚举在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等前面，用来对这些元素进行说明，注释。</li>
<li>作用：
<ol>
<li>编写文档：通过代码里的标识的注解生成文档</li>
<li>代码分析：通过代码里的标识的注解对代码进行分析（反射）</li>
<li>编译检查：通过代码里的标识的注解让编译器能够实现基本的编译检查（@Override）</li>
</ol>
</li>
</ul>
<h4 id="22-jdk预定义注解">2.2 JDK预定义注解</h4>
<ul>
<li>@Override：检测被该注解标注的方法是否继承自父类</li>
<li>@Deprecate：该注解标注的内容，表示已过时</li>
<li>@SuppressWarnings：压制警告
<ul>
<li>@SuppressWarnings(&quot;all&quot;)：压制所有警告</li>
</ul>
</li>
</ul>
<h4 id="23-自定义注解">2.3 自定义注解</h4>
<ul>
<li>格式：</li>
</ul>
<pre><code class="language-java">public @interface 注解名称{}
</code></pre>
<ul>
<li>本质：注解本质上就是一个接口，继承自java.lang.annotation.Annotation</li>
</ul>
<pre><code class="language-java">public interface MyAnno extends java.lang.annotation.Annotation{}
</code></pre>
<ul>
<li>
<p>属性：接口中可以定义的抽象方法</p>
<ul>
<li>要求：
<ol>
<li>属性的返回值类型
<ul>
<li>基本数据类型</li>
<li>String</li>
<li>枚举</li>
<li>注解</li>
<li>以上类型的数组</li>
</ul>
</li>
<li>定义了属性，需要给属性赋值
<ul>
<li>如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时可以不进行属性的赋值</li>
<li>如果只有一个属性需要赋值，并且属性名是value，则value可以忽略不写，直接定义值即可</li>
<li>数组赋值时，使用大括号{}包裹，如果数组中只有一个值，则大括号可以省略</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>元注解：用于描述注解的注解</p>
<ul>
<li>@Target：描述注解能够作用的范围
<ul>
<li>ElementType取值
<ul>
<li>TYPE：可以作用于类上，接口上，注解接口上，枚举类上</li>
<li>METHOD：可以作用于方法上</li>
<li>FIELD：可以作用于成员变量上，枚举常量上</li>
</ul>
</li>
</ul>
</li>
<li>@Retention：描述注解被保留的阶段
<ul>
<li>RetentionPolicy取值
<ul>
<li>SOURCE：注解保留到源码中，编译为字节码class文件中就不存在了</li>
<li>CLASS：注解保留在字节码class文件中，不必被JVM读取</li>
<li>RUNTIME：注解保留到字节码class文件中，并被JVM读取（可以通过反射方式读取）</li>
</ul>
</li>
</ul>
</li>
<li>@Documented：描述注解是否被抽取到api文档中</li>
<li>@Inherited：描述注解是否被子类继承</li>
</ul>
</li>
<li>
<p>在程序中使用注解：获取注解中定义的属性值</p>
<ul>
<li>获取注解定义的位置的对象</li>
<li>获取指定的注解
<ul>
<li>getAnnotation（Class）</li>
</ul>
</li>
<li>调用注解中的抽象方法获取配置的属性值</li>
</ul>
</li>
</ul>
<blockquote>
<p>小结：</p>
<ol>
<li>以后大多数时候，我们会使用注解，而不是自定义注解</li>
<li>注解给谁用：
<ol>
<li>编译器</li>
<li>解析程序</li>
</ol>
</li>
<li>注解不是程序的一部分</li>
</ol>
</blockquote>
<h4 id="24-代码实现">2.4 代码实现</h4>
<pre><code class="language-java">//简单的实现：解析注解属性值，调用方法
//材料：一个自定义注解，一个测试类，一个解析注解类

//1.自定义注解
@Target(value={ElementType.TYPE,ElementType.FIELD,ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
    public abstract String className();
    public abstract String methodName();
}
//2.测试类
public class AnnotationDemo {
    public void show(){
        System.out.println(&quot;show()方法&quot;);
    }
}
//3.注解解析类
@MyAnnotation(className = &quot;com.demo.javase.AnnotationDemo&quot;,methodName = &quot;show&quot;)
public class Demo1 {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException {
        //获取当前解析类的对象
        Class&lt;Demo1&gt; c = Demo1.class;
        //获取注解对象（本质上就是在内存中实现了一个注解的类的对象）
        MyAnnotation annotation = c.getAnnotation(MyAnnotation.class);
        /*
        * public MyAnnotionImp implements MyAnnotation{
        *   public String className(){
        *       return &quot;com.demo.javase.AnnotationDemo&quot;;
        *   }
        *   public String methodName(){
        *       return &quot;show&quot;;
        *   }
        * }
        * */
        //获取注解对象的属性值
        String className = annotation.className();
        String methodName = annotation.methodName();
        System.out.println(className);
        System.out.println(methodName);
        //获取测试类的对象
        Class&lt;?&gt; c2 = Class.forName(className);
        //创建测试类的实例化对象
        Object o = c2.newInstance();
        //获取对应名称的方法
        Method method = c2.getMethod(methodName);
        //执行方法
        method.invoke(o);
    }
}
</code></pre>
<pre><code class="language-java">//利用注解实现程序检错
//材料：一个自定义注解，一个测试类，一个解析注解检错类

//1.自定义注解
@Target(value={ElementType.TYPE,ElementType.METHOD,ElementType.FIELD})
@Retention(value = RetentionPolicy.RUNTIME)
@Documented
public @interface Check {
}
//2.测试类
public class Demo2 {
    @Check
    public void add(){
        System.out.println(&quot;1+0=&quot;+(1+0));
    }
    @Check
    public void subtract(){
        System.out.println(&quot;1-0=&quot;+(1-0));
    }
    @Check
    public void multiply(){
        System.out.println(&quot;1*0=&quot;+(1*0));
    }
    @Check
    public void divide(){
        System.out.println(&quot;1/0=&quot;+(1/0));
    }
}
//3.解析注解检错类
public class CheckDemo {
    public static void main(String[] args) throws IOException {
        Demo2 demo2 = new Demo2();
        Class&lt;? extends Demo2&gt; aClass = demo2.getClass();
        Method[] methods = aClass.getMethods();
        int number = 0;
        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;bug.txt&quot;,true));
        for (Method method : methods) {
            if(method.isAnnotationPresent(Check.class)){
                try {
                    method.invoke(demo2);
                } catch (Exception e){
                    number++;
                    bw.write(&quot;问题:&quot;+method.getName()+&quot;()方法出现异常&quot;);
                    bw.newLine();
                    bw.write(&quot;异常:&quot;+e.toString());
                    bw.newLine();
                }
            }
        }
        if(number &gt; 0){
            bw.write(&quot;类名：&quot;+ demo2.getClass().getName());
            bw.newLine();
            bw.write(&quot;本次总共检测到&quot;+number+&quot;个错误&quot;);
            bw.newLine();
            bw.write(&quot;检测时间：&quot;+new SimpleDateFormat(&quot;yyyy年MM月dd日 kk时mm分ss秒&quot;).format(new Date(System.currentTimeMillis())));
            bw.newLine();
        }else{
            bw.write(&quot;恭喜你，本次检测此程序没有错误&quot;);
        }
        bw.write(&quot;---------------------------------------------&quot;);
        bw.newLine();
        bw.flush();
        bw.close();
        System.out.println(number);
    }
}
//bug.txt的结果
/*
问题:divide()方法出现异常
异常:java.lang.reflect.InvocationTargetException
类名：com.demo.javase.demo.Demo2
本次总共检测到1个错误
检测时间：2020年12月15日 12时39分35秒
*/
</code></pre>
<blockquote>
<p>原文作者：絷缘<br>
作者邮箱：zhiyuanworkemail@163.com<br>
原文地址：<a href="https://zhiyuandnc.github.io/3pOEFSCc4/">https://zhiyuandnc.github.io/3pOEFSCc4/</a><br>
版权声明：本文为博主原创文章，转载请注明原文链接作者信息</p>
</blockquote>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://zhiyuandnc.github.io/IW8mQ0Bvy/" class="post-title gt-a-link">
                    常用API收集（第一期：2021.2.19）
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">事实不以人的意志为转移</div>
    <div class="social-container">
        
            
                <a href="#" target="_blank">
                    <i class="fab fa-github gt-c-content-color-first"></i>
                </a>
            
        
            
                <a href="#" target="_blank">
                    <i class="fab fa-telegram gt-c-content-color-first"></i>
                </a>
            
        
            
                <a href="#" target="_blank">
                    <i class="fab fa-qq gt-c-content-color-first"></i>
                </a>
            
        
            
                <a href="#" target="_blank">
                    <i class="fab fa-bilibili gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Copyright&ensp;&copy;&ensp;絷缘的博客<br/><a href="https://beian.miit.gov.cn/" target="_blank">晋ICP备20001723号-1</a>
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://zhiyuandnc.github.io/atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>
